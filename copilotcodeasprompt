Directory Structure:

└── ./
    ├── CopilotKit
    │   ├── examples
    │   │   ├── next-openai
    │   │   │   ├── src
    │   │   │   │   ├── app
    │   │   │   │   │   ├── api
    │   │   │   │   │   │   ├── copilotkit
    │   │   │   │   │   │   │   ├── anthropic
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── azure
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── gemini
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── gpt-newspaper
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── langchain
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── openai
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── presentation
    │   │   │   │   │   │   │   │   ├── research.ts
    │   │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   │   ├── travel
    │   │   │   │   │   │   │   │   ├── route.ts
    │   │   │   │   │   │   │   │   └── tavily.ts
    │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   ├── transcribe
    │   │   │   │   │   │   │   └── route.ts
    │   │   │   │   │   │   └── tts
    │   │   │   │   │   │       └── route.ts
    │   │   │   │   │   ├── components
    │   │   │   │   │   │   ├── ActionButton.tsx
    │   │   │   │   │   │   ├── destination-row.tsx
    │   │   │   │   │   │   ├── destination-table.tsx
    │   │   │   │   │   │   ├── Presentation.tsx
    │   │   │   │   │   │   ├── Slide.tsx
    │   │   │   │   │   │   ├── vacation-list.tsx
    │   │   │   │   │   │   └── vacation-notes.tsx
    │   │   │   │   │   ├── presentation
    │   │   │   │   │   │   ├── actions
    │   │   │   │   │   │   │   ├── useAppendSlide.tsx
    │   │   │   │   │   │   │   └── useUpdateSlide.tsx
    │   │   │   │   │   │   ├── components
    │   │   │   │   │   │   │   ├── buttons
    │   │   │   │   │   │   │   │   ├── ActionButton.tsx
    │   │   │   │   │   │   │   │   ├── AddSlideButton.tsx
    │   │   │   │   │   │   │   │   ├── DeleteSlideButton.tsx
    │   │   │   │   │   │   │   │   ├── GenerateSlideButton.tsx
    │   │   │   │   │   │   │   │   ├── NavButton.tsx
    │   │   │   │   │   │   │   │   ├── PerformResearchSwitch.tsx
    │   │   │   │   │   │   │   │   └── SpeakCurrentSlideButton.tsx
    │   │   │   │   │   │   │   ├── main
    │   │   │   │   │   │   │   │   ├── Header.tsx
    │   │   │   │   │   │   │   │   ├── Presentation.tsx
    │   │   │   │   │   │   │   │   └── Slide.tsx
    │   │   │   │   │   │   │   └── misc
    │   │   │   │   │   │   │       ├── SlideNumberIndicator.tsx
    │   │   │   │   │   │   │       └── SlidePreview.tsx
    │   │   │   │   │   │   ├── utils
    │   │   │   │   │   │   │   └── globalAudio.tsx
    │   │   │   │   │   │   ├── page.tsx
    │   │   │   │   │   │   ├── styles.css
    │   │   │   │   │   │   └── types.ts
    │   │   │   │   │   ├── textarea
    │   │   │   │   │   │   └── page.tsx
    │   │   │   │   │   ├── travel
    │   │   │   │   │   │   ├── page.tsx
    │   │   │   │   │   │   └── styles.css
    │   │   │   │   │   ├── layout.tsx
    │   │   │   │   │   ├── page.tsx
    │   │   │   │   │   └── utils.ts
    │   │   │   │   └── styles
    │   │   │   │       └── globals.css
    │   │   │   ├── .eslintrc.js
    │   │   │   ├── next-env.d.ts
    │   │   │   ├── next.config.js
    │   │   │   ├── postcss.config.js
    │   │   │   └── tailwind.config.js
    │   │   ├── next-pages-router
    │   │   │   ├── pages
    │   │   │   │   ├── api
    │   │   │   │   │   ├── copilotkit.ts
    │   │   │   │   │   └── hello.ts
    │   │   │   │   ├── _app.tsx
    │   │   │   │   ├── _document.tsx
    │   │   │   │   └── index.tsx
    │   │   │   ├── styles
    │   │   │   │   └── globals.css
    │   │   │   ├── .eslintrc.js
    │   │   │   └── tailwind.config.ts
    │   │   ├── node-express
    │   │   │   ├── src
    │   │   │   │   └── index.ts
    │   │   │   └── .eslintrc.js
    │   │   └── node-http
    │   │       ├── src
    │   │       │   └── index.ts
    │   │       └── .eslintrc.js
    │   ├── packages
    │   │   ├── react-core
    │   │   │   ├── src
    │   │   │   │   ├── components
    │   │   │   │   │   ├── copilot-provider
    │   │   │   │   │   │   ├── copilotkit-props.tsx
    │   │   │   │   │   │   ├── copilotkit.tsx
    │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── context
    │   │   │   │   │   ├── copilot-context.tsx
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── hooks
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── use-chat.ts
    │   │   │   │   │   ├── use-coagent-state-render.ts
    │   │   │   │   │   ├── use-coagent.ts
    │   │   │   │   │   ├── use-copilot-action.ts
    │   │   │   │   │   ├── use-copilot-chat.ts
    │   │   │   │   │   ├── use-copilot-readable.ts
    │   │   │   │   │   ├── use-flat-category-store.ts
    │   │   │   │   │   ├── use-make-copilot-document-readable.ts
    │   │   │   │   │   └── use-tree.ts
    │   │   │   │   ├── lib
    │   │   │   │   │   ├── copilot-task.ts
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── types
    │   │   │   │   │   ├── chat-suggestion-configuration.ts
    │   │   │   │   │   ├── coagent-action.ts
    │   │   │   │   │   ├── coagent-state.ts
    │   │   │   │   │   ├── document-pointer.ts
    │   │   │   │   │   ├── frontend-action.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   └── system-message.ts
    │   │   │   │   ├── utils
    │   │   │   │   │   ├── extract.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── utils.test.ts
    │   │   │   │   │   └── utils.ts
    │   │   │   │   └── index.tsx
    │   │   │   ├── jest.config.js
    │   │   │   └── tsup.config.ts
    │   │   ├── react-textarea
    │   │   │   ├── src
    │   │   │   │   ├── components
    │   │   │   │   │   ├── base-copilot-textarea
    │   │   │   │   │   │   ├── base-copilot-textarea.css
    │   │   │   │   │   │   ├── base-copilot-textarea.tsx
    │   │   │   │   │   │   ├── render-element.tsx
    │   │   │   │   │   │   ├── render-placeholder.tsx
    │   │   │   │   │   │   ├── track-cursor-moved-since-last-text-change.tsx
    │   │   │   │   │   │   └── use-add-branding-css.tsx
    │   │   │   │   │   ├── copilot-textarea
    │   │   │   │   │   │   └── copilot-textarea.tsx
    │   │   │   │   │   ├── hovering-toolbar
    │   │   │   │   │   │   ├── text-insertion-prompt-box
    │   │   │   │   │   │   │   ├── hovering-insertion-prompt-box-core.tsx
    │   │   │   │   │   │   │   ├── hovering-insertion-prompt-box.tsx
    │   │   │   │   │   │   │   ├── included-files-preview.tsx
    │   │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   │   ├── hovering-editor-provider.tsx
    │   │   │   │   │   │   ├── hovering-toolbar-components.tsx
    │   │   │   │   │   │   └── hovering-toolbar.tsx
    │   │   │   │   │   ├── manual-ui
    │   │   │   │   │   │   └── chip-with-icon.tsx
    │   │   │   │   │   ├── source-search-box
    │   │   │   │   │   │   └── source-search-box.tsx
    │   │   │   │   │   ├── ui
    │   │   │   │   │   │   ├── button.tsx
    │   │   │   │   │   │   ├── command.tsx
    │   │   │   │   │   │   ├── dialog.tsx
    │   │   │   │   │   │   └── label.tsx
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── context
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── hooks
    │   │   │   │   │   ├── base-copilot-textarea-implementation
    │   │   │   │   │   │   ├── use-autosuggestions.ts
    │   │   │   │   │   │   ├── use-copilot-textarea-editor.tsx
    │   │   │   │   │   │   └── use-populate-copilot-textarea-ref.ts
    │   │   │   │   │   ├── make-autosuggestions-function
    │   │   │   │   │   │   ├── use-make-standard-autosuggestions-function.tsx
    │   │   │   │   │   │   └── use-make-standard-insertion-function.tsx
    │   │   │   │   │   ├── misc
    │   │   │   │   │   │   └── use-autosize-textarea.tsx
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── lib
    │   │   │   │   │   ├── slatejs-edits
    │   │   │   │   │   │   ├── add-autocompletions.ts
    │   │   │   │   │   │   ├── clear-autocompletions.ts
    │   │   │   │   │   │   ├── replace-text.ts
    │   │   │   │   │   │   └── with-partial-history.ts
    │   │   │   │   │   ├── debouncer.ts
    │   │   │   │   │   ├── editor-to-text.ts
    │   │   │   │   │   ├── get-text-around-cursor.ts
    │   │   │   │   │   ├── retry.tsx
    │   │   │   │   │   ├── stream-promise-flatten.ts
    │   │   │   │   │   ├── utils.test.ts
    │   │   │   │   │   └── utils.ts
    │   │   │   │   ├── types
    │   │   │   │   │   ├── autosuggestions-config
    │   │   │   │   │   │   ├── subtypes
    │   │   │   │   │   │   │   └── make-system-prompt.ts
    │   │   │   │   │   │   ├── autosuggestions-config-user-specified.tsx
    │   │   │   │   │   │   ├── autosuggestions-config.tsx
    │   │   │   │   │   │   ├── editing-api-config.tsx
    │   │   │   │   │   │   ├── index.ts
    │   │   │   │   │   │   ├── insertions-api-config.tsx
    │   │   │   │   │   │   └── suggestions-api-config.tsx
    │   │   │   │   │   ├── base
    │   │   │   │   │   │   ├── autosuggestion-state.ts
    │   │   │   │   │   │   ├── autosuggestions-bare-function.ts
    │   │   │   │   │   │   ├── base-autosuggestions-config.tsx
    │   │   │   │   │   │   ├── base-copilot-textarea-props.tsx
    │   │   │   │   │   │   ├── custom-editor.tsx
    │   │   │   │   │   │   ├── editor-autocomplete-state.ts
    │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   ├── html-copilot-textarea-element.ts
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── index.tsx
    │   │   │   │   └── styles.css
    │   │   │   ├── jest.config.js
    │   │   │   ├── postcss.config.js
    │   │   │   ├── tailwind.config.js
    │   │   │   └── tsup.config.ts
    │   │   ├── react-ui
    │   │   │   ├── src
    │   │   │   │   ├── components
    │   │   │   │   │   ├── chat
    │   │   │   │   │   │   ├── messages
    │   │   │   │   │   │   │   ├── RenderActionExecutionMessage.tsx
    │   │   │   │   │   │   │   ├── RenderAgentStateMessage.tsx
    │   │   │   │   │   │   │   ├── RenderResultMessage.tsx
    │   │   │   │   │   │   │   └── RenderTextMessage.tsx
    │   │   │   │   │   │   ├── Button.tsx
    │   │   │   │   │   │   ├── Chat.tsx
    │   │   │   │   │   │   ├── ChatContext.tsx
    │   │   │   │   │   │   ├── CodeBlock.tsx
    │   │   │   │   │   │   ├── Header.tsx
    │   │   │   │   │   │   ├── Icons.tsx
    │   │   │   │   │   │   ├── index.tsx
    │   │   │   │   │   │   ├── Input.tsx
    │   │   │   │   │   │   ├── Markdown.tsx
    │   │   │   │   │   │   ├── Messages.tsx
    │   │   │   │   │   │   ├── Modal.tsx
    │   │   │   │   │   │   ├── Popup.tsx
    │   │   │   │   │   │   ├── props.ts
    │   │   │   │   │   │   ├── Response.tsx
    │   │   │   │   │   │   ├── Sidebar.tsx
    │   │   │   │   │   │   ├── Suggestion.tsx
    │   │   │   │   │   │   ├── Textarea.tsx
    │   │   │   │   │   │   └── Window.tsx
    │   │   │   │   │   ├── dev-console
    │   │   │   │   │   │   ├── console.tsx
    │   │   │   │   │   │   ├── icons.tsx
    │   │   │   │   │   │   ├── index.tsx
    │   │   │   │   │   │   ├── types.ts
    │   │   │   │   │   │   └── utils.ts
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── context
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── css
    │   │   │   │   │   ├── animations.css
    │   │   │   │   │   ├── button.css
    │   │   │   │   │   ├── colors.css
    │   │   │   │   │   ├── console.css
    │   │   │   │   │   ├── header.css
    │   │   │   │   │   ├── input.css
    │   │   │   │   │   ├── markdown.css
    │   │   │   │   │   ├── messages.css
    │   │   │   │   │   ├── panel.css
    │   │   │   │   │   ├── popup.css
    │   │   │   │   │   ├── response.css
    │   │   │   │   │   ├── sidebar.css
    │   │   │   │   │   ├── suggestions.css
    │   │   │   │   │   └── window.css
    │   │   │   │   ├── hooks
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── use-copilot-chat-suggestions.tsx
    │   │   │   │   │   ├── use-copy-to-clipboard.tsx
    │   │   │   │   │   └── use-push-to-talk.tsx
    │   │   │   │   ├── lib
    │   │   │   │   │   ├── utils.test.ts
    │   │   │   │   │   └── utils.ts
    │   │   │   │   ├── types
    │   │   │   │   │   ├── css.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   └── suggestions.ts
    │   │   │   │   ├── index.tsx
    │   │   │   │   └── styles.css
    │   │   │   ├── jest.config.js
    │   │   │   ├── postcss.config.js
    │   │   │   ├── tailwind.config.js
    │   │   │   └── tsup.config.ts
    │   │   ├── runtime
    │   │   │   ├── scripts
    │   │   │   │   └── generate-gql-schema.ts
    │   │   │   ├── src
    │   │   │   │   ├── agents
    │   │   │   │   │   └── langgraph
    │   │   │   │   │       ├── event-source.ts
    │   │   │   │   │       └── events.ts
    │   │   │   │   ├── graphql
    │   │   │   │   │   ├── inputs
    │   │   │   │   │   │   ├── action.input.ts
    │   │   │   │   │   │   ├── agent-session.input.ts
    │   │   │   │   │   │   ├── agent-state.input.ts
    │   │   │   │   │   │   ├── cloud-guardrails.input.ts
    │   │   │   │   │   │   ├── cloud.input.ts
    │   │   │   │   │   │   ├── context-property.input.ts
    │   │   │   │   │   │   ├── custom-property.input.ts
    │   │   │   │   │   │   ├── forwarded-parameters.input.ts
    │   │   │   │   │   │   ├── frontend.input.ts
    │   │   │   │   │   │   ├── generate-copilot-response.input.ts
    │   │   │   │   │   │   └── message.input.ts
    │   │   │   │   │   ├── resolvers
    │   │   │   │   │   │   └── copilot.resolver.ts
    │   │   │   │   │   └── types
    │   │   │   │   │       ├── base
    │   │   │   │   │       │   └── index.ts
    │   │   │   │   │       ├── converted
    │   │   │   │   │       │   └── index.ts
    │   │   │   │   │       ├── copilot-response.type.ts
    │   │   │   │   │       ├── enums.ts
    │   │   │   │   │       ├── guardrails-result.type.ts
    │   │   │   │   │       ├── message-status.type.ts
    │   │   │   │   │       └── response-status.type.ts
    │   │   │   │   ├── lib
    │   │   │   │   │   ├── cloud
    │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   ├── integrations
    │   │   │   │   │   │   ├── nest
    │   │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   │   ├── nextjs
    │   │   │   │   │   │   │   ├── app-router.ts
    │   │   │   │   │   │   │   └── pages-router.ts
    │   │   │   │   │   │   ├── node-express
    │   │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   │   ├── node-http
    │   │   │   │   │   │   │   └── index.ts
    │   │   │   │   │   │   ├── index.ts
    │   │   │   │   │   │   └── shared.ts
    │   │   │   │   │   ├── runtime
    │   │   │   │   │   │   ├── copilot-runtime.ts
    │   │   │   │   │   │   └── remote-actions.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── logger.ts
    │   │   │   │   │   └── telemetry-client.ts
    │   │   │   │   ├── service-adapters
    │   │   │   │   │   ├── anthropic
    │   │   │   │   │   │   ├── anthropic-adapter.ts
    │   │   │   │   │   │   └── utils.ts
    │   │   │   │   │   ├── experimental
    │   │   │   │   │   │   └── ollama
    │   │   │   │   │   │       └── ollama-adapter.ts
    │   │   │   │   │   ├── google
    │   │   │   │   │   │   ├── google-genai-adapter.ts
    │   │   │   │   │   │   └── utils.ts
    │   │   │   │   │   ├── groq
    │   │   │   │   │   │   └── groq-adapter.ts
    │   │   │   │   │   ├── langchain
    │   │   │   │   │   │   ├── langchain-adapter.ts
    │   │   │   │   │   │   ├── langserve.ts
    │   │   │   │   │   │   ├── types.ts
    │   │   │   │   │   │   └── utils.ts
    │   │   │   │   │   ├── openai
    │   │   │   │   │   │   ├── openai-adapter.ts
    │   │   │   │   │   │   ├── openai-assistant-adapter.ts
    │   │   │   │   │   │   └── utils.ts
    │   │   │   │   │   ├── unify
    │   │   │   │   │   │   └── unify-adapter.ts
    │   │   │   │   │   ├── conversion.ts
    │   │   │   │   │   ├── events.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   └── service-adapter.ts
    │   │   │   │   ├── utils
    │   │   │   │   │   ├── failed-response-status-reasons.ts
    │   │   │   │   │   └── index.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── .eslintrc.js
    │   │   │   ├── jest.config.js
    │   │   │   └── tsup.config.ts
    │   │   ├── runtime-client-gql
    │   │   │   ├── src
    │   │   │   │   ├── client
    │   │   │   │   │   ├── conversion.ts
    │   │   │   │   │   ├── CopilotRuntimeClient.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   └── types.ts
    │   │   │   │   ├── graphql
    │   │   │   │   │   └── definitions
    │   │   │   │   │       └── mutations.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── codegen.ts
    │   │   │   ├── jest.config.js
    │   │   │   └── tsup.config.ts
    │   │   └── shared
    │   │       ├── src
    │   │       │   ├── constants
    │   │       │   │   └── index.ts
    │   │       │   ├── telemetry
    │   │       │   │   ├── events.ts
    │   │       │   │   ├── index.ts
    │   │       │   │   ├── security-check.ts
    │   │       │   │   ├── telemetry-client.ts
    │   │       │   │   └── utils.ts
    │   │       │   ├── types
    │   │       │   │   ├── action.ts
    │   │       │   │   ├── copilot-cloud-config.ts
    │   │       │   │   ├── index.ts
    │   │       │   │   └── openai-assistant.ts
    │   │       │   ├── utils
    │   │       │   │   ├── index.ts
    │   │       │   │   ├── json-schema.ts
    │   │       │   │   └── random-id.ts
    │   │       │   └── index.ts
    │   │       ├── jest.config.js
    │   │       └── tsup.config.ts
    │   ├── scripts
    │   │   ├── docs
    │   │   │   ├── lib
    │   │   │   │   ├── comments.ts
    │   │   │   │   ├── files.ts
    │   │   │   │   ├── mdx.ts
    │   │   │   │   ├── reference-doc.ts
    │   │   │   │   └── source.ts
    │   │   │   └── gen.ts
    │   │   └── qa
    │   │       └── lib
    │   │           ├── actions
    │   │           │   ├── bad
    │   │           │   │   ├── array.ts
    │   │           │   │   ├── enum.ts
    │   │           │   │   ├── noargs.ts
    │   │           │   │   ├── object.ts
    │   │           │   │   └── optional.ts
    │   │           │   └── good
    │   │           │       ├── array.ts
    │   │           │       ├── enum.ts
    │   │           │       ├── noargs.ts
    │   │           │       ├── object.ts
    │   │           │       └── optional.ts
    │   │           ├── css
    │   │           │   ├── page.tsx
    │   │           │   └── route.ts
    │   │           ├── firebase
    │   │           │   ├── index.ts
    │   │           │   └── page.tsx
    │   │           ├── langchain
    │   │           │   ├── page.tsx
    │   │           │   └── route.ts
    │   │           ├── langserve
    │   │           │   ├── app
    │   │           │   │   └── server.py
    │   │           │   └── next
    │   │           │       ├── page.tsx
    │   │           │       └── route.ts
    │   │           ├── next
    │   │           │   ├── page.tsx
    │   │           │   └── route.ts
    │   │           ├── next-pages
    │   │           │   ├── copilotkit.ts
    │   │           │   └── index.tsx
    │   │           ├── node
    │   │           │   ├── express.ts
    │   │           │   ├── page.tsx
    │   │           │   └── server.ts
    │   │           ├── remix
    │   │           │   ├── _index.tsx
    │   │           │   └── copilotkit.tsx
    │   │           ├── upgrade-express
    │   │           │   ├── new
    │   │           │   │   ├── page.tsx
    │   │           │   │   └── server.ts
    │   │           │   └── old
    │   │           │       ├── page.tsx
    │   │           │       └── server.ts
    │   │           ├── upgrade-next-app
    │   │           │   ├── new
    │   │           │   │   ├── page.tsx
    │   │           │   │   └── route.ts
    │   │           │   └── old
    │   │           │       ├── page.tsx
    │   │           │       └── route.ts
    │   │           ├── upgrade-next-pages
    │   │           │   ├── new
    │   │           │   │   ├── page.tsx
    │   │           │   │   └── route.ts
    │   │           │   └── old
    │   │           │       ├── page.tsx
    │   │           │       └── route.ts
    │   │           └── upgrade-node
    │   │               ├── new
    │   │               │   ├── page.tsx
    │   │               │   └── server.ts
    │   │               └── old
    │   │                   ├── page.tsx
    │   │                   └── server.ts
    │   ├── utilities
    │   │   ├── eslint-config-custom
    │   │   │   └── index.js
    │   │   └── tailwind-config
    │   │       └── tailwind.config.js
    │   └── .eslintrc.js
    ├── docs
    │   ├── app
    │   │   ├── (home)
    │   │   │   ├── [[...slug]]
    │   │   │   │   └── page.tsx
    │   │   │   └── layout.tsx
    │   │   ├── api
    │   │   │   └── search
    │   │   │       └── route.ts
    │   │   ├── og
    │   │   │   └── [...slug]
    │   │   │       └── route.tsx
    │   │   ├── global.css
    │   │   ├── layout.config.tsx
    │   │   ├── layout.tsx
    │   │   ├── logo.tsx
    │   │   ├── sitemap.ts
    │   │   └── source.ts
    │   ├── components
    │   │   ├── layout
    │   │   │   └── top-bar.tsx
    │   │   ├── react
    │   │   │   ├── coagents
    │   │   │   │   ├── coagents-enterprise-cta.tsx
    │   │   │   │   └── coagents-features.tsx
    │   │   │   ├── copilotkit-css.tsx
    │   │   │   ├── dynamic-content-wrapper.tsx
    │   │   │   ├── frame.tsx
    │   │   │   ├── property-reference.tsx
    │   │   │   ├── select-llm-provider.tsx
    │   │   │   ├── subdocs-menu.tsx
    │   │   │   ├── test-react-component.tsx
    │   │   │   └── youtube-video.tsx
    │   │   └── ui
    │   │       └── button.tsx
    │   ├── lib
    │   │   ├── hooks
    │   │   │   ├── use-rb2b.tsx
    │   │   │   └── use-tailored-content.tsx
    │   │   ├── icons
    │   │   │   ├── custom-icons.tsx
    │   │   │   └── index.tsx
    │   │   ├── providers
    │   │   │   ├── posthog-provider.tsx
    │   │   │   ├── providers-wrapper.tsx
    │   │   │   └── scarf-pixel.tsx
    │   │   └── utils.ts
    │   ├── next-env.d.ts
    │   ├── postcss.config.js
    │   ├── props.ts
    │   ├── source.config.ts
    │   └── tailwind.config.js
    └── examples
        ├── coagents-ai-researcher
        │   ├── agent
        │   │   └── ai_researcher
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       ├── demo.py
        │   │       ├── extract.py
        │   │       ├── model.py
        │   │       ├── search.py
        │   │       ├── state.py
        │   │       ├── steps.py
        │   │       └── summarize.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   └── page.tsx
        │       ├── components
        │       │   ├── ui
        │       │   │   ├── accordion.tsx
        │       │   │   ├── background-beams.tsx
        │       │   │   ├── button.tsx
        │       │   │   ├── card.tsx
        │       │   │   ├── input.tsx
        │       │   │   ├── meteors.tsx
        │       │   │   ├── skeleton.tsx
        │       │   │   └── textarea.tsx
        │       │   ├── AnswerMarkdown.tsx
        │       │   ├── HomeView.tsx
        │       │   ├── Progress.tsx
        │       │   ├── ResearchWrapper.tsx
        │       │   ├── ResultsView.tsx
        │       │   └── SkeletonLoader.tsx
        │       ├── lib
        │       │   ├── research-provider.tsx
        │       │   └── utils.ts
        │       └── tailwind.config.ts
        ├── coagents-qa
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   ├── Mailer.tsx
        │       │   └── page.tsx
        │       └── tailwind.config.ts
        ├── coagents-qa-native
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   ├── Mailer.tsx
        │       │   └── page.tsx
        │       └── tailwind.config.ts
        ├── coagents-qa-text
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── Greeter.tsx
        │       │   ├── layout.tsx
        │       │   └── page.tsx
        │       └── tailwind.config.ts
        ├── coagents-shared-state
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   ├── page.tsx
        │       │   └── Translator.tsx
        │       └── tailwind.config.ts
        ├── coagents-starter
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   ├── page.tsx
        │       │   └── Translator.tsx
        │       └── tailwind.config.ts
        ├── coagents-streaming
        │   ├── agent
        │   │   └── my_agent
        │   │       ├── __init__.py
        │   │       ├── agent.py
        │   │       └── demo.py
        │   └── ui
        │       ├── app
        │       │   ├── api
        │       │   │   └── copilotkit
        │       │   │       └── route.ts
        │       │   ├── globals.css
        │       │   ├── layout.tsx
        │       │   ├── page.tsx
        │       │   └── Translator.tsx
        │       └── tailwind.config.ts
        └── coagents-wait-user-input
            ├── agent
            │   └── my_agent
            │       ├── __init__.py
            │       ├── agent.py
            │       └── demo.py
            └── ui
                ├── app
                │   ├── api
                │   │   └── copilotkit
                │   │       └── route.ts
                │   ├── globals.css
                │   ├── layout.tsx
                │   ├── page.tsx
                │   └── WaitForUserInput.tsx
                └── tailwind.config.ts



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/anthropic/route.ts
---

import {
  CopilotRuntime,
  AnthropicAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { NextRequest } from "next/server";

export const POST = async (req: NextRequest) => {
  const runtime = new CopilotRuntime({});

  const serviceAdapter = new AnthropicAdapter();

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/azure/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { NextRequest } from "next/server";
import OpenAI from "openai";

const AZURE_OPENAI_API_KEY = "AZURE_OPENAI_API_KEY";

export const POST = async (req: NextRequest) => {
  // The name of your Azure OpenAI Instance.
  // https://learn.microsoft.com/en-us/azure/cognitive-services/openai/how-to/create-resource?pivots=web-portal#create-a-resource
  const instance = "<your instance name>";

  // Corresponds to your Model deployment within your OpenAI resource, e.g. my-gpt35-16k-deployment
  // Navigate to the Azure OpenAI Studio to deploy a model.
  const model = "<your model>";

  const apiKey = process.env[AZURE_OPENAI_API_KEY];
  if (!apiKey) {
    throw new Error("The AZURE_OPENAI_API_KEY environment variable is missing or empty.");
  }

  const openai = new OpenAI({
    apiKey,
    baseURL: `https://${instance}.openai.azure.com/openai/deployments/${model}`,
    defaultQuery: { "api-version": "2024-04-01-preview" },
    defaultHeaders: { "api-key": apiKey },
  });

  const runtime = new CopilotRuntime();
  const serviceAdapter = new OpenAIAdapter({ openai });

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/gemini/route.ts
---

import {
  CopilotRuntime,
  GoogleGenerativeAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { NextRequest } from "next/server";

const env = process.env;

export const POST = async (req: NextRequest) => {
  const runtime = new CopilotRuntime();

  const genAI = new GoogleGenerativeAI(env["GOOGLE_API_KEY"]!);
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });
  const serviceAdapter = new GoogleGenerativeAIAdapter({ model });

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/gpt-newspaper/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { NextRequest } from "next/server";

// -----------------
// To run this example:
// - clone https://github.com/mme/gpt-newspaper
// - follow the instructions in NOTES.md
// -----------------

export const POST = async (req: NextRequest) => {
  const runtime = new CopilotRuntime({
    actions: [
      {
        name: "research",
        description:
          "Call this function when the user requests research on a certain topic. After researching, make a presentation.",
        parameters: [
          {
            name: "topic",
            type: "string",
            description: "The topic to research.",
          },
        ],
        handler: async ({ topic }) => {
          const response = await fetch("http://localhost:8000/generate_newspaper_html", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              topics: [topic],
              layout: "layout_1.html",
            }),
          });

          // return the html from the newspaper generator
          return await response.text();
        },
      },
    ],
  });

  const serviceAdapter = new OpenAIAdapter();

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/langchain/route.ts
---

import {
  CopilotRuntime,
  LangChainAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";

import { ChatOpenAI } from "@langchain/openai";
import { NextRequest } from "next/server";

export const POST = async (req: NextRequest) => {
  const runtime = new CopilotRuntime({
    actions: [
      {
        name: "sayHello",
        description: "Says hello to someone.",
        parameters: [
          {
            name: "arg",
            type: "string",
            description: "The name of the person to say hello to.",
            required: true,
          },
        ],
        handler: async ({ arg }) => {
          console.log("Hello from the server", arg, "!");
        },
      },
    ],
  });

  const serviceAdapter = new LangChainAdapter({
    chainFn: async ({ messages, tools }) => {
      const model = new ChatOpenAI({ modelName: "gpt-4-1106-preview" });

      return model.stream(messages, { tools });
    },
  });

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/openai/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { NextRequest } from "next/server";

export const POST = async (req: NextRequest) => {
  const runtime = new CopilotRuntime({});

  const serviceAdapter = new OpenAIAdapter();

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/presentation/research.ts
---

/**
 * This is a port of GPT Newspaper to LangGraph JS, adapted from the original Python code.
 *
 * https://github.com/assafelovic/gpt-newspaper
 */
import { HumanMessage, SystemMessage } from "@langchain/core/messages";
import { ChatOpenAI } from "@langchain/openai";
import { StateGraph, END } from "@langchain/langgraph";
import { RunnableLambda } from "@langchain/core/runnables";
import { TavilySearchAPIRetriever } from "@langchain/community/retrievers/tavily_search_api";

interface AgentState {
  topic: string;
  searchResults?: string;
  article?: string;
  critique?: string;
}

function model() {
  return new ChatOpenAI({
    temperature: 0,
    modelName: "gpt-4-1106-preview",
  });
}

async function search(state: { agentState: AgentState }): Promise<{ agentState: AgentState }> {
  const retriever = new TavilySearchAPIRetriever({
    k: 10,
  });
  let topic = state.agentState.topic;
  // must be at least 5 characters long
  if (topic.length < 5) {
    topic = "topic: " + topic;
  }
  const docs = await retriever.getRelevantDocuments(topic);
  return {
    agentState: {
      ...state.agentState,
      searchResults: JSON.stringify(docs),
    },
  };
}

async function curate(state: { agentState: AgentState }): Promise<{ agentState: AgentState }> {
  const response = await model().invoke(
    [
      new SystemMessage(
        `You are a personal newspaper editor. 
         Your sole task is to return a list of URLs of the 5 most relevant articles for the provided topic or query as a JSON list of strings
         in this format:
         {
          urls: ["url1", "url2", "url3", "url4", "url5"]
         }
         .`.replace(/\s+/g, " "),
      ),
      new HumanMessage(
        `Today's date is ${new Date().toLocaleDateString("en-GB")}.
       Topic or Query: ${state.agentState.topic}
       
       Here is a list of articles:
       ${state.agentState.searchResults}`.replace(/\s+/g, " "),
      ),
    ],
    {
      response_format: {
        type: "json_object",
      },
    },
  );
  const urls = JSON.parse(response.content as string).urls;
  const searchResults = JSON.parse(state.agentState.searchResults!);
  const newSearchResults = searchResults.filter((result: any) => {
    return urls.includes(result.metadata.source);
  });
  return {
    agentState: {
      ...state.agentState,
      searchResults: JSON.stringify(newSearchResults),
    },
  };
}

async function critique(state: { agentState: AgentState }): Promise<{ agentState: AgentState }> {
  let feedbackInstructions = "";
  if (state.agentState.critique) {
    feedbackInstructions =
      `The writer has revised the article based on your previous critique: ${state.agentState.critique}
       The writer might have left feedback for you encoded between <FEEDBACK> tags.
       The feedback is only for you to see and will be removed from the final article.
    `.replace(/\s+/g, " ");
  }
  const response = await model().invoke([
    new SystemMessage(
      `You are a personal newspaper writing critique. Your sole purpose is to provide short feedback on a written 
      article so the writer will know what to fix.       
      Today's date is ${new Date().toLocaleDateString("en-GB")}
      Your task is to provide a really short feedback on the article only if necessary.
      if you think the article is good, please return [DONE].
      you can provide feedback on the revised article or just
      return [DONE] if you think the article is good.
      Please return a string of your critique or [DONE].`.replace(/\s+/g, " "),
    ),
    new HumanMessage(
      `${feedbackInstructions}
       This is the article: ${state.agentState.article}`,
    ),
  ]);
  const content = response.content as string;
  console.log("critique:", content);
  return {
    agentState: {
      ...state.agentState,
      critique: content.includes("[DONE]") ? undefined : content,
    },
  };
}

async function write(state: { agentState: AgentState }): Promise<{ agentState: AgentState }> {
  const response = await model().invoke([
    new SystemMessage(
      `You are a personal newspaper writer. Your sole purpose is to write a well-written article about a 
      topic using a list of articles. Write 5 paragraphs in markdown.`.replace(/\s+/g, " "),
    ),
    new HumanMessage(
      `Today's date is ${new Date().toLocaleDateString("en-GB")}.
      Your task is to write a critically acclaimed article for me about the provided query or 
      topic based on the sources. 
      Here is a list of articles: ${state.agentState.searchResults}
      This is the topic: ${state.agentState.topic}
      Please return a well-written article based on the provided information.`.replace(/\s+/g, " "),
    ),
  ]);
  const content = response.content as string;
  return {
    agentState: {
      ...state.agentState,
      article: content,
    },
  };
}

async function revise(state: { agentState: AgentState }): Promise<{ agentState: AgentState }> {
  const response = await model().invoke([
    new SystemMessage(
      `You are a personal newspaper editor. Your sole purpose is to edit a well-written article about a 
      topic based on given critique.`.replace(/\s+/g, " "),
    ),
    new HumanMessage(
      `Your task is to edit the article based on the critique given.
      This is the article: ${state.agentState.article}
      This is the critique: ${state.agentState.critique}
      Please return the edited article based on the critique given.
      You may leave feedback about the critique encoded between <FEEDBACK> tags like this:
      <FEEDBACK> here goes the feedback ...</FEEDBACK>`.replace(/\s+/g, " "),
    ),
  ]);
  const content = response.content as string;
  return {
    agentState: {
      ...state.agentState,
      article: content,
    },
  };
}

const agentState = {
  agentState: {
    value: (x: AgentState, y: AgentState) => y,
    default: () => ({
      topic: "",
    }),
  },
};

// Define the function that determines whether to continue or not
const shouldContinue = (state: { agentState: AgentState }) => {
  const result = state.agentState.critique === undefined ? "end" : "continue";
  return result;
};

const workflow = new StateGraph({
  channels: agentState,
});

workflow.addNode("search", new RunnableLambda({ func: search }) as any);
workflow.addNode("curate", new RunnableLambda({ func: curate }) as any);
workflow.addNode("write", new RunnableLambda({ func: write }) as any);
workflow.addNode("critique", new RunnableLambda({ func: critique }) as any);
workflow.addNode("revise", new RunnableLambda({ func: revise }) as any);

workflow.addEdge("search", "curate");
workflow.addEdge("curate", "write");
workflow.addEdge("write", "critique");

// We now add a conditional edge
workflow.addConditionalEdges(
  // First, we define the start node. We use `agent`.
  // This means these are the edges taken after the `agent` node is called.
  "critique",
  // Next, we pass in the function that will determine which node is called next.
  shouldContinue,
  // Finally we pass in a mapping.
  // The keys are strings, and the values are other nodes.
  // END is a special node marking that the graph should finish.
  // What will happen is we will call `should_continue`, and then the output of that
  // will be matched against the keys in this mapping.
  // Based on which one it matches, that node will then be called.
  {
    // If `tools`, then we call the tool node.
    continue: "revise",
    // Otherwise we finish.
    end: END,
  },
);

workflow.addEdge("revise", "critique");

workflow.setEntryPoint("search");
const app = workflow.compile();

export async function researchWithLangGraph(topic: string) {
  const inputs = {
    agentState: {
      topic,
    },
  };
  const result = await app.invoke(inputs);
  const regex = /<FEEDBACK>[\s\S]*?<\/FEEDBACK>/g;
  const article = result.agentState.article.replace(regex, "");
  return article;
}



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/presentation/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { researchWithLangGraph } from "./research";
import { Action } from "@copilotkit/shared";
import { NextRequest } from "next/server";

const researchAction = {
  name: "research",
  description:
    "Call this function to conduct research on a certain topic. Respect other notes about when to call this function",
  parameters: [
    {
      name: "topic",
      type: "string",
      description: "The topic to research. 5 characters or longer.",
    },
  ],
  handler: async ({ topic }) => {
    console.log("Researching topic: ", topic);
    return await researchWithLangGraph(topic);
  },
};

export const POST = async (req: NextRequest) => {
  const serviceAdapter = new OpenAIAdapter();

  const env = process.env;
  const actions: Action<any>[] = [];
  if (env["TAVILY_API_KEY"]) {
    actions.push(researchAction);
  }
  const runtime = new CopilotRuntime({ actions });

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/travel/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { research } from "./tavily";
import { NextRequest } from "next/server";

export const POST = async (req: NextRequest) => {
  const serviceAdapter = new OpenAIAdapter();

  const actions: any[] = [];

  if ("TAVILY_API_KEY" in process.env) {
    actions.push({
      name: "research",
      description:
        "Call this function to conduct research on a certain topic. Respect other notes about when to call this function",
      parameters: [
        {
          name: "topic",
          type: "string",
          description: "The topic to research. 5 characters or longer.",
        },
      ],
      handler: async ({ topic }) => {
        console.log("Researching topic: ", topic);
        return await research(topic);
      },
    });
  }
  const runtime = new CopilotRuntime({ actions });
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/travel/tavily.ts
---

import OpenAI from "openai";
const TAVILY_API_KEY = "TAVILY_API_KEY";

export async function research(query: string) {
  const response = await fetch("https://api.tavily.com/search", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      api_key: process.env[TAVILY_API_KEY],
      query,
      search_depth: "basic",
      include_answer: true,
      include_images: true,
      include_raw_content: false,
      max_results: 20,
    }),
  });

  const responseJson = await response.json();
  const openai = new OpenAI();

  console.log("TAVILY RESPONSE", responseJson);

  const completion = await openai.chat.completions.create({
    messages: [
      {
        role: "system",
        content: `Summarize the following JSON to answer the research query \`"${query}"\`: ${JSON.stringify(
          responseJson,
        )} in plain English. Make sure to include the links to all images.`,
      },
    ],
    model: "gpt-4o",
  });

  console.log("SUMMARY", completion.choices[0].message.content);

  return completion.choices[0].message.content;
}



---
File: /CopilotKit/examples/next-openai/src/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });
const UNSPLASH_ACCESS_KEY_ENV = "UNSPLASH_ACCESS_KEY";
const UNSPLASH_ACCESS_KEY = process.env[UNSPLASH_ACCESS_KEY_ENV];

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "getImageUrl",
      description: "Get an image url for a topic",
      parameters: [
        {
          name: "topic",
          description: "The topic of the image",
        },
      ],
      handler: async ({ topic }) => {
        if (UNSPLASH_ACCESS_KEY) {
          const response = await fetch(
            `https://api.unsplash.com/search/photos?query=${encodeURIComponent(topic)}&per_page=10&order_by=relevant&content_filter=high`,
            {
              headers: {
                Authorization: `Client-ID ${UNSPLASH_ACCESS_KEY}`,
              },
            },
          );
          const data = await response.json();
          if (data.results && data.results.length > 0) {
            const randomIndex = Math.floor(Math.random() * data.results.length);
            return data.results[randomIndex].urls.regular;
          }
        }
        return 'url("https://loremflickr.com/800/600/' + encodeURIComponent(topic) + '")';
      },
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /CopilotKit/examples/next-openai/src/app/api/transcribe/route.ts
---

import { OpenAI } from "openai";

export const runtime = "edge";

const openai = new OpenAI();

export async function POST(req: Request): Promise<Response> {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return new Response("File not provided", { status: 400 });
    }

    const transcription = await openai.audio.transcriptions.create({
      file,
      model: "whisper-1",
    });

    return new Response(JSON.stringify(transcription), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
}



---
File: /CopilotKit/examples/next-openai/src/app/api/tts/route.ts
---

import { OpenAI } from "openai";

export const runtime = "edge";

const openai = new OpenAI();

export async function GET(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const text = url.searchParams.get("text"); // 'text' is the query parameter name

  if (!text) {
    return new Response("Text parameter is missing", { status: 400 });
  }

  const response = await openai.audio.speech.create({
    voice: "alloy",
    input: text,
    model: "tts-1",
  });

  return response;
}



---
File: /CopilotKit/examples/next-openai/src/app/components/ActionButton.tsx
---

export const ActionButton = ({
  disabled,
  onClick,
  className,
  children,
}: {
  disabled: boolean;
  onClick: () => void;
  className?: string;
  children: React.ReactNode;
}) => {
  return (
    <button
      disabled={disabled}
      className={`bg-blue-500 text-white font-bold py-2 px-4 rounded
      ${disabled ? "opacity-50 cursor-not-allowed" : "hover:bg-blue-700"}
      ${className}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};



---
File: /CopilotKit/examples/next-openai/src/app/components/destination-row.tsx
---

"use client";

import React from "react";
import { Destination } from "./vacation-list";
import { useCopilotReadable } from "@copilotkit/react-core";
import Image from "next/image";

export type DestinationRowProps = {
  destination: Destination;
  isChecked: boolean;
  onCheckChange: (isChecked: boolean) => void;
  parentCopilotPointer?: string;
};

export function DestinationRow({
  destination,
  isChecked,
  onCheckChange,
  parentCopilotPointer,
}: DestinationRowProps) {
  useCopilotReadable({
    description: "A row in the destination list",
    value: {
      name: destination.name,
      country: destination.country,
      description: destination.description,
      activities: destination.activities,
      isSelected: isChecked,
    },
    parentId: parentCopilotPointer,
  });

  return (
    <tr key={destination.name}>
      <td className="whitespace-nowrap py-5 pl-4 px-3 text-sm">
        <div className="flex items-center">
          <div className="h-20 w-20 flex-shrink-0">
            <Image className="h-full w-full rounded-full" src={destination.image} alt="" />
          </div>
          <div className="ml-4">
            <div className="font-medium text-gray-900">{destination.name}</div>
            <div className="mt-1 text-gray-500">{destination.country}</div>
          </div>
        </div>
      </td>
      <td className="whitespace-nowrap py-5 pl-4 pr-3 text-sm">
        <div className="w-full flex items-stretch">
          <div className="flex items-center justify-center w-full">
            <input
              type="checkbox"
              checked={isChecked}
              onChange={(event) => onCheckChange(event.target.checked)}
            />
          </div>
        </div>
      </td>
      <td className="whitespace-nowrap px-3 py-5 text-sm text-gray-500">
        <div className="text-gray-900">{destination.description}</div>
      </td>
      <td className="whitespace-nowrap px-3 py-5 text-sm text-gray-500">
        {destination.activities}
      </td>
    </tr>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/components/destination-table.tsx
---

"use client";

import React from "react";
import { DestinationRow } from "./destination-row";
import { Destination } from "./vacation-list";
import { useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";

export type DestinationTableProps = {
  destinations: Destination[];
  heading: string;
};

function Thead() {
  return (
    <thead>
      <tr>
        <th
          scope="col"
          className="py-3.5 pl-4 px-3 text-left text-sm font-semibold text-gray-900 sm:pl-0"
        >
          Destination
        </th>
        <th
          scope="col"
          className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-0"
        >
          Selected
        </th>
        <th scope="col" className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
          Description
        </th>
        <th scope="col" className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
          Activities
        </th>
      </tr>
    </thead>
  );
}

export function DestinationTable({ destinations, heading }: DestinationTableProps) {
  const copilotPointer = useCopilotReadable({
    description: "Destination table",
    value: heading,
  });

  const [checkedRows, setCheckedRows] = React.useState<Record<string, boolean>>({});
  const handleCheckChange = (destinationName: string, isChecked: boolean) => {
    setCheckedRows((prevState) => ({
      ...prevState,
      [destinationName]: isChecked,
    }));
  };

  useCopilotAction(
    {
      name: `selectDestinations_${toCamelCase(heading)}`,
      description: `Set the given destinations as 'selected', on the ${heading} table`,
      parameters: [
        {
          name: "destinationNames",
          type: "string[]",
          description: "The names of the destinations to select",
          required: true,
        },
      ],
      handler: async ({ destinationNames }) => {
        setCheckedRows((prevState) => {
          const newState = { ...prevState };
          destinationNames.forEach((destinationName) => {
            newState[destinationName] = true;
          });
          return newState;
        });
      },
    },
    [],
  );

  useCopilotAction(
    {
      name: `deselectDestinations_${toCamelCase(heading)}`,
      description: `Set the given destinations as de-selected (unselected), on the ${heading} table`,
      parameters: [
        {
          name: "destinationNames",
          type: "string[]",
          description: "The names of the destinations to de-select",
          required: true,
        },
      ],
      handler: async ({ destinationNames }) => {
        setCheckedRows((prevState) => {
          const newState = { ...prevState };
          destinationNames.forEach((destinationName) => {
            newState[destinationName] = false;
          });
          return newState;
        });
      },
    },
    [],
  );

  return (
    <div>
      <h2 className="text-lg font-semibold leading-6 text-gray-900 mb-4 p-2">{heading}</h2>
      <table className="min-w-full divide-y divide-gray-300">
        <Thead />
        <tbody className="divide-y divide-gray-200 bg-white">
          {destinations.map((destination) => (
            <DestinationRow
              key={destination.name}
              destination={destination}
              isChecked={!!checkedRows[destination.name]}
              onCheckChange={(isChecked) => handleCheckChange(destination.name, isChecked)}
              parentCopilotPointer={copilotPointer}
            />
          ))}
        </tbody>
      </table>
    </div>
  );
}

function toCamelCase(str: string): string {
  return str
    .replace(/[-_ ](.)/g, (match, group1) => {
      return group1.toUpperCase();
    })
    .replace(/^(.)/, (match, group1) => group1.toLowerCase());
}



---
File: /CopilotKit/examples/next-openai/src/app/components/Presentation.tsx
---

"use client";
import { useCopilotAction, useCopilotContext } from "@copilotkit/react-core";
import { CopilotTask } from "@copilotkit/react-core";
import { useCopilotReadable } from "@copilotkit/react-core";
import { useCallback, useMemo, useState } from "react";
import {
  BackwardIcon,
  ForwardIcon,
  PlusIcon,
  SparklesIcon,
  SpeakerWaveIcon,
  TrashIcon,
} from "@heroicons/react/24/outline";
import { resetGlobalAudio, speak } from "../utils";
import { ActionButton } from "./ActionButton";
import { SlideModel, Slide } from "./Slide";

export const Presentation = ({ chatInProgress }: { chatInProgress: boolean }) => {
  const [slides, setSlides] = useState<SlideModel[]>([
    {
      title: `Welcome to our presentation!`,
      content: "This is the first slide.",
      backgroundImageDescription: "hello",
      spokenNarration: "This is the first slide. Welcome to our presentation!",
    },
  ]);
  const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
  const currentSlide = useMemo(() => slides[currentSlideIndex], [slides, currentSlideIndex]);

  useCopilotReadable({
    description: "These are all the slides",
    value: slides,
  });
  useCopilotReadable({
    description: "This is the current slide",
    value: currentSlide,
  });

  useCopilotAction({
    name: "appendSlide",
    description:
      "Add a slide after all the existing slides. Call this function multiple times to add multiple slides.",
    parameters: [
      {
        name: "title",
        type: "string",
        description: "The title of the slide. Should be a few words long.",
      },
      {
        name: "content",
        type: "string",
        description: "The content of the slide. Should generally consists of a few bullet points.",
      },
      {
        name: "backgroundImageDescription",
        type: "string",
        description:
          "What to display in the background of the slide. For example, 'dog', 'house', etc.",
      },
      {
        name: "spokenNarration",
        type: "string",
        description:
          "The text to read while presenting the slide. Should be distinct from the slide's content, and can include additional context, references, etc. Will be read aloud as-is. Should be a few sentences long, clear, and smooth to read.",
      },
    ],
    handler: async ({ title, content, backgroundImageDescription, spokenNarration }) => {
      const newSlide: SlideModel = {
        title,
        content,
        backgroundImageDescription,
        spokenNarration,
      };

      setSlides((slides) => [...slides, newSlide]);
    },
    render: "Adding slide...",
  });

  const context = useCopilotContext();
  const generateSlideTask = new CopilotTask({
    instructions:
      "Make the next slide related to the overall topic of the presentation. It will be inserted after the current slide.",
  });
  const [generateSlideTaskRunning, setGenerateSlideTaskRunning] = useState(false);

  const updateCurrentSlide = useCallback(
    (partialSlide: Partial<SlideModel>) => {
      setSlides((slides) => [
        ...slides.slice(0, currentSlideIndex),
        { ...slides[currentSlideIndex], ...partialSlide },
        ...slides.slice(currentSlideIndex + 1),
      ]);
    },
    [currentSlideIndex, setSlides],
  );

  return (
    <div className="relative">
      <Slide slide={currentSlide} partialUpdateSlide={updateCurrentSlide} />

      {/* Add the action buttons below */}
      <div className="absolute top-0 left-0 mt-6 ml-4 z-30">
        <ActionButton
          disabled={generateSlideTaskRunning || chatInProgress}
          onClick={() => {
            const newSlide: SlideModel = {
              title: "Title",
              content: "Body",
              backgroundImageDescription: "random",
              spokenNarration: "The speaker's notes for this slide.",
            };
            setSlides((slides) => [
              ...slides.slice(0, currentSlideIndex + 1),
              newSlide,
              ...slides.slice(currentSlideIndex + 1),
            ]);
            setCurrentSlideIndex((i) => i + 1);
          }}
          className="rounded-r-none"
        >
          <PlusIcon className="h-6 w-6" />
        </ActionButton>
        <ActionButton
          disabled={generateSlideTaskRunning || chatInProgress}
          onClick={async () => {
            setGenerateSlideTaskRunning(true);
            await generateSlideTask.run(context);
            setGenerateSlideTaskRunning(false);
          }}
          className="rounded-l-none ml-[1px]"
        >
          <SparklesIcon className="h-6 w-6" />
        </ActionButton>
      </div>

      <div className="absolute top-0 right-0 mt-6 mr-24">
        <ActionButton
          disabled={generateSlideTaskRunning || chatInProgress || slides.length === 1}
          onClick={() => {
            // delete the current slide
            setSlides((slides) => [
              ...slides.slice(0, currentSlideIndex),
              ...slides.slice(currentSlideIndex + 1),
            ]);
            setCurrentSlideIndex((i) => 0);
          }}
          className="ml-5 rounded-r-none"
        >
          <TrashIcon className="h-6 w-6" />
        </ActionButton>

        <ActionButton
          disabled={generateSlideTaskRunning || chatInProgress}
          onClick={() => {
            resetGlobalAudio();
            speak(currentSlide.spokenNarration);
          }}
          className="rounded-l-none rounded-r-none ml-[1px]"
        >
          <SpeakerWaveIcon className="h-6 w-6" />
        </ActionButton>
      </div>

      <div
        className="absolute bottom-0 right-0 mb-20 mx-24 text-xl"
        style={{
          textShadow: "1px 1px 0 #ddd, -1px -1px 0 #ddd, 1px -1px 0 #ddd, -1px 1px 0 #ddd",
        }}
      >
        Slide {currentSlideIndex + 1} of {slides.length}
      </div>

      <div className="absolute bottom-0 right-0 mb-6 mx-24">
        <ActionButton
          className="rounded-r-none"
          disabled={generateSlideTaskRunning || currentSlideIndex === 0 || chatInProgress}
          onClick={() => {
            setCurrentSlideIndex((i) => i - 1);
          }}
        >
          <BackwardIcon className="h-6 w-6" />
        </ActionButton>
        <ActionButton
          className="mr-[1px] rounded-l-none"
          disabled={
            generateSlideTaskRunning || chatInProgress || currentSlideIndex + 1 === slides.length
          }
          onClick={async () => {
            setCurrentSlideIndex((i) => i + 1);
          }}
        >
          <ForwardIcon className="h-6 w-6" />
        </ActionButton>
      </div>
    </div>
  );
};



---
File: /CopilotKit/examples/next-openai/src/app/components/Slide.tsx
---

import { useCopilotAction } from "@copilotkit/react-core";

export interface SlideModel {
  title: string;
  content: string;
  backgroundImageDescription: string;
  spokenNarration: string;
}

export interface SlideProps {
  slide: SlideModel;
  partialUpdateSlide: (partialSlide: Partial<SlideModel>) => void;
}

export const Slide = (props: SlideProps) => {
  const heightOfSpeakerNotes = 200;
  const backgroundImage =
    'url("https://source.unsplash.com/featured/?' +
    encodeURIComponent(props.slide.backgroundImageDescription) +
    '")';

  useCopilotAction({
    name: "updateSlide",
    description: "Update the current slide.",
    parameters: [
      {
        name: "title",
        type: "string",
        description: "The title of the slide. Should be a few words long.",
      },
      {
        name: "content",
        type: "string",
        description: "The content of the slide. Should generally consist of a few bullet points.",
      },
      {
        name: "backgroundImageDescription",
        type: "string",
        description:
          "Simple description what to display in the background of the slide. For example, 'dog', 'house', etc.",
      },
      {
        name: "spokenNarration",
        type: "string",
        description:
          "The spoken narration for the slide. This is what the user will hear when the slide is shown.",
      },
    ],
    handler: async ({ title, content, backgroundImageDescription, spokenNarration }) => {
      props.partialUpdateSlide({
        title,
        content,
        backgroundImageDescription,
        spokenNarration,
      });
    },
    render: "Updating slide...",
  });

  return (
    <>
      <div
        className="w-full relative bg-slate-200"
        style={{
          height: `calc(100vh - ${heightOfSpeakerNotes}px)`,
        }}
      >
        <div className="h-1/3 flex items-center justify-center text-5xl text-white p-10 text-center z-10">
          <textarea
            className="mt-16 text-7xl bg-white text-gray-400 p-4 text-center font-bold uppercase italic line-clamp-2 flex items-center"
            style={{
              border: "none",
              outline: "none",
            }}
            value={props.slide.title}
            placeholder="Title"
            onChange={(e) => {
              props.partialUpdateSlide({ title: e.target.value });
            }}
          />
        </div>

        <div className="h-2/3 flex">
          <textarea
            className="w-1/2 text-3xl text-black font-medium p-10 resize-none bg-transparent m-12 rounded-xl"
            style={{
              lineHeight: "1.5",
            }}
            value={props.slide.content}
            placeholder="Body"
            onChange={(e) => {
              props.partialUpdateSlide({ content: e.target.value });
            }}
          />

          <div
            className="w-1/2 z-10 rounded-xl m-12 mr-24"
            style={{
              backgroundImage,
              backgroundSize: "cover",
              backgroundPosition: "center",
            }}
          />
        </div>
      </div>

      <textarea
        className=" w-9/12 h-full bg-transparent text-5xl p-10 resize-none bg-gray-500 pr-36"
        style={{
          height: `${heightOfSpeakerNotes}px`,
          background: "none",
          border: "none",
          outline: "none",
          fontFamily: "inherit",
          fontSize: "inherit",
          lineHeight: "inherit",
        }}
        value={props.slide.spokenNarration}
        onChange={(e) => {
          props.partialUpdateSlide({ spokenNarration: e.target.value });
        }}
      />
    </>
  );
};



---
File: /CopilotKit/examples/next-openai/src/app/components/vacation-list.tsx
---

"use client";
import React from "react";
import { DestinationTable } from "./destination-table";
import { VacationNotes } from "./vacation-notes";
import { useMakeCopilotDocumentReadable, DocumentPointer } from "@copilotkit/react-core";

export type Destination = {
  name: string;
  country: string;
  image: string;
  description: string;
  activities: string;
};

const document: DocumentPointer = {
  id: "2",
  name: "Travel Pet Peeves",
  sourceApplication: "Google Docs",
  iconImageUri: "/images/GoogleDocs.svg",
  getContents: () => {
    return [
      "1. Crowded tourist spots",
      "2. Expensive souvenirs",
      "3. Uncomfortable airplane seats",
      "4. Language barriers",
      "5. Lost luggage",
      "6. Jet lag",
      "7. Long layovers",
      "8. Unpredictable weather",
      "9. Poor internet connection",
      "10. Local cuisine not matching taste",
    ].join("\n");
  },
} as DocumentPointer;

export function VacationList() {
  useMakeCopilotDocumentReadable(document);

  return (
    <div className="px-4 sm:px-6 lg:px-8 bg-slate-50 py-4">
      <div className="sm:flex sm:items-center">
        <div className="sm:flex-auto">
          <h1 className="text-3xl font-semibold leading-6 text-gray-900">WaterBnB (Toy Example)</h1>
        </div>
      </div>
      <div className="mt-8 flow-root bg-slate-200">
        <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
            <VacationNotes />
          </div>
        </div>
      </div>
      <div className="mt-8 flow-root bg-slate-200">
        <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
            <DestinationTable destinations={visitedDestinations} heading="Visited Destinations" />
          </div>
        </div>
      </div>
      <div className="mt-8 flow-root bg-slate-200">
        <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
            <DestinationTable destinations={newDestinations} heading="New Destinations" />
          </div>
        </div>
      </div>
    </div>
  );
}

const visitedDestinations: Destination[] = [
  {
    name: "New York City",
    country: "USA",
    image: "https://worldstrides.com/wp-content/uploads/2015/07/iStock_000040849990_Large.jpg",
    description:
      'Known as "The Big Apple", famous for its high energy, arts scene, and iconic landmarks.',
    activities: "Visit the Statue of Liberty, Central Park, Times Square, etc.",
  },
  {
    name: "London",
    country: "United Kingdom",
    image:
      "https://assets.editorial.aetnd.com/uploads/2019/03/topic-london-gettyimages-760251843-feature.jpg",
    description:
      "England's capital known for its rich history, art, culture, and famous landmarks.",
    activities: "Visit the British Museum, the Tower of London, Buckingham Palace, etc.",
  },
  {
    name: "Sydney",
    country: "Australia",
    image:
      "https://media.tatler.com/photos/6141d37b9ce9874a3e40107d/16:9/w_2560%2Cc_limit/social_crop_sydney_opera_house_gettyimages-869714270.jpg",
    description:
      "Australia's biggest city known for its harbourfront Sydney Opera House, arched Harbour Bridge and Darling Harbour.",
    activities: "Visit Sydney Opera House, Sydney Harbour Bridge, Bondi Beach, etc.",
  },
];

const newDestinations: Destination[] = [
  {
    name: "Paris",
    country: "France",
    image:
      "https://th.bing.com/th/id/R.9f0633e930516f6ff470595268f58b27?rik=ha1vaHawmkpg3g&riu=http%3a%2f%2fwww.sumit4allphotography.com%2fwp-content%2fuploads%2f2015%2f04%2fparis-013.jpg&ehk=4fi64VWVWbUIYMx4LFBas8A4zxTkVTREQNlHirY2sPU%3d&risl=&pid=ImgRaw&r=0",
    description:
      'Known as the "City of Light", famous for its museums and architectural landmarks.',
    activities: "Visit Eiffel Tower, Louvre Museum, Notre-Dame, etc.",
  },
  {
    name: "Tokyo",
    country: "Japan",
    image: "https://th.bing.com/th/id/OIP.MzXk5dvbrXpDe1b8bjkfpQHaFC?pid=ImgDet&rs=1",
    description:
      "A bustling city known for its modern architecture, nightlife, and hearty street food.",
    activities: "Visit Tokyo Tower, Meiji Shrine, Tokyo Disneyland, etc.",
  },
  {
    name: "Rome",
    country: "Italy",
    image:
      "https://fthmb.tqn.com/zrONHS-4SIm0ySkio8PsrtKkl-E=/5710x3799/filters:fill(auto,1)/the-roman-coliseum-during-a-warm-spring-sunset-542105331-58f15ac63df78cd3fc763275.jpg",
    description:
      "The capital of Italy known for its ancient ruins, including the Forum and the Colosseum.",
    activities: "Visit the Vatican City, Roman Forum, Colosseum, etc.",
  },
  {
    name: "Rio de Janeiro",
    country: "Brazil",
    image:
      "https://th.bing.com/th/id/R.58c7cd07743a65337c18c919bcaa1fc5?rik=TJqBfegI01c7Gw&riu=http%3a%2f%2fwww.getsready.com%2fwp-content%2fuploads%2f2016%2f08%2fRio-de-Janeiro-an-amazing-part-in-brazil.jpg&ehk=Dx7YdRlKPvbF%2fRsGg%2fGXOhSNQyYcyiqFKpqr7IoS3s8%3d&risl=&pid=ImgRaw&r=0",
    description:
      "A huge seaside city in Brazil, known for its Copacabana and Ipanema beaches, and the Christ the Redeemer statue.",
    activities: "Visit Sugarloaf Mountain, the Christ the Redeemer statue, Ipanema Beach, etc.",
  },
  {
    name: "Istanbul",
    country: "Turkey",
    image: "https://th.bing.com/th/id/OIP.S4Al32XFCu0bS99Tf2DCnwHaE8?pid=ImgDet&rs=1",
    description:
      "A city straddling Europe and Asia across the Bosphorus Strait, known for its historic sites.",
    activities: "Visit Hagia Sophia, Blue Mosque, Topkapi Palace, etc.",
  },
  {
    name: "Bali",
    country: "Indonesia",
    image:
      "https://th.bing.com/th/id/R.3a2422d39d9999c93c3438d9b4950d95?rik=GOiVPf3Xb26%2fpw&riu=http%3a%2f%2fwww.absolutemagazine.co.uk%2fwp-content%2fuploads%2f2017%2f11%2f2017_03_20_23739_1489984971._large.jpg&ehk=aNYxygLXB2jpi%2bCLdISg3BCYhHFUk61mcrqviLq9pmk%3d&risl=&pid=ImgRaw&r=0",
    description:
      "An Indonesian island known for its forested volcanic mountains, iconic rice paddies, beaches and coral reefs.",
    activities: "Visit Ubud, Seminyak, Nusa Dua, etc.",
  },
  {
    name: "Vienna",
    country: "Austria",
    image: "https://lp-cms-production.imgix.net/2020-11/500pxRF_124014183.jpg",
    description:
      "A city marked by its imperial palaces and musical heritage, located on the Danube River.",
    activities: "Visit Schönbrunn Palace, St. Stephen's Cathedral, Vienna State Opera, etc.",
  },
  {
    name: "Havana",
    country: "Cuba",
    image:
      "data:image/jpeg;base64,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",
    description:
      "Cuba's capital, a city carrying the scent of the old world with its well-preserved Spanish colonial architecture.",
    activities: "Visit Old Havana, Morro Castle, Malecón, etc.",
  },
  {
    name: "Dubai",
    country: "United Arab Emirates",
    image:
      "https://cloudfront-us-east-2.images.arcpublishing.com/reuters/TECHZMXJDZIZ3MSPVCWBOGTK6Y.jpg",
    description:
      "A city known for its modern architecture, luxury shopping, and a lively nightlife scene.",
    activities: "Visit Burj Khalifa, Dubai Mall, Palm Jumeirah, etc.",
  },
  {
    name: "Edinburgh",
    country: "Scotland",
    image:
      "https://static.nationalgeographic.co.uk/files/styles/image_3200/public/neighbourhood_edinburgh_awl_sco35873aw_hr.jpg?w=1600",
    description: "Scotland's compact, hilly capital known for its historical sites.",
    activities: "Visit Edinburgh Castle, Arthur's Seat, Royal Mile, etc.",
  },
  {
    name: "Marrakesh",
    country: "Morocco",
    image:
      "https://www.nomadicchica.com/en/productive/wp-content/uploads/2020/02/Marrakesh-best-things-to-do-Morocco-Woman-Gloria-Apara-Nomadicchica.com-7.jpg",
    description: "A city steeped in rich history and culture, known for its palaces and gardens.",
    activities: "Visit Jardin Majorelle, Koutoubia Mosque, Bahia Palace, etc.",
  },
  {
    name: "Prague",
    country: "Czech Republic",
    image:
      "https://a.cdn-hotels.com/gdcs/production76/d1135/21203dce-feeb-40f3-8c93-fc1a98f7549a.jpg?impolicy=fcrop&w=800&h=533&q=medium",
    description:
      "The capital city of the Czech Republic, known for its Old Town Square and historic monuments.",
    activities: "Visit Charles Bridge, Prague Castle, Old Town Square, etc.",
  },

  {
    name: "Zurich",
    country: "Switzerland",
    image:
      "https://a.cdn-hotels.com/gdcs/production127/d484/b9ca99c3-b15e-48ab-a3cb-983186637256.jpg?impolicy=fcrop&w=800&h=533&q=medium",
    description:
      "A global center for banking and finance, it lies at the north end of Lake Zurich in northern Switzerland.",
    activities: "Visit Lake Zurich, Old Town (Altstadt), Uetliberg, etc.",
  },
  {
    name: "Kyoto",
    country: "Japan",
    image:
      "https://e5rxtr4t5ah.exactdn.com/wp-content/uploads/2018/05/kyoto-4-day-itinerary-header.jpg",
    description:
      "Famous for its numerous classical Buddhist temples, as well as gardens, imperial palaces, Shinto shrines and traditional wooden houses.",
    activities: "Visit Fushimi Inari-taisha, Kinkaku-ji, Arashiyama, etc.",
  },
  {
    name: "Cairo",
    country: "Egypt",
    image:
      "https://lp-cms-production.imgix.net/features/2018/03/islamic-cairo-egypt-324042f64d76.jpg?auto=format&q=75&w=1920",
    description:
      "Egypt's sprawling capital, set on the Nile River, is a vibrant merging of the ancient and the modern.",
    activities: "Visit the Egyptian Museum, Pyramids of Giza, The Sphinx, etc.",
  },
  {
    name: "Athens",
    country: "Greece",
    image:
      "https://dynamic-media-cdn.tripadvisor.com/media/photo-o/1c/c0/98/c5/caption.jpg?w=700&h=-1&s=1&cx=960&cy=638&chk=v1_dd51d42e9a888a6b338f",
    description:
      "Athens, the capital of Greece, was also at the heart of Ancient Greece, a powerful civilization and empire.",
    activities: "Visit the Acropolis Museum, Parthenon, Plaka, etc.",
  },
  {
    name: "Lisbon",
    country: "Portugal",
    image:
      "https://www.travelandleisure.com/thmb/LzWpzDihxjffaFmM9TZWCvm9VyY=/1500x0/filters:no_upscale():max_bytes(150000):strip_icc()/lisbon-portugal-LISBONTG0521-c933a0fb669647619fa580f6c602c4c8.jpg",
    description:
      "Portugal’s hilly, coastal capital city known for its cafe culture and soulful Fado music.",
    activities: "Visit Belém Tower, Jerónimos Monastery, Praça do Comércio, etc.",
  },
  {
    name: "Buenos Aires",
    country: "Argentina",
    image:
      "https://lp-cms-production.imgix.net/2021-09/La%20Boca%2C%20Buenos%20Aires%2C%20Argentina.jpg",
    description:
      "Buenos Aires is Argentina’s big, cosmopolitan capital city known for its preserved Spanish/European-style architecture and rich cultural life.",
    activities: "Visit the Teatro Colón, MALBA, La Boca, etc.",
  },
  {
    name: "Cape Town",
    country: "South Africa",
    image:
      "https://media.discoverafrica.com/wp-content/uploads/2022/07/iStock-1371129172-scaled.jpg?strip=all&lossy=1&ssl=1",
    description:
      "Cape Town is a port city on South Africa’s southwest coast, on a peninsula beneath the imposing Table Mountain.",
    activities: "Visit Table Mountain, Kirstenbosch National Botanical Garden, Robben Island, etc.",
  },
  {
    name: "Queenstown",
    country: "New Zealand",
    image:
      "https://www.newzealand.com/assets/Operator-Database/img-1612224709-7722-18346-sel-20452d-summer-brand-campaign-web-banner-1920x1280-dining__aWxvdmVrZWxseQo_CropResizeWzEyMDAsNjMwLDc1LCJqcGciXQ.jpg",
    description:
      "Queenstown, New Zealand, sits on the shores of the South Island’s Lake Wakatipu, set against the dramatic Southern Alps.",
    activities: "Adventure sports like bungee jumping, skydiving, Visit Lake Wakatipu, etc.",
  },
  // More destinations...
];



---
File: /CopilotKit/examples/next-openai/src/app/components/vacation-notes.tsx
---

import { CopilotTextarea } from "@copilotkit/react-textarea";
import { useState } from "react";

export function VacationNotes() {
  const [text, setText] = useState("");

  return (
    <>
      <CopilotTextarea
        className="px-4 py-4"
        value={text}
        onValueChange={(value: string) => setText(value)}
        placeholder="What are your plans for your vacation?"
        autosuggestionsConfig={{
          textareaPurpose:
            "Travel notes from the user's previous vacations. Likely written in a colloquial style, but adjust as needed.",
          debounceTime: 250,
          disableWhenEmpty: true,

          // Accept on tab is the default behavior, but we can override it if we wanted to, as so:
          shouldAcceptAutosuggestionOnKeyPress: (event: React.KeyboardEvent<HTMLDivElement>) => {
            // if tab, accept the autosuggestion
            if (event.key === "Tab") {
              return true;
            }
            return false;
          },

          chatApiConfigs: {
            suggestionsApiConfig: {
              maxTokens: 20,
              stop: [".", "?", "!"],
            },
            insertionApiConfig: {},
          },
        }}
      />
    </>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/actions/useAppendSlide.tsx
---

import { useCopilotAction } from "@copilotkit/react-core";
import { SlideModel } from "../types";
import { SlidePreview } from "../components/misc/SlidePreview";

interface AppendSlideParams {
  setSlides: (fn: (slides: SlideModel[]) => SlideModel[]) => void;
  setCurrentSlideIndex: (fn: (i: number) => number) => void;
  slides: SlideModel[];
}

export default function useAppendSlide({
  setSlides,
  setCurrentSlideIndex,
  slides,
}: AppendSlideParams) {
  useCopilotAction({
    name: "appendSlide",
    description:
      "Add a slide after all the existing slides. Call this function multiple times to add multiple slides.",
    parameters: [
      {
        name: "content",
        description:
          "The content of the slide. MUST consist of a title, then an empty newline, then a few bullet points. Always between 1-3 bullet points - no more, no less.",
      },
      {
        name: "backgroundImageUrl",
        description:
          "The url of the background image for the slide. Use the getImageUrl tool to retrieve a URL for a topic.",
      },
      {
        name: "spokenNarration",
        description:
          "The text to read while presenting the slide. Should be distinct from the slide's content, " +
          "and can include additional context, references, etc. Will be read aloud as-is. " +
          "Should be a few sentences long, clear, and smooth to read." +
          "DO NOT include meta-commentary, such as 'in this slide', 'we explore', etc.",
      },
      {
        name: "backgroundImageDescription",
        description:
          "The description of the background image. This is optional and can be used to describe the image to the user.",
      },
    ],

    handler: async ({
      content,
      backgroundImageUrl,
      spokenNarration,
      backgroundImageDescription,
    }) => {
      const newSlide: SlideModel = {
        content,
        backgroundImageUrl,
        spokenNarration,
        backgroundImageDescription,
      };

      setSlides((slides) => [...slides, newSlide]);
      setCurrentSlideIndex((i) => slides.length);
    },
    render: (props) => {
      return (
        <SlidePreview
          {...props.args}
          done={props.status === "complete"}
          inProgressLabel="Adding slide..."
          doneLabel="Slide added."
        />
      );
    },
  });
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/actions/useUpdateSlide.tsx
---

import { useCopilotAction } from "@copilotkit/react-core";
import { SlideModel } from "../types";
import { SlidePreview } from "../components/misc/SlidePreview";

interface UpdateSlideParams {
  partialUpdateSlide: (partialSlide: Partial<SlideModel>) => void;
}

export default function useUpdateSlide({ partialUpdateSlide }: UpdateSlideParams) {
  useCopilotAction({
    name: "updateSlide",
    description: "Update the current slide.",
    parameters: [
      {
        name: "content",
        description: "The content of the slide. Should generally consist of a few bullet points.",
      },
      {
        name: "backgroundImageUrl",
        description:
          "The url of the background image for the slide. Use the getImageUrl tool to retrieve a URL for a topic.",
      },
      {
        name: "spokenNarration",
        description:
          "The spoken narration for the slide. This is what the user will hear when the slide is shown.",
      },
    ],
    handler: async ({ content, backgroundImageUrl, spokenNarration }) => {
      partialUpdateSlide({
        content,
        backgroundImageUrl,
        spokenNarration,
      });
    },
    render: (props) => {
      return (
        <SlidePreview
          {...props.args}
          done={props.status === "complete"}
          inProgressLabel="Updating slide..."
          doneLabel="Slide updated."
        />
      );
    },
  });
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/ActionButton.tsx
---

import clsx from "clsx";

interface ActionButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  inProgress?: boolean;
}

export function ActionButton({ children, onClick, disabled, inProgress }: ActionButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled || inProgress}
      className={clsx(
        "text-white font-bold w-7 h-7 flex items-center justify-center rounded-md",
        disabled ? "opacity-50 cursor-not-allowed" : "hover:border hover:border-white",
        inProgress && "animate-bounce text-blue-400 cursor-not-allowed hover:border-none",
      )}
    >
      {children}
    </button>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/AddSlideButton.tsx
---

import { SlideModel } from "../../types";
import { ActionButton } from "./ActionButton";
import { PlusCircleIcon } from "@heroicons/react/24/outline";

interface AddSlideButtonProps {
  currentSlideIndex: number;
  setCurrentSlideIndex: (fn: (i: number) => number) => void;
  setSlides: (fn: (slides: SlideModel[]) => SlideModel[]) => void;
}

export function AddSlideButton({
  currentSlideIndex,
  setCurrentSlideIndex,
  setSlides,
}: AddSlideButtonProps) {
  return (
    <ActionButton
      onClick={() => {
        const newSlide: SlideModel = {
          content: "",
          backgroundImageUrl: "",
          backgroundImageDescription: "random",
          spokenNarration: "",
        };
        setSlides((slides) => [
          ...slides.slice(0, currentSlideIndex + 1),
          newSlide,
          ...slides.slice(currentSlideIndex + 1),
        ]);
        setCurrentSlideIndex((i) => i + 1);
      }}
    >
      <PlusCircleIcon className="h-5 w-5" />
    </ActionButton>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/DeleteSlideButton.tsx
---

import { SlideModel } from "../../types";
import { ActionButton } from "./ActionButton";
import { TrashIcon } from "@heroicons/react/24/outline";

interface DeleteSlideButtonProps {
  currentSlideIndex: number;
  setCurrentSlideIndex: (fn: (i: number) => number) => void;
  slides: SlideModel[];
  setSlides: (fn: (slides: SlideModel[]) => SlideModel[]) => void;
}

export function DeleteSlideButton({
  currentSlideIndex,
  setCurrentSlideIndex,
  slides,
  setSlides,
}: DeleteSlideButtonProps) {
  return (
    <ActionButton
      disabled={slides.length == 1}
      onClick={() => {
        // delete the current slide
        setSlides((slides) => [
          ...slides.slice(0, currentSlideIndex),
          ...slides.slice(currentSlideIndex + 1),
        ]);
        setCurrentSlideIndex((i) => 0);
      }}
    >
      <TrashIcon className="h-5 w-5" />
    </ActionButton>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/GenerateSlideButton.tsx
---

import { CopilotContextParams, CopilotTask } from "@copilotkit/react-core";
import { useState } from "react";
import { ActionButton } from "./ActionButton";
import { SparklesIcon } from "@heroicons/react/24/outline";

interface GenerateSlideButtonProps {
  context: CopilotContextParams;
}

export function GenerateSlideButton({ context }: GenerateSlideButtonProps) {
  const [isGeneratingSlide, setIsGeneratingSlide] = useState(false);
  return (
    <ActionButton
      inProgress={isGeneratingSlide}
      onClick={async () => {
        try {
          let slideContent = prompt("What should the new slide be about?");
          if (slideContent === null) {
            return;
          }
          setIsGeneratingSlide(true);
          const generateSlideTask = new CopilotTask({
            instructions:
              "Make a new slide given this user input: " +
              slideContent +
              "\n DO NOT carry out research",
          });
          await generateSlideTask.run(context);
        } finally {
          setIsGeneratingSlide(false);
        }
      }}
    >
      <SparklesIcon className={"h-5 w-5"} />
    </ActionButton>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/NavButton.tsx
---

import clsx from "clsx";

interface NavButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

export function NavButton({ children, onClick, disabled }: NavButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={clsx(
        "w-7 h-7 border border-white rounded-md flex justify-center items-center",
        "focus:outline-none",
        disabled ? "opacity-40 cursor-not-allowed" : "hover:bg-white hover:text-black",
      )}
    >
      {children}
    </button>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/PerformResearchSwitch.tsx
---

interface PerformResearchSwitchProps {
  isEnabled: boolean;
  setIsEnabled: (fn: (b: boolean) => boolean) => void;
}

export const PerformResearchSwitch = ({ isEnabled, setIsEnabled }: PerformResearchSwitchProps) => {
  return (
    <label className="flex items-center cursor-pointer pl-4">
      <div className="relative">
        <input
          type="checkbox"
          className="sr-only"
          checked={isEnabled}
          onChange={() => setIsEnabled((b) => !b)}
        />
        <div
          className={`w-10 h-4 ${
            isEnabled ? "bg-blue-500" : "bg-gray-400"
          } rounded-full shadow-inner transition-colors`}
        ></div>

        <div
          className={`absolute w-6 h-6 bg-white rounded-full shadow -left-1 -top-1 transition-transform ${
            isEnabled ? "transform translate-x-full" : ""
          }`}
        ></div>
      </div>
      <span className="text-sm font-normal ml-2">Perform Research?</span>
    </label>
  );
};



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/buttons/SpeakCurrentSlideButton.tsx
---

import { useState } from "react";
import { ActionButton } from "./ActionButton";
import { SpeakerWaveIcon } from "@heroicons/react/24/outline";
import { resetGlobalAudio, speak } from "../../utils/globalAudio";

interface SpeakCurrentSlideButtonProps {
  spokenNarration: string;
}

export function SpeakCurrentSlideButton({ spokenNarration }: SpeakCurrentSlideButtonProps) {
  const [isSpeaking, setIsSpeaking] = useState(false);
  return (
    <ActionButton inProgress={isSpeaking}>
      <SpeakerWaveIcon
        className="h-5 w-5"
        onClick={async () => {
          resetGlobalAudio();
          try {
            setIsSpeaking(true);
            await speak(spokenNarration);
          } finally {
            setIsSpeaking(false);
          }
        }}
      />
    </ActionButton>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/main/Header.tsx
---

import clsx from "clsx";
import { SlideModel } from "../../types";
import { useMemo } from "react";
import { useCopilotContext } from "@copilotkit/react-core";
import { SlideNumberIndicator } from "../misc/SlideNumberIndicator";
import { GenerateSlideButton } from "../buttons/GenerateSlideButton";
import { SpeakCurrentSlideButton } from "../buttons/SpeakCurrentSlideButton";
import { DeleteSlideButton } from "../buttons/DeleteSlideButton";
import { NavButton } from "../buttons/NavButton";
import { ChevronLeftIcon, ChevronRightIcon } from "@heroicons/react/24/outline";
import { PerformResearchSwitch } from "../buttons/PerformResearchSwitch";
import { AddSlideButton } from "../buttons/AddSlideButton";

interface HeaderProps {
  currentSlideIndex: number;
  setCurrentSlideIndex: (fn: (i: number) => number) => void;
  slides: SlideModel[];
  setSlides: (fn: (slides: SlideModel[]) => SlideModel[]) => void;
  performResearch: boolean;
  setPerformResearch: (fn: (b: boolean) => boolean) => void;
}

export function Header({
  currentSlideIndex,
  setCurrentSlideIndex,
  slides,
  setSlides,
  performResearch,
  setPerformResearch,
}: HeaderProps) {
  const currentSlide = useMemo(() => slides[currentSlideIndex], [slides, currentSlideIndex]);

  /**
   * We need to get the context here to run a Copilot task for generating a slide
   **/
  const context = useCopilotContext();

  return (
    <header className={clsx("text-white items-center flex p-4")}>
      <div className="flex-0 flex space-x-1">
        {/* Back */}
        <NavButton
          disabled={currentSlideIndex == 0}
          onClick={() => setCurrentSlideIndex((i) => i - 1)}
        >
          <ChevronLeftIcon className="h-6 w-6" />
        </NavButton>

        {/* Forward */}
        <NavButton
          disabled={currentSlideIndex == slides.length - 1}
          onClick={() => setCurrentSlideIndex((i) => i + 1)}
        >
          <ChevronRightIcon className="h-6 w-6" />
        </NavButton>

        {/* Perform Research */}
        <PerformResearchSwitch isEnabled={performResearch} setIsEnabled={setPerformResearch} />
      </div>

      <SlideNumberIndicator {...{ currentSlideIndex, totalSlides: slides.length }} />

      <div className="flex-0 flex space-x-1">
        <AddSlideButton {...{ currentSlideIndex, setCurrentSlideIndex, setSlides }} />

        <GenerateSlideButton context={context} />

        <SpeakCurrentSlideButton spokenNarration={currentSlide.spokenNarration} />

        <DeleteSlideButton {...{ currentSlideIndex, setCurrentSlideIndex, slides, setSlides }} />
      </div>
    </header>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/main/Presentation.tsx
---

"use client";
import { useCoAgent, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { useCopilotChatSuggestions } from "@copilotkit/react-ui";
import { useCallback, useMemo, useState } from "react";
import { Slide } from "./Slide";
import { Header } from "./Header";
import useAppendSlide from "../../actions/useAppendSlide";
import { SlideModel } from "../../types";

interface PresentationProps {
  performResearch: boolean;
  setPerformResearch: (fn: (b: boolean) => boolean) => void;
}

export const Presentation = ({ performResearch, setPerformResearch }: PresentationProps) => {
  // Load messages from local storage

  // const { messages, setMessages } = useCopilotContext();

  // // save to local storage when messages change
  // useEffect(() => {
  //   if (messages.length !== 0) {
  //     localStorage.setItem("copilotkit-messages", JSON.stringify(messages));
  //   }
  // }, [JSON.stringify(messages)]);

  // // initially load from local storage
  // useEffect(() => {
  //   const messages = localStorage.getItem("copilotkit-messages");
  //   if (messages) {
  //     console.log("got messages from local storage", messages);
  //     setMessages(JSON.parse(messages));
  //   }
  // }, []);

  const [slides, setSlides] = useState<SlideModel[]>([
    {
      content: "This is the first slide.",
      backgroundImageUrl:
        "https://loremflickr.com/cache/resized/65535_53415810728_d1db6e2660_h_800_600_nofilter.jpg",
      spokenNarration: "This is the first slide. Welcome to our presentation!",
      backgroundImageDescription: "A default image placeholder",
    },
  ]);
  const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
  const currentSlide = useMemo(() => slides[currentSlideIndex], [slides, currentSlideIndex]);

  /**
   * This makes all slides available to the Copilot.
   */
  useCopilotReadable({
    description: "These are all the slides",
    value: slides,
  });

  /**
   * This makes the current slide available to the Copilot.
   */
  useCopilotReadable({
    description: "This is the current slide",
    value: currentSlide,
  });

  /**
   * This action allows the Copilot to append a new slide to the presentation.
   */
  useAppendSlide({
    setSlides,
    setCurrentSlideIndex,
    slides,
  });

  /**
   * Auto Suggestions
   */
  useCopilotChatSuggestions(
    {
      instructions: "Suggest a new slide based on the existing slides.",
    },
    [currentSlide],
  );

  useCopilotChatSuggestions(
    {
      instructions:
        "Suggest specifically what could be improved about the content of current slide. " +
        "The specific suggestion should be in the button text. " +
        "Do not suggest to update the background image.",
      minSuggestions: 0,
      maxSuggestions: 1,
      className: "custom-suggestion",
    },
    [currentSlide],
  );

  const updateCurrentSlide = useCallback(
    (partialSlide: Partial<SlideModel>) => {
      setSlides((slides) => [
        ...slides.slice(0, currentSlideIndex),
        { ...slides[currentSlideIndex], ...partialSlide },
        ...slides.slice(currentSlideIndex + 1),
      ]);
    },
    [currentSlideIndex, setSlides],
  );

  return (
    <div
      style={{
        height: `100vh`,
      }}
      className="flex flex-col"
    >
      <Header
        currentSlideIndex={currentSlideIndex}
        setCurrentSlideIndex={setCurrentSlideIndex}
        slides={slides}
        setSlides={setSlides}
        performResearch={performResearch}
        setPerformResearch={setPerformResearch}
      />
      <div
        className="flex items-center justify-center flex-1"
        style={{ backgroundColor: "#414247", overflow: "auto" }}
      >
        <div
          className="aspect-ratio-box bg-white flex shadow-2xl"
          style={{ margin: "5rem", maxHeight: "70vh" }}
        >
          <Slide slide={currentSlide} partialUpdateSlide={updateCurrentSlide} />
        </div>
      </div>
    </div>
  );
};



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/main/Slide.tsx
---

"use client";
import useUpdateSlide from "../../actions/useUpdateSlide";
import { SlideModel } from "../../types";

export interface SlideProps {
  slide: SlideModel;
  partialUpdateSlide: (partialSlide: Partial<SlideModel>) => void;
}

export const Slide = (props: SlideProps) => {
  const backgroundImage = `url("${props.slide.backgroundImageUrl}")`;

  /**
   * This action allows the Copilot to update the current slide.
   */
  useUpdateSlide({ partialUpdateSlide: props.partialUpdateSlide });

  return (
    <div className="w-full h-full flex flex-row bg-white">
      <div className="flex-grow h-full flex flex-col" style={{ flex: "2" }}>
        <SlideContent
          content={props.slide.content}
          onChange={(newContent) => {
            props.partialUpdateSlide({ content: newContent });
          }}
        />
        <SlideSpeakerNotes
          spokenNarration={props.slide.spokenNarration}
          onChange={(newSpokenNarration) => {
            props.partialUpdateSlide({ spokenNarration: newSpokenNarration });
          }}
        />
      </div>
      <SlideImage backgroundImage={backgroundImage} />
    </div>
  );
};

function SlideImage({ backgroundImage }: { backgroundImage: string }) {
  return (
    <div
      className="flex-grow h-full bg-slate-200"
      style={{
        flex: "1",
        backgroundImage,
        backgroundSize: "cover",
        backgroundPosition: "center",
      }}
    />
  );
}

interface SpeakerNotesProps {
  spokenNarration: string;
  onChange: (newSpokenNarration: string) => void;
}

function SlideSpeakerNotes({ spokenNarration, onChange }: SpeakerNotesProps) {
  return (
    <div className="bg-gray-200 relative h-20 flex flex-col">
      <textarea
        className="w-full h-full bg-transparent p-2 text-base"
        style={{
          border: "none",
          outline: "none",
          lineHeight: "1.5",
          resize: "none",
        }}
        placeholder="Speaker notes..."
        value={spokenNarration}
        onChange={(e) => {
          onChange(e.target.value);
        }}
      />
    </div>
  );
}

interface SlideContentProps {
  content: string;
  onChange: (newContent: string) => void;
}

function SlideContent({ content, onChange }: SlideContentProps) {
  return (
    <textarea
      className="flex-1 w-full text-gray-800 p-4 px-10 font-bold flex items-center line-clamp-6"
      style={{
        border: "none",
        outline: "none",
        resize: "none",
        fontSize: "2vw",
      }}
      value={content}
      placeholder="Slide content..."
      onChange={(e) => {
        onChange(e.target.value);
      }}
    />
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/misc/SlideNumberIndicator.tsx
---

interface SlideNumberIndicatorProps {
  currentSlideIndex: number;
  totalSlides: number;
}

export function SlideNumberIndicator({
  currentSlideIndex,
  totalSlides,
}: SlideNumberIndicatorProps) {
  return (
    <div className="flex-1 items-center justify-center flex uppercase text-xs font-bold tracking-widest">
      <span className="mr-3">{SLIDES_ICON}</span>
      Slide {currentSlideIndex + 1} of {totalSlides}
    </div>
  );
}

const SLIDES_ICON = (
  <svg
    width="10px"
    height="10px"
    viewBox="0 0 42 42"
    xmlns="http://www.w3.org/2000/svg"
    fill="currentColor"
  >
    <rect x="0" y="0" width="10" height="10" />
    <rect x="16" y="0" width="10" height="10" />
    <rect x="32" y="0" width="10" height="10" />
    <rect x="0" y="16" width="10" height="10" />
    <rect x="16" y="16" width="10" height="10" />
    <rect x="32" y="16" width="10" height="10" />
    <rect x="0" y="32" width="10" height="10" />
    <rect x="16" y="32" width="10" height="10" />
    <rect x="32" y="32" width="10" height="10" />
  </svg>
);



---
File: /CopilotKit/examples/next-openai/src/app/presentation/components/misc/SlidePreview.tsx
---

interface SlidePreviewProps {
  inProgressLabel: string;
  doneLabel: string;
  title?: string;
  content?: string;
  spokenNarration?: string;
  done?: boolean;
}

export function SlidePreview({
  content,
  spokenNarration,
  done,
  doneLabel,
  inProgressLabel,
}: SlidePreviewProps) {
  return (
    <div className="">
      <div className=" w-full relative max-w-xs">
        <div className="absolute inset-0 h-full w-full bg-gradient-to-r from-blue-500 to-teal-500 transform scale-[0.80] bg-red-500 rounded-full blur-3xl" />
        <div className="relative shadow-xl bg-gray-900 border border-gray-800  px-4 py-8 h-full overflow-hidden rounded-2xl flex flex-col justify-end items-start">
          <h1 className="font-bold text-xl text-white mb-4 relative z-50">
            {done ? doneLabel : inProgressLabel}
          </h1>
          <p className="font-normal text-base text-slate-500 mb-4 relative z-50 whitespace-pre">
            {content}
          </p>
          {spokenNarration && (
            <p className="font-normal text-sm text-slate-500 mb-4 relative z-50">
              &quot;{spokenNarration}&quot;
            </p>
          )}
        </div>
      </div>
    </div>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/utils/globalAudio.tsx
---

"use client";

export let globalAudio: any = undefined;

export function resetGlobalAudio() {
  if (globalAudio) {
    globalAudio.pause();
    globalAudio.currentTime = 0;
  } else {
    globalAudio = new Audio();
  }
}

export async function speak(text: string) {
  const encodedText = encodeURIComponent(text);
  const url = `/api/tts?text=${encodedText}`;
  globalAudio.src = url;
  globalAudio.play();
  await new Promise<void>((resolve) => {
    globalAudio.onended = function () {
      resolve();
    };
  });
  await new Promise((resolve) => setTimeout(resolve, 500));
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/page.tsx
---

"use client";
import { CopilotKit, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotKitCSSProperties, CopilotPopup, CopilotSidebar } from "@copilotkit/react-ui";
import "./styles.css";
import { Presentation } from "./components/main/Presentation";
import { useState } from "react";

export default function AIPresentation() {
  const [performResearch, setPerformResearch] = useState(false);

  const copilotKitProps = {
    transcribeAudioUrl: "/api/transcribe",
    textToSpeechUrl: "/api/tts",
    runtimeUrl: process.env["NEXT_PUBLIC_COPILOTKIT_RUNTIME_URL"] ?? "/api/copilotkit/openai",
    publicApiKey: process.env["NEXT_PUBLIC_COPILOTKIT_PUBLIC_API_KEY"] ?? undefined,
  };

  return (
    <CopilotKit {...copilotKitProps}>
      <div
        style={
          {
            height: `100vh`,
            "--copilot-kit-primary-color": "#222222",
          } as CopilotKitCSSProperties
        }
      >
        <CopilotSidebar
          instructions={
            "Help the user create and edit a powerpoint-style presentation." +
            (!performResearch
              ? " No research is needed. Do not perform any research."
              : " Perform research on the topic.")
          }
          defaultOpen={true}
          labels={{
            title: "Presentation Copilot",
            initial: "Hi you! 👋 I can help you create a presentation on any topic.",
          }}
          clickOutsideToClose={false}
        >
          <Presentation performResearch={performResearch} setPerformResearch={setPerformResearch} />
        </CopilotSidebar>
      </div>
    </CopilotKit>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/styles.css
---

.copilotKitHeader {
  height: 60px;
  border-left: 1px solid #555;
}

.copilotKitWindow.open {
  box-shadow: none;
}

html,
body {
  height: 100%;
  margin: 0;
}

.aspect-ratio-box {
  width: 100%;
  max-width: calc(100% - 5rem); /* Account for margin */
  position: relative;
}
.aspect-ratio-box::before {
  content: "";
  display: block;
  padding-top: 56.25%; /* 16:9 Aspect Ratio */
}
.aspect-ratio-box > * {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

.custom-suggestion {
  padding: 8px 12px;
  font-size: 0.7rem;
  border-radius: 0.5rem;
  background: #4169e1;
  color: white;
}



---
File: /CopilotKit/examples/next-openai/src/app/presentation/types.ts
---

export interface SlideModel {
  content: string;
  backgroundImageUrl: string;
  backgroundImageDescription: string;
  spokenNarration: string;
}



---
File: /CopilotKit/examples/next-openai/src/app/textarea/page.tsx
---

"use client"; // need use client to use useRef
import {
  CopilotKit,
  DocumentPointer,
  useCopilotReadable,
  useMakeCopilotDocumentReadable,
} from "@copilotkit/react-core";
import { CopilotTextarea, HTMLCopilotTextAreaElement } from "@copilotkit/react-textarea";
import { useRef } from "react";
import { useStateWithLocalStorage } from "../utils";

export default function CopilotTextareaDemo() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit">
      <TextAreas />
    </CopilotKit>
  );
}

const clientTranscriptSummaryDocument: DocumentPointer = {
  id: "clientTranscriptSummary",
  name: "Client Call Gong Transcript",
  sourceApplication: "Gong",
  iconImageUri: "https://asset.brandfetch.io/idHyhmcKvT/idRu6db2HA.jpeg?updated=1690987844207",
  getContents: () => {
    return "This is the client transcript summary";
  },
};

function TextAreas() {
  const [detailsText, setDetailsText] = useStateWithLocalStorage("", "cacheKey_detailsText");
  const [copilotText, setCopilotText] = useStateWithLocalStorage("", "cacheKey_copilotText");

  const [textareaPurpose, setTextareaPurpose] = useStateWithLocalStorage(
    "A COOL & SMOOTH announcement post about CopilotTextarea. No pomp, no fluff, no BS. Just the facts. Be brief, be clear, be concise. Be cool.",
    "cacheKey_textareaPurpose",
  );

  const salesReplyCategoryId = "sales_reply";
  useCopilotReadable({
    description: "Details Text",
    value: detailsText,
    categories: [salesReplyCategoryId],
  });

  const copilotTextareaRef = useRef<HTMLCopilotTextAreaElement>(null);

  useMakeCopilotDocumentReadable(clientTranscriptSummaryDocument, [salesReplyCategoryId], []);

  return (
    <div className="w-full h-full gap-10 flex flex-col items-center p-10">
      <div className="flex w-1/2 items-start gap-3">
        <span className="text-3xl text-white whitespace-nowrap">Textarea Purpose:</span>
        <textarea
          className="p-2 h-12 rounded-lg flex-grow overflow-x-auto overflow-y-hidden whitespace-nowrap"
          value={textareaPurpose}
          onChange={(event) => setTextareaPurpose(event.target.value)}
        />
      </div>
      <CopilotTextarea
        value={copilotText}
        ref={copilotTextareaRef}
        onChange={(event) => setCopilotText(event.target.value)}
        className="p-4 w-1/2 aspect-square font-bold text-3xl bg-slate-800 text-white rounded-lg resize-none"
        placeholderStyle={{
          color: "white",
          opacity: 0.5,
        }}
        autosuggestionsConfig={{
          textareaPurpose: textareaPurpose,
          contextCategories: [salesReplyCategoryId],
          chatApiConfigs: {
            suggestionsApiConfig: {
              // makeSystemPrompt: makeSystemPrompt,
              // fewShotMessages: fewShotMessages,
              maxTokens: 5,
              stop: ["\n", ".", ","],
            },
            insertionApiConfig: {},
          },
          debounceTime: 250,
        }}
      />

      <textarea
        className="p-4 w-1/2 h-80 rounded-lg"
        value={detailsText}
        placeholder="the normal textarea"
        onChange={(event) => setDetailsText(event.target.value)}
      />

      <button
        className="p-4 w-1/2 bg-slate-800 text-white rounded-lg"
        onClick={() => {
          if (copilotTextareaRef.current) {
            copilotTextareaRef.current.focus();
          }
        }}
      >
        Focus CopilotTextarea
      </button>
    </div>
  );
}

// const makeSystemPrompt: MakeSystemPrompt = (textareaPurpose, contextString) => {
//   return `
// You are a versatile writing assistant.

// The user is writing some text.
// The purpose is: \"${textareaPurpose}\"

// Your job is to guess what the user will write next AS BEST YOU CAN.
// Only guess a SHORT distance ahead. Usually 1 sentence, or at most 1 paragraph.

// Adjust yourself to the user's style and implied intent.

// The user will provide both the text before and after the cursor. You should use this to infer what the user is likely to write next.
// <TextAfterCursor>
// <TextBeforeCursor>
// <YourSuggestion>

// If we need to add a whitespace character to the suggested text, make sure to explicitly add it in.

// The following external context is also provided. Use it to help you make better suggestions!!!
// \`\`\`
// ${contextString}
// \`\`\`
// `;
// };



---
File: /CopilotKit/examples/next-openai/src/app/travel/page.tsx
---

"use client";

import { CopilotChat } from "@copilotkit/react-ui";
import "./styles.css";
import { CopilotKit, useCopilotAction } from "@copilotkit/react-core";
import { useState } from "react";
import Image from "next/image";

interface BookableItem {
  name: string;
  arrivalDate: string;
  departureDate: string;
}

export default function PanelPage() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit/travel">
      <TravelPlanner />
    </CopilotKit>
  );
}

function TravelPlanner() {
  const [bookableItems, setBookableItems] = useState<BookableItem[]>([]);

  useCopilotAction({
    name: "presentHotelOrLocation",
    description:
      "Call this function to present the user with a hotel or location or really anything related to travel.",
    parameters: [
      {
        name: "title",
        type: "string",
        description: "The title of the hotel or location.",
      },
      {
        name: "description",
        type: "string",
      },
      {
        name: "image",
        type: "string",
        description: "The url of an image if available.",
        required: false,
      },
    ],
    handler: async ({ title }) => {
      return `Presented ${title}`;
    },
    render({ status, args }) {
      return (
        <div className="bg-white w-96 rounded-lg shadow-sm border">
          <div className="py-4 px-4">
            <h1 className="text-xl font-bold">{args.title || ""}</h1>
            <p className="text-sm">{args.description || ""}</p>
          </div>
          {status == "complete" && (
            <Image className="rounded-b-lg" src={args.image || ""} alt={args.title || ""} />
          )}
        </div>
      );
    },
  });

  useCopilotAction({
    name: "bookHotel",
    parameters: [
      {
        name: "name",
        type: "string",
        description: "The title of the hotel.",
      },
      {
        name: "arrivalDate",
        type: "string",
        description: "The date of arrival (ask).",
      },
      {
        name: "departureDate",
        type: "string",
        description: "The date of departure (ask).",
      },
    ],
    handler: async ({ name, arrivalDate, departureDate }) => {
      setBookableItems((prev) => [...prev, { name, arrivalDate, departureDate }]);
    },
  });

  return (
    <div className="h-full flex">
      <CopilotChat
        className="w-2/3 h-full border-r border-gray-200"
        labels={{
          initial: "Hi you! 👋 Let's book your next vacation. Ask me anything.",
        }}
        instructions="You are a travel planner. You help the user plan their vacation. After presenting something, don't summarize, but keep the reply short."
      />
      <div className="h-full flex-1 flex flex-col p-4 space-y-4">
        {bookableItems.length === 0 ? (
          <p className="text-black h-full p-3 text-sm pt-8 items-center justify-center w-full flex">
            No items booked yet. Your cart is empty.
          </p>
        ) : (
          <>
            <h2 className="text-2xl font-bold mb-4">Your Bookings</h2>
            {bookableItems.map((item, index) => (
              <div key={index} className="bg-white p-4 rounded-lg shadow-md border relative">
                <button
                  className="absolute top-2 right-2 text-red-500 text-xs"
                  onClick={() => setBookableItems((prev) => prev.filter((_, i) => i !== index))}
                >
                  Remove
                </button>
                <h2 className="text-lg font-semibold">{item.name}</h2>
                <p className="text-sm text-gray-600">Arrival: {item.arrivalDate}</p>
                <p className="text-sm text-gray-600">Departure: {item.departureDate}</p>
              </div>
            ))}
          </>
        )}
      </div>
    </div>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/travel/styles.css
---

html,
body {
  height: 100%;
  margin: 0;
  background-color: white;
}



---
File: /CopilotKit/examples/next-openai/src/app/layout.tsx
---

import "../styles/globals.css";
import "@copilotkit/react-ui/styles.css";
import "@copilotkit/react-textarea/styles.css";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="bg-zinc-900">
      <body>{children}</body>
    </html>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/page.tsx
---

import { CopilotKit } from "@copilotkit/react-core";
import { CopilotSidebar } from "@copilotkit/react-ui";
import { VacationList } from "./components/vacation-list";

export default function WaterBnb() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit">
      <CopilotSidebar>
        <VacationList />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/examples/next-openai/src/app/utils.ts
---

export function generateRandomString(length: number) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

import { useState, useEffect, useRef } from "react";

export function useStateWithLocalStorage(
  defaultValue: string,
  key: string,
): [string, React.Dispatch<React.SetStateAction<string>>] {
  const [state, setState] = useState<string>(defaultValue);
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (typeof window !== "undefined") {
      const storagedValue = localStorage.getItem(key);
      if (storagedValue) {
        try {
          setState(JSON.parse(storagedValue));
        } catch {}
      }
    }
  }, [key]);

  useEffect(() => {
    if (typeof window !== "undefined" && !isFirstRender.current) {
      localStorage.setItem(key, JSON.stringify(state));
    }
    if (isFirstRender.current) {
      isFirstRender.current = false;
    }
  }, [key, state]);

  return [state, setState];
}

export let globalAudio: any = undefined;

export function resetGlobalAudio() {
  if (globalAudio) {
    globalAudio.pause();
    globalAudio.currentTime = 0;
  } else {
    globalAudio = new Audio();
  }
}

export async function speak(text: string) {
  const encodedText = encodeURIComponent(text);
  const url = `/api/tts?text=${encodedText}`;
  globalAudio.src = url;
  globalAudio.play();
  await new Promise<void>((resolve) => {
    globalAudio.onended = function () {
      resolve();
    };
  });
  await new Promise((resolve) => setTimeout(resolve, 500));
}



---
File: /CopilotKit/examples/next-openai/src/styles/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /CopilotKit/examples/next-openai/.eslintrc.js
---

module.exports = {
  root: true,
  extends: ["custom"],
};



---
File: /CopilotKit/examples/next-openai/next-env.d.ts
---

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.



---
File: /CopilotKit/examples/next-openai/next.config.js
---

module.exports = {
  reactStrictMode: true,
};



---
File: /CopilotKit/examples/next-openai/postcss.config.js
---

// If you want to use other PostCSS plugins, see the following:
// https://tailwindcss.com/docs/using-with-preprocessors

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};



---
File: /CopilotKit/examples/next-openai/tailwind.config.js
---

// tailwind config is required for editor support

const sharedConfig = require("tailwind-config/tailwind.config.js");

module.exports = {
  presets: [sharedConfig],
};



---
File: /CopilotKit/examples/next-pages-router/pages/api/copilotkit.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSPagesRouterEndpoint,
} from "@copilotkit/runtime";
import { NextApiRequest, NextApiResponse } from "next";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "say hello so someone by roasting their name",
      parameters: [
        {
          name: "roast",
          description: "A sentence or two roasting the name of the person",
          type: "string",
          required: true,
        },
      ],
      handler: ({ roast }) => {
        console.log(roast);
        return "The person has been roasted.";
      },
    },
  ],
});

// This is required for file upload to work
export const config = {
  api: {
    bodyParser: false,
  },
};

// const copilotRuntimeHandler = copilotRuntimeNextJSPagesRouterEndpoint({
//   endpoint: "/api/copilotkit",
//   runtime,
//   serviceAdapter,
// });

// export default copilotRuntimeHandler;

// OR

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const handleRequest = copilotRuntimeNextJSPagesRouterEndpoint({
    endpoint: "/api/copilotkit",
    runtime,
    serviceAdapter,
  });

  return await handleRequest(req, res);
};

export default handler;



---
File: /CopilotKit/examples/next-pages-router/pages/api/hello.ts
---

// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  name: string;
};

export default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  res.status(200).json({ name: "John Doe" });
}



---
File: /CopilotKit/examples/next-pages-router/pages/_app.tsx
---

import "../styles/globals.css";
import type { AppProps } from "next/app";

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}



---
File: /CopilotKit/examples/next-pages-router/pages/_document.tsx
---

import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}



---
File: /CopilotKit/examples/next-pages-router/pages/index.tsx
---

"use client";

import Image from "next/image";
import { Inter } from "next/font/google";
import { CopilotKit } from "@copilotkit/react-core";
import { CopilotKitCSSProperties, CopilotSidebar } from "@copilotkit/react-ui";

const inter = Inter({ subsets: ["latin"] });

export default function Home() {
  return (
    <CopilotKit
      runtimeUrl="/api/copilotkit"
      transcribeAudioUrl="/api/transcribe"
      textToSpeechUrl="/api/tts"
    >
      <CopilotSidebar
        instructions={"Be friendly and helpful to the user."}
        defaultOpen={true}
        labels={{
          title: "Copilot",
          initial: "Hi you! 👋 I can help you with anything.",
        }}
        clickOutsideToClose={false}
      >
        <div>
          <h1>Hello</h1>
        </div>
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/examples/next-pages-router/styles/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}



---
File: /CopilotKit/examples/next-pages-router/.eslintrc.js
---

module.exports = {
  root: true,
  extends: ["custom"],
};



---
File: /CopilotKit/examples/next-pages-router/tailwind.config.ts
---

// tailwind config is required for editor support

const sharedConfig = require("tailwind-config/tailwind.config.js");

module.exports = {
  presets: [sharedConfig],
};



---
File: /CopilotKit/examples/node-express/src/index.ts
---

import express from "express";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "say hello so someone by roasting their name",
      parameters: [
        {
          name: "roast",
          description: "A sentence or two roasting the name of the person",
          type: "string",
          required: true,
        },
      ],
      handler: ({ roast }: { roast: string }) => {
        console.log(roast);
        return "The person has been roasted.";
      },
    },
  ],
});

const copilotRuntime = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/copilotkit",
  runtime,
  serviceAdapter,
});

const app = express();

// app.use("/copilotkit", copilotRuntime);

// OR

app.use("/copilotkit", (req, res, next) => {
  return copilotRuntime(req, res, next);
});

app.listen(4000, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/examples/node-express/.eslintrc.js
---

module.exports = {
  root: true,
  extends: ["custom"],
};



---
File: /CopilotKit/examples/node-http/src/index.ts
---

import { createServer } from "node:http";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "say hello so someone by roasting their name",
      parameters: [
        {
          name: "roast",
          description: "A sentence or two roasting the name of the person",
          type: "string",
          required: true,
        },
      ],
      handler: ({ roast }) => {
        console.log(roast);
        return "The person has been roasted.";
      },
    },
  ],
});

const copilotRuntime = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/copilotkit",
  runtime,
  serviceAdapter,
});

// const server = createServer(copilotRuntime);

// OR

const server = createServer((req, res) => {
  return copilotRuntime(req, res);
});

server.listen(4000, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/examples/node-http/.eslintrc.js
---

module.exports = {
  root: true,
  extends: ["custom"],
};



---
File: /CopilotKit/packages/react-core/src/components/copilot-provider/copilotkit-props.tsx
---

import { ReactNode } from "react";

/**
 * Props for CopilotKit.
 */

export interface CopilotKitProps {
  /**
   *  Your Copilot Cloud API key. Don't have it yet? Go to https://cloud.copilotkit.ai and get one for free.
   */
  publicApiKey?: string;

  /**
   * Restrict input to a specific topic.
   */
  cloudRestrictToTopic?: {
    validTopics?: string[];
    invalidTopics?: string[];
  };

  /**
   * The endpoint for the Copilot Runtime instance. [Click here for more information](/concepts/copilot-runtime).
   */
  runtimeUrl?: string;

  /**
   * The endpoint for the Copilot transcribe audio service.
   */
  transcribeAudioUrl?: string;

  /**
   * The endpoint for the Copilot text to speech service.
   */
  textToSpeechUrl?: string;

  /**
   * Additional headers to be sent with the request.
   *
   * For example:
   * ```json
   * {
   *   "Authorization": "Bearer X"
   * }
   * ```
   */
  headers?: Record<string, string>;

  /**
   * The children to be rendered within the CopilotKit.
   */
  children: ReactNode;

  /**
   * Custom properties to be sent with the request
   * For example:
   * ```js
   * {
   *   'user_id': 'users_id',
   * }
   * ```
   */
  properties?: Record<string, any>;

  /**
   * Indicates whether the user agent should send or receive cookies from the other domain
   * in the case of cross-origin requests.
   */
  credentials?: RequestCredentials;

  /**
   * Whether to show the dev console.
   *
   * If set to "auto", the dev console will be show on localhost only.
   */
  showDevConsole?: boolean | "auto";

  /**
   * The name of the agent to use.
   */
  agent?: string;
}



---
File: /CopilotKit/packages/react-core/src/components/copilot-provider/copilotkit.tsx
---

/**
 * This component will typically wrap your entire application (or a sub-tree of your application where you want to have a copilot). It provides the copilot context to all other components and hooks.
 *
 * ## Example
 *
 * You can find more information about self-hosting CopilotKit [here](/guides/self-hosting).
 *
 * ```tsx
 * import { CopilotKit } from "@copilotkit/react-core";
 *
 * <CopilotKit runtimeUrl="<your-runtime-url>">
 *   // ... your app ...
 * </CopilotKit>
 * ```
 */

import { useCallback, useRef, useState } from "react";
import {
  CopilotContext,
  CopilotApiConfig,
  InChatRenderFunction,
  ChatComponentsCache,
  AgentSession,
} from "../../context/copilot-context";
import useTree from "../../hooks/use-tree";
import { CopilotChatSuggestionConfiguration, DocumentPointer } from "../../types";
import { flushSync } from "react-dom";
import {
  COPILOT_CLOUD_CHAT_URL,
  CopilotCloudConfig,
  FunctionCallHandler,
} from "@copilotkit/shared";
import { AgentStateMessage, Message } from "@copilotkit/runtime-client-gql";

import { FrontendAction } from "../../types/frontend-action";
import useFlatCategoryStore from "../../hooks/use-flat-category-store";
import { CopilotKitProps } from "./copilotkit-props";
import { CoagentAction } from "../../types/coagent-action";
import { CoagentState } from "../../types/coagent-state";

export function CopilotKit({ children, ...props }: CopilotKitProps) {
  // Compute all the functions and properties that we need to pass
  // to the CopilotContext.

  if (!props.runtimeUrl && !props.publicApiKey) {
    throw new Error(
      "Please provide either a runtimeUrl or a publicApiKey to the CopilotKit component.",
    );
  }

  const chatApiEndpoint = props.runtimeUrl || COPILOT_CLOUD_CHAT_URL;

  const [actions, setActions] = useState<Record<string, FrontendAction<any>>>({});
  const [coagentActions, setCoagentActions] = useState<Record<string, CoagentAction<any>>>({});
  const chatComponentsCache = useRef<ChatComponentsCache>({
    actions: {},
    coagentActions: {},
  });
  const { addElement, removeElement, printTree } = useTree();
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [chatInstructions, setChatInstructions] = useState("");

  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments,
  } = useFlatCategoryStore<DocumentPointer>();

  const setAction = useCallback((id: string, action: FrontendAction<any>) => {
    setActions((prevPoints) => {
      return {
        ...prevPoints,
        [id]: action,
      };
    });
  }, []);

  const removeAction = useCallback((id: string) => {
    setActions((prevPoints) => {
      const newPoints = { ...prevPoints };
      delete newPoints[id];
      return newPoints;
    });
  }, []);

  const setCoagentAction = useCallback((id: string, action: CoagentAction<any>) => {
    setCoagentActions((prevPoints) => {
      return {
        ...prevPoints,
        [id]: action,
      };
    });
  }, []);

  const removeCoagentAction = useCallback((id: string) => {
    setCoagentActions((prevPoints) => {
      const newPoints = { ...prevPoints };
      delete newPoints[id];
      return newPoints;
    });
  }, []);

  const getContextString = useCallback(
    (documents: DocumentPointer[], categories: string[]) => {
      const documentsString = documents
        .map((document) => {
          return `${document.name} (${document.sourceApplication}):\n${document.getContents()}`;
        })
        .join("\n\n");

      const nonDocumentStrings = printTree(categories);

      return `${documentsString}\n\n${nonDocumentStrings}`;
    },
    [printTree],
  );

  const addContext = useCallback(
    (
      context: string,
      parentId?: string,
      categories: string[] = defaultCopilotContextCategories,
    ) => {
      return addElement(context, categories, parentId);
    },
    [addElement],
  );

  const removeContext = useCallback(
    (id: string) => {
      removeElement(id);
    },
    [removeElement],
  );

  const getFunctionCallHandler = useCallback(
    (customEntryPoints?: Record<string, FrontendAction<any>>) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));
    },
    [actions],
  );

  const getDocumentsContext = useCallback(
    (categories: string[]) => {
      return allDocuments(categories);
    },
    [allDocuments],
  );

  const addDocumentContext = useCallback(
    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument],
  );

  const removeDocumentContext = useCallback(
    (documentId: string) => {
      removeDocument(documentId);
    },
    [removeDocument],
  );

  if (!props.publicApiKey) {
    if (props.cloudRestrictToTopic) {
      throw new Error(
        "To use the cloudRestrictToTopic feature, please sign up at https://copilotkit.ai and provide a publicApiKey.",
      );
    }
  }

  let cloud: CopilotCloudConfig | undefined = undefined;
  if (props.publicApiKey) {
    cloud = {
      guardrails: {
        input: {
          restrictToTopic: {
            enabled: props.cloudRestrictToTopic ? true : false,
            validTopics: props.cloudRestrictToTopic?.validTopics || [],
            invalidTopics: props.cloudRestrictToTopic?.invalidTopics || [],
          },
        },
      },
    };
  }

  // get the appropriate CopilotApiConfig from the props
  const copilotApiConfig: CopilotApiConfig = {
    publicApiKey: props.publicApiKey,
    ...(cloud ? { cloud } : {}),
    chatApiEndpoint: chatApiEndpoint,
    headers: props.headers || {},
    properties: props.properties || {},
    transcribeAudioUrl: props.transcribeAudioUrl,
    textToSpeechUrl: props.textToSpeechUrl,
    credentials: props.credentials,
  };

  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = useState<{
    [key: string]: CopilotChatSuggestionConfiguration;
  }>({});

  const addChatSuggestionConfiguration = (
    id: string,
    suggestion: CopilotChatSuggestionConfiguration,
  ) => {
    setChatSuggestionConfiguration((prev) => ({ ...prev, [id]: suggestion }));
  };

  const removeChatSuggestionConfiguration = (id: string) => {
    setChatSuggestionConfiguration((prev) => {
      const { [id]: _, ...rest } = prev;
      return rest;
    });
  };

  const [coagentStates, setCoagentStates] = useState<Record<string, CoagentState>>({});
  let initialAgentSession: AgentSession | null = null;
  if (props.agent) {
    initialAgentSession = {
      agentName: props.agent,
    };
  }

  const [agentSession, setAgentSession] = useState<AgentSession | null>(initialAgentSession);

  return (
    <CopilotContext.Provider
      value={{
        actions,
        chatComponentsCache,
        getFunctionCallHandler,
        setAction,
        removeAction,
        coagentActions,
        setCoagentAction,
        removeCoagentAction,
        getContextString,
        addContext,
        removeContext,
        getDocumentsContext,
        addDocumentContext,
        removeDocumentContext,
        copilotApiConfig: copilotApiConfig,
        messages,
        setMessages,
        isLoading,
        setIsLoading,
        chatSuggestionConfiguration,
        addChatSuggestionConfiguration,
        removeChatSuggestionConfiguration,
        chatInstructions,
        setChatInstructions,
        showDevConsole: props.showDevConsole === undefined ? "auto" : props.showDevConsole,
        coagentStates,
        setCoagentStates,
        agentSession,
        setAgentSession,
      }}
    >
      {children}
    </CopilotContext.Provider>
  );
}

export const defaultCopilotContextCategories = ["global"];

function entryPointsToFunctionCallHandler(actions: FrontendAction<any>[]): FunctionCallHandler {
  return async ({ messages, name, args }) => {
    let actionsByFunctionName: Record<string, FrontendAction<any>> = {};
    for (let action of actions) {
      actionsByFunctionName[action.name] = action;
    }

    const action = actionsByFunctionName[name];
    let result: any = undefined;
    if (action) {
      await new Promise<void>((resolve, reject) => {
        flushSync(async () => {
          try {
            result = await action.handler?.(args);
            resolve();
          } catch (error) {
            reject(error);
          }
        });
      });
      await new Promise((resolve) => setTimeout(resolve, 20));
    }
    return result;
  };
}



---
File: /CopilotKit/packages/react-core/src/components/copilot-provider/index.ts
---

export { CopilotKit, defaultCopilotContextCategories } from "./copilotkit";

export type { CopilotKitProps } from "./copilotkit-props";



---
File: /CopilotKit/packages/react-core/src/components/index.ts
---

export * from "./copilot-provider";



---
File: /CopilotKit/packages/react-core/src/context/copilot-context.tsx
---

import { CopilotCloudConfig, FunctionCallHandler } from "@copilotkit/shared";
import { Message } from "@copilotkit/runtime-client-gql";
import { ActionRenderProps, FrontendAction } from "../types/frontend-action";
import React from "react";
import { TreeNodeId } from "../hooks/use-tree";
import { DocumentPointer } from "../types";
import { CopilotChatSuggestionConfiguration } from "../types/chat-suggestion-configuration";
import { CoagentAction, CoagentActionRenderProps } from "../types/coagent-action";
import { CoagentState } from "../types/coagent-state";

/**
 * Interface for the configuration of the Copilot API.
 */
export interface CopilotApiConfig {
  /**
   * The public API key for Copilot Cloud.
   */
  publicApiKey?: string;

  /**
   * The configuration for Copilot Cloud.
   */
  cloud?: CopilotCloudConfig;

  /**
   * The endpoint for the chat API.
   */
  chatApiEndpoint: string;

  /**
   * The endpoint for the Copilot transcribe audio service.
   */
  transcribeAudioUrl?: string;

  /**
   * The endpoint for the Copilot text to speech service.
   */
  textToSpeechUrl?: string;

  /**
   * additional headers to be sent with the request
   * @default {}
   * @example
   * ```
   * {
   *   'Authorization': 'Bearer your_token_here'
   * }
   * ```
   */
  headers: Record<string, string>;

  /**
   * Custom properties to be sent with the request
   * @default {}
   * @example
   * ```
   * {
   *   'user_id': 'user_id'
   * }
   * ```
   */
  properties?: Record<string, any>;

  /**
   * Indicates whether the user agent should send or receive cookies from the other domain
   * in the case of cross-origin requests.
   */
  credentials?: RequestCredentials;
}

export type InChatRenderFunction = (props: ActionRenderProps<any>) => string | JSX.Element;
export type CoagentInChatRenderFunction = (
  props: CoagentActionRenderProps<any>,
) => string | JSX.Element;

export interface ChatComponentsCache {
  actions: Record<string, InChatRenderFunction | string>;
  coagentActions: Record<string, CoagentInChatRenderFunction | string>;
}

export interface AgentSession {
  agentName: string;
  threadId?: string;
  nodeName?: string;
}

export interface CopilotContextParams {
  // function-calling
  actions: Record<string, FrontendAction<any>>;
  setAction: (id: string, action: FrontendAction<any>) => void;
  removeAction: (id: string) => void;

  // coagent actions
  coagentActions: Record<string, CoagentAction<any>>;
  setCoagentAction: (id: string, action: CoagentAction<any>) => void;
  removeCoagentAction: (id: string) => void;

  chatComponentsCache: React.RefObject<ChatComponentsCache>;

  getFunctionCallHandler: (
    customEntryPoints?: Record<string, FrontendAction<any>>,
  ) => FunctionCallHandler;

  // text context
  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;
  removeContext: (id: TreeNodeId) => void;
  getContextString: (documents: DocumentPointer[], categories: string[]) => string;

  // document context
  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;
  removeDocumentContext: (documentId: string) => void;
  getDocumentsContext: (categories: string[]) => DocumentPointer[];

  // chat
  messages: Message[];
  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;

  isLoading: boolean;
  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;

  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };
  addChatSuggestionConfiguration: (
    id: string,
    suggestion: CopilotChatSuggestionConfiguration,
  ) => void;
  removeChatSuggestionConfiguration: (id: string) => void;

  chatInstructions: string;
  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;

  // api endpoints
  copilotApiConfig: CopilotApiConfig;

  showDevConsole: boolean | "auto";

  // agents
  coagentStates: Record<string, CoagentState>;
  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;
  agentSession: AgentSession | null;
  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;
}

const emptyCopilotContext: CopilotContextParams = {
  actions: {},
  setAction: () => {},
  removeAction: () => {},

  coagentActions: {},
  setCoagentAction: () => {},
  removeCoagentAction: () => {},

  chatComponentsCache: { current: { actions: {}, coagentActions: {} } },
  getContextString: (documents: DocumentPointer[], categories: string[]) =>
    returnAndThrowInDebug(""),
  addContext: () => "",
  removeContext: () => {},

  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),

  messages: [],
  setMessages: () => returnAndThrowInDebug([]),

  isLoading: false,
  setIsLoading: () => returnAndThrowInDebug(false),

  chatInstructions: "",
  setChatInstructions: () => returnAndThrowInDebug(""),

  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),
  addDocumentContext: () => returnAndThrowInDebug(""),
  removeDocumentContext: () => {},

  copilotApiConfig: new (class implements CopilotApiConfig {
    get chatApiEndpoint(): string {
      throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
    }

    get headers(): Record<string, string> {
      return {};
    }
    get body(): Record<string, any> {
      return {};
    }
  })(),

  chatSuggestionConfiguration: {},
  addChatSuggestionConfiguration: () => {},
  removeChatSuggestionConfiguration: () => {},
  showDevConsole: "auto",
  coagentStates: {},
  setCoagentStates: () => {},

  agentSession: null,
  setAgentSession: () => {},
};

export const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);

export function useCopilotContext(): CopilotContextParams {
  const context = React.useContext(CopilotContext);
  if (context === emptyCopilotContext) {
    throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  }
  return context;
}

function returnAndThrowInDebug<T>(value: T): T {
  throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  return value;
}



---
File: /CopilotKit/packages/react-core/src/context/index.ts
---

export { CopilotContext, useCopilotContext } from "./copilot-context";
export type {
  CopilotContextParams,
  CoagentInChatRenderFunction,
  CopilotApiConfig,
} from "./copilot-context";



---
File: /CopilotKit/packages/react-core/src/hooks/index.ts
---

export { useCopilotChat } from "./use-copilot-chat";
export type { UseCopilotChatOptions } from "./use-copilot-chat";
export type { UseCopilotChatReturn } from "./use-copilot-chat";

export { useCopilotAction } from "./use-copilot-action";
export { useCoagentStateRender } from "./use-coagent-state-render";
export { useMakeCopilotDocumentReadable } from "./use-make-copilot-document-readable";
export { type UseChatHelpers } from "./use-chat";
export { useCopilotReadable } from "./use-copilot-readable";
export { useCoAgent } from "./use-coagent";



---
File: /CopilotKit/packages/react-core/src/hooks/use-chat.ts
---

import { useRef } from "react";
import {
  FunctionCallHandler,
  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,
  actionParametersToJsonSchema,
  CoagentActionHandler,
} from "@copilotkit/shared";
import {
  Message,
  TextMessage,
  ActionExecutionMessage,
  ResultMessage,
  CopilotRuntimeClient,
  convertMessagesToGqlInput,
  filterAdjacentAgentStateMessages,
  filterAgentStateMessages,
  convertGqlOutputToMessages,
  MessageStatusCode,
  MessageRole,
  Role,
  CopilotRequestType,
  AgentStateMessage,
} from "@copilotkit/runtime-client-gql";

import { CopilotApiConfig } from "../context";
import { FrontendAction } from "../types/frontend-action";
import { CoagentState } from "../types/coagent-state";
import { AgentSession } from "../context/copilot-context";

export type UseChatOptions = {
  /**
   * System messages of the chat. Defaults to an empty array.
   */
  initialMessages?: Message[];
  /**
   * Callback function to be called when a function call is received.
   * If the function returns a `ChatRequest` object, the request will be sent
   * automatically to the API and will be used to update the chat.
   */
  onFunctionCall?: FunctionCallHandler;

  /**
   * Callback function to be called when a coagent action is received.
   */
  onCoagentAction?: CoagentActionHandler;

  /**
   * Function definitions to be sent to the API.
   */
  actions: FrontendAction<any>[];

  /**
   * The CopilotKit API configuration.
   */
  copilotConfig: CopilotApiConfig;

  /**
   * The current list of messages in the chat.
   */
  messages: Message[];
  /**
   * The setState-powered method to update the chat messages.
   */
  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;

  /**
   * A callback to get the latest system message.
   */
  makeSystemMessageCallback: () => TextMessage;

  /**
   * Whether the API request is in progress
   */
  isLoading: boolean;

  /**
   * setState-powered method to update the isChatLoading value
   */
  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;

  /**
   * The current list of coagent states.
   */
  coagentStates: Record<string, CoagentState>;

  /**
   * setState-powered method to update the agent states
   */
  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;

  /**
   * The current agent session.
   */
  agentSession: AgentSession | null;

  /**
   * setState-powered method to update the agent session
   */
  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;
};

export type UseChatHelpers = {
  /**
   * Append a user message to the chat list. This triggers the API call to fetch
   * the assistant's response.
   * @param message The message to append
   */
  append: (message: Message) => Promise<void>;
  /**
   * Reload the last AI chat response for the given chat history. If the last
   * message isn't from the assistant, it will request the API to generate a
   * new response.
   */
  reload: () => Promise<void>;
  /**
   * Abort the current request immediately, keep the generated tokens if any.
   */
  stop: () => void;
};

export function useChat(options: UseChatOptions): UseChatHelpers {
  const {
    messages,
    setMessages,
    makeSystemMessageCallback,
    copilotConfig,
    setIsLoading,
    initialMessages,
    isLoading,
    actions,
    onFunctionCall,
    onCoagentAction,
    setCoagentStates,
    coagentStates,
    agentSession,
    setAgentSession,
  } = options;

  const abortControllerRef = useRef<AbortController>();
  const threadIdRef = useRef<string | null>(null);
  const runIdRef = useRef<string | null>(null);

  const runChatCompletionRef = useRef<(previousMessages: Message[]) => Promise<Message[]>>();
  // We need to keep a ref of coagent states because of renderAndWait - making sure
  // the latest state is sent to the API
  // This is a workaround and needs to be addressed in the future
  const coagentStatesRef = useRef<Record<string, CoagentState>>(coagentStates);
  coagentStatesRef.current = coagentStates;
  const agentSessionRef = useRef<AgentSession | null>(agentSession);
  agentSessionRef.current = agentSession;

  const publicApiKey = copilotConfig.publicApiKey;

  const headers = {
    ...(copilotConfig.headers || {}),
    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),
  };

  const runtimeClient = new CopilotRuntimeClient({
    url: copilotConfig.chatApiEndpoint,
    publicApiKey: copilotConfig.publicApiKey,
    headers,
    credentials: copilotConfig.credentials,
  });

  const runChatCompletion = async (previousMessages: Message[]): Promise<Message[]> => {
    setIsLoading(true);

    // this message is just a placeholder. It will disappear once the first real message
    // is received
    let newMessages: Message[] = [
      new TextMessage({
        content: "",
        role: Role.Assistant,
      }),
    ];
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setMessages([...previousMessages, ...newMessages]);

    const systemMessage = makeSystemMessageCallback();

    const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];

    const stream = CopilotRuntimeClient.asStream(
      runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: actions
              .filter((action) => !action.disabled)
              .map((action) => ({
                name: action.name,
                description: action.description || "",
                jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),
              })),
            url: window.location.href,
          },
          threadId: threadIdRef.current,
          runId: runIdRef.current,
          messages: convertMessagesToGqlInput(filterAgentStateMessages(messagesWithContext)),
          ...(copilotConfig.cloud
            ? {
                cloud: {
                  ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled
                    ? {
                        guardrails: {
                          inputValidationRules: {
                            allowList:
                              copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,
                            denyList:
                              copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,
                          },
                        },
                      }
                    : {}),
                },
              }
            : {}),
          metadata: {
            requestType: CopilotRequestType.Chat,
          },
          ...(agentSessionRef.current
            ? {
                agentSession: agentSessionRef.current,
              }
            : {}),
          agentStates: Object.values(coagentStatesRef.current).map((state) => ({
            agentName: state.name,
            state: JSON.stringify(state.state),
          })),
        },
        properties: copilotConfig.properties,
        signal: abortControllerRef.current?.signal,
      }),
    );

    const guardrailsEnabled =
      copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;

    const reader = stream.getReader();

    let actionResults: { [id: string]: string } = {};
    let executedCoagentActions: string[] = [];

    try {
      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          break;
        }

        if (!value?.generateCopilotResponse) {
          continue;
        }

        threadIdRef.current = value.generateCopilotResponse.threadId || null;
        runIdRef.current = value.generateCopilotResponse.runId || null;

        const messages = convertGqlOutputToMessages(
          filterAdjacentAgentStateMessages(value.generateCopilotResponse.messages),
        );

        if (messages.length === 0) {
          continue;
        }

        newMessages = [];

        // request failed, display error message
        if (
          value.generateCopilotResponse.status?.__typename === "FailedResponseStatus" &&
          value.generateCopilotResponse.status.reason === "GUARDRAILS_VALIDATION_FAILED"
        ) {
          newMessages = [
            new TextMessage({
              role: MessageRole.Assistant,
              content: value.generateCopilotResponse.status.details?.guardrailsReason || "",
            }),
          ];
        }

        // add messages to the chat
        else {
          for (const message of messages) {
            newMessages.push(message);
            // execute regular action executions
            if (
              message instanceof ActionExecutionMessage &&
              message.status.code !== MessageStatusCode.Pending &&
              message.scope === "client" &&
              onFunctionCall
            ) {
              if (!(message.id in actionResults)) {
                // Do not execute a function call if guardrails are enabled but the status is not known
                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {
                  break;
                }
                // execute action
                try {
                  // We update the message state before calling the handler so that the render
                  // function can be called with `executing` state
                  setMessages([...previousMessages, ...newMessages]);

                  const result = await onFunctionCall({
                    messages: previousMessages,
                    name: message.name,
                    args: message.arguments,
                  });
                  actionResults[message.id] = result;
                } catch (e) {
                  actionResults[message.id] = `Failed to execute action ${message.name}`;
                  console.error(`Failed to execute action ${message.name}: ${e}`);
                }
              }
              // add the result message
              newMessages.push(
                new ResultMessage({
                  result: ResultMessage.encodeResult(actionResults[message.id]),
                  actionExecutionId: message.id,
                  actionName: message.name,
                }),
              );
            }
            // execute coagent actions
            if (
              message instanceof AgentStateMessage &&
              !message.active &&
              !executedCoagentActions.includes(message.id) &&
              onCoagentAction
            ) {
              // Do not execute a coagent action if guardrails are enabled but the status is not known
              if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {
                break;
              }
              // execute coagent action
              await onCoagentAction({
                name: message.agentName,
                nodeName: message.nodeName,
                state: message.state,
              });
              executedCoagentActions.push(message.id);
            }
          }

          const lastAgentStateMessage = [...messages]
            .reverse()
            .find((message) => message instanceof AgentStateMessage);

          if (lastAgentStateMessage) {
            if (lastAgentStateMessage.running) {
              setCoagentStates((prevAgentStates) => ({
                ...prevAgentStates,
                [lastAgentStateMessage.agentName]: {
                  name: lastAgentStateMessage.agentName,
                  state: lastAgentStateMessage.state,
                  running: lastAgentStateMessage.running,
                  active: lastAgentStateMessage.active,
                  threadId: lastAgentStateMessage.threadId,
                  nodeName: lastAgentStateMessage.nodeName,
                  runId: lastAgentStateMessage.runId,
                },
              }));
              setAgentSession({
                threadId: lastAgentStateMessage.threadId,
                agentName: lastAgentStateMessage.agentName,
                nodeName: lastAgentStateMessage.nodeName,
              });
            } else {
              setAgentSession(null);
            }
          }
        }

        if (newMessages.length > 0) {
          // Update message state
          setMessages([...previousMessages, ...newMessages]);
        }
      }

      if (
        // if we have client side results
        Object.values(actionResults).length ||
        // or the last message we received is a result
        (newMessages.length && newMessages[newMessages.length - 1] instanceof ResultMessage)
      ) {
        // run the completion again and return the result

        // wait for next tick to make sure all the react state updates
        // - tried using react-dom's flushSync, but it did not work
        await new Promise((resolve) => setTimeout(resolve, 10));

        return await runChatCompletionRef.current!([...previousMessages, ...newMessages]);
      } else {
        return newMessages.slice();
      }
    } finally {
      setIsLoading(false);
    }
  };

  runChatCompletionRef.current = runChatCompletion;

  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {
    await runChatCompletionRef.current!(messages);
  };

  const append = async (message: Message): Promise<void> => {
    if (isLoading) {
      return;
    }

    const newMessages = [...messages, message];
    setMessages(newMessages);
    return runChatCompletionAndHandleFunctionCall(newMessages);
  };

  const reload = async (): Promise<void> => {
    if (isLoading || messages.length === 0) {
      return;
    }
    let newMessages = [...messages];
    const lastMessage = messages[messages.length - 1];

    if (lastMessage instanceof TextMessage && lastMessage.role === "assistant") {
      newMessages = newMessages.slice(0, -1);
    }

    setMessages(newMessages);

    return runChatCompletionAndHandleFunctionCall(newMessages);
  };

  const stop = (): void => {
    abortControllerRef.current?.abort();
  };

  return {
    append,
    reload,
    stop,
  };
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-coagent-state-render.ts
---

import { useRef, useContext, useEffect } from "react";
import { CopilotContext } from "../context/copilot-context";
import { randomId } from "@copilotkit/shared";
import { CoagentAction } from "../types/coagent-action";

// We implement useCoAgentAction dependency handling so that
// the developer has the option to not provide any dependencies.
// see useCopilotAction for more details about this approach.
export function useCoagentStateRender<T = any>(
  action: CoagentAction<T>,
  dependencies?: any[],
): void {
  const { setCoagentAction, removeCoagentAction, coagentActions, chatComponentsCache } =
    useContext(CopilotContext);
  const idRef = useRef<string>(randomId());

  const key = `${action.name}-${action.nodeName || "global"}`;

  if (dependencies === undefined) {
    if (coagentActions[idRef.current]) {
      coagentActions[idRef.current].handler = action.handler as any;
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.coagentActions[key] = action.render;
        }
      }
    }
  }

  useEffect(() => {
    setCoagentAction(idRef.current, action as any);
    if (chatComponentsCache.current !== null && action.render !== undefined) {
      chatComponentsCache.current.coagentActions[key] = action.render;
    }
    return () => {
      removeCoagentAction(idRef.current);
    };
  }, [
    setCoagentAction,
    removeCoagentAction,
    action.name,
    // include render only if it's a string
    typeof action.render === "string" ? action.render : undefined,
    // dependencies set by the developer
    ...(dependencies || []),
  ]);
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-coagent.ts
---

import { useEffect } from "react";
import { CopilotContextParams, useCopilotContext } from "../context";
import { CoagentState } from "../types/coagent-state";
import { useCopilotChat } from "./use-copilot-chat";
import { AgentStateMessage, Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";

interface WithInternalStateManagementAndInitial<T> {
  name: string;
  initialState: T;
}

interface WithInternalStateManagement {
  name: string;
  initialState?: any; // Optional initialState with default type any
}

interface WithExternalStateManagement<T> {
  name: string;
  state: T;
  setState: (newState: T | ((prevState: T | undefined) => T)) => void;
}

type UseCoagentOptions<T> =
  | WithInternalStateManagementAndInitial<T>
  | WithInternalStateManagement
  | WithExternalStateManagement<T>;

export interface UseCoagentReturnType<T> {
  name: string;
  nodeName?: string;
  threadId?: string;
  running: boolean;
  state: T;
  setState: (newState: T | ((prevState: T | undefined) => T)) => void;
  start: () => void;
  stop: () => void;
  run: (hint?: HintFunction) => Promise<void>;
}

export interface HintFunctionParams {
  previousState: any;
  currentState: any;
}

export type HintFunction = (params: HintFunctionParams) => Message | undefined;

export function useCoAgent<T = any>(options: UseCoagentOptions<T>): UseCoagentReturnType<T> {
  const isExternalStateManagement = (
    options: UseCoagentOptions<T>,
  ): options is WithExternalStateManagement<T> => {
    return "state" in options && "setState" in options;
  };

  const { name } = options;

  const isInternalStateManagementWithInitial = (
    options: UseCoagentOptions<T>,
  ): options is WithInternalStateManagementAndInitial<T> => {
    return "initialState" in options;
  };

  const context = useCopilotContext();
  const { coagentStates, setCoagentStates } = context;
  const { appendMessage } = useCopilotChat();

  const getCoagentState = (coagentStates: Record<string, CoagentState>, name: string) => {
    if (coagentStates[name]) {
      return coagentStates[name];
    } else {
      return {
        name,
        state: isInternalStateManagementWithInitial(options) ? options.initialState : {},
        running: false,
        active: false,
        threadId: undefined,
        nodeName: undefined,
        runId: undefined,
      };
    }
  };

  // if we manage state internally, we need to provide a function to set the state
  const setState = (newState: T | ((prevState: T | undefined) => T)) => {
    setCoagentStates((prevAgentStates) => {
      let coagentState: CoagentState = getCoagentState(prevAgentStates, name);

      const updatedState =
        typeof newState === "function" ? (newState as Function)(coagentState.state) : newState;

      return {
        ...prevAgentStates,
        [name]: {
          ...coagentState,
          state: updatedState,
        },
      };
    });
  };

  const coagentState = getCoagentState(coagentStates, name);

  const state = isExternalStateManagement(options) ? options.state : coagentState.state;

  // Sync internal state with external state if state management is external
  useEffect(() => {
    if (isExternalStateManagement(options)) {
      setState(options.state);
    } else if (coagentStates[name] === undefined) {
      setState(options.initialState === undefined ? {} : options.initialState);
    }
  }, [isExternalStateManagement(options) ? JSON.stringify(options.state) : undefined]);

  // Return the state and setState function
  return {
    name,
    nodeName: coagentState.nodeName,
    state,
    setState,
    running: coagentState.running,
    start: () => {
      startAgent(name, context);
    },
    stop: () => {
      stopAgent(name, context);
    },
    run: (hint?: HintFunction) => {
      return runAgent(name, context, appendMessage, hint);
    },
  };
}

function startAgent(name: string, context: CopilotContextParams) {
  const { setAgentSession } = context;
  setAgentSession({
    agentName: name,
  });
}

function stopAgent(name: string, context: CopilotContextParams) {
  const { agentSession, setAgentSession } = context;
  if (agentSession && agentSession.agentName === name) {
    setAgentSession(null);
  } else {
    console.warn(`No agent session found for ${name}`);
  }
}

async function runAgent(
  name: string,
  context: CopilotContextParams,
  appendMessage: (message: Message) => Promise<void>,
  hint?: HintFunction,
) {
  const { agentSession, setAgentSession } = context;
  if (!agentSession || agentSession.agentName !== name) {
    setAgentSession({
      agentName: name,
    });
  }

  let previousState: any = null;
  for (let i = context.messages.length - 1; i >= 0; i--) {
    const message = context.messages[i];
    if (message instanceof AgentStateMessage && message.agentName === name) {
      previousState = message.state;
    }
  }

  let state = context.coagentStates?.[name]?.state || {};

  if (hint) {
    const hintMessage = hint({ previousState, currentState: state });
    if (hintMessage) {
      await appendMessage(hintMessage);
    }
  }
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-copilot-action.ts
---

/**
 * <img src="/images/use-copilot-action/useCopilotAction.gif" width="500" />
 * `useCopilotAction` is a React hook that you can use in your application to provide
 * custom actions that can be called by the AI. Essentially, it allows the Copilot to
 * execute these actions contextually during a chat, based on the user's interactions
 * and needs.
 *
 * Here's how it works:
 *
 * Use `useCopilotAction` to set up actions that the Copilot can call. To provide
 * more context to the Copilot, you can provide it with a `description` (for example to explain
 * what the action does, under which conditions it can be called, etc.).
 *
 * Then you define the parameters of the action, which can be simple, e.g. primitives like strings or numbers,
 * or complex, e.g. objects or arrays.
 *
 * Finally, you provide a `handler` function that receives the parameters and returns a result.
 * CopilotKit takes care of automatically inferring the parameter types, so you get type safety
 * and autocompletion for free.
 *
 * To render a custom UI for the action, you can provide a `render()` function. This function
 * lets you render a custom component or return a string to display.
 *
 * ## Usage
 *
 * ### Simple Usage
 *
 * ```tsx
 * useCopilotAction({
 *   name: "sayHello",
 *   description: "Say hello to someone.",
 *   parameters: [
 *     {
 *       name: "name",
 *       type: "string",
 *       description: "name of the person to say greet",
 *     },
 *   ],
 *   handler: async ({ name }) => {
 *     alert(`Hello, ${name}!`);
 *   },
 * });
 * ```
 *
 * ## Generative UI
 *
 * This hooks enables you to dynamically generate UI elements and render them in the copilot chat. For more information, check out the [Generative UI](/concepts/generative-ui) page.
 */
import { useRef, useEffect } from "react";
import { FrontendAction, ActionRenderProps, ActionRenderPropsWait } from "../types/frontend-action";
import { useCopilotContext } from "../context/copilot-context";
import { Parameter, randomId } from "@copilotkit/shared";

/**
 * Options for the useCopilotAction hook.
 */
export interface UseCopilotActionOptions {
  /**
   * Something nce
   */
  some: string;
}

// We implement useCopilotAction dependency handling so that
// the developer has the option to not provide any dependencies.
// In this case, we assume they want to update the handler on each rerender.
// To avoid getting stuck in an infinite loop, we update the handler directly,
// skipping React state updates.
// This is ok in this case, because the handler is not part of any UI that
// needs to be updated.
// useCallback, useMemo or other memoization techniques are not suitable here,
// because they will cause a infinite rerender loop.
export function useCopilotAction<const T extends Parameter[] | [] = []>(
  action: FrontendAction<T>,
  dependencies?: any[],
): void {
  const { setAction, removeAction, actions, chatComponentsCache } = useCopilotContext();
  const idRef = useRef<string>(randomId());
  const renderAndWaitRef = useRef<RenderAndWait | null>(null);

  // clone the action to avoid mutating the original object
  action = { ...action };

  // If the developer provides a renderAndWait function, we transform the action
  // to use a promise internally, so that we can treat it like a normal action.
  if (action.renderAndWait) {
    const renderAndWait = action.renderAndWait!;

    // remove the renderAndWait function from the action
    action.renderAndWait = undefined;

    // add a handler that will be called when the action is executed
    action.handler = (async () => {
      // we create a new promise when the handler is called
      let resolve: (result: any) => void;
      let reject: (error: any) => void;
      const promise = new Promise<any>((resolvePromise, rejectPromise) => {
        resolve = resolvePromise;
        reject = rejectPromise;
      });
      renderAndWaitRef.current = { promise, resolve: resolve!, reject: reject! };
      // then we await the promise (it will be resolved in the original renderAndWait function)
      return await promise;
    }) as any;

    // add a render function that will be called when the action is rendered
    action.render = ((props: ActionRenderProps<any>): React.ReactElement => {
      const waitProps: ActionRenderPropsWait<any> = {
        status: props.status as any,
        args: props.args,
        result: props.result,
        handler: props.status === "executing" ? renderAndWaitRef.current!.resolve : undefined,
      };
      return renderAndWait(waitProps);
    }) as any;
  }

  // If the developer doesn't provide dependencies, we assume they want to
  // update handler and render function when the action object changes.
  // This ensures that any captured variables in the handler are up to date.
  if (dependencies === undefined) {
    if (actions[idRef.current]) {
      actions[idRef.current].handler = action.handler as any;
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.actions[action.name] = action.render;
        }
      }
    }
  }

  useEffect(() => {
    setAction(idRef.current, action as any);
    if (chatComponentsCache.current !== null && action.render !== undefined) {
      chatComponentsCache.current.actions[action.name] = action.render;
    }
    return () => {
      // NOTE: For now, we don't remove the chatComponentsCache entry when the action is removed.
      // This is because we currently don't have access to the messages array in CopilotContext.
      removeAction(idRef.current);
    };
  }, [
    setAction,
    removeAction,
    action.description,
    action.name,
    action.disabled,
    // This should be faster than deep equality checking
    // In addition, all major JS engines guarantee the order of object keys
    JSON.stringify(action.parameters),
    // include render only if it's a string
    typeof action.render === "string" ? action.render : undefined,
    // dependencies set by the developer
    ...(dependencies || []),
  ]);
}

interface RenderAndWait {
  promise: Promise<any>;
  resolve: (result: any) => void;
  reject: (error: any) => void;
}

// Usage Example:
// useCopilotAction({
//   name: "myAction",
//   parameters: [
//     { name: "arg1", type: "string", enum: ["option1", "option2", "option3"], required: false },
//     { name: "arg2", type: "number" },
//     {
//       name: "arg3",
//       type: "object",
//       attributes: [
//         { name: "nestedArg1", type: "boolean" },
//         { name: "xyz", required: false },
//       ],
//     },
//     { name: "arg4", type: "number[]" },
//   ],
//   handler: ({ arg1, arg2, arg3, arg4 }) => {
//     const x = arg3.nestedArg1;
//     const z = arg3.xyz;
//     console.log(arg1, arg2, arg3);
//   },
// });

// useCopilotAction({
//   name: "myAction",
//   handler: () => {
//     console.log("No parameters provided.");
//   },
// });



---
File: /CopilotKit/packages/react-core/src/hooks/use-copilot-chat.ts
---

/**
 * `useCopilotChat` is a React hook that lets you directly interact with the
 * Copilot instance. Use to implement a fully custom UI (headless UI) or to
 * programmatically interact with the Copilot instance managed by the default
 * UI.
 *
 * ## Usage
 *
 * ### Simple Usage
 *
 * ```tsx
 * import { useCopilotChat } from "@copilotkit/react-core";
 * import { Role, TextMessage } from "@copilotkit/runtime-client-gql";
 *
 * export function YourComponent() {
 *   const { appendMessage } = useCopilotChat();
 *
 *   appendMessage(
 *     new TextMessage({
 *       content: "Hello World",
 *       role: Role.User,
 *     }),
 *   );
 * }
 * ```
 *
 * `useCopilotChat` returns an object with the following properties:
 *
 * ```tsx
 * const {
 *   visibleMessages, // An array of messages that are currently visible in the chat.
 *   appendMessage, // A function to append a message to the chat.
 *   setMessages, // A function to set the messages in the chat.
 *   deleteMessage, // A function to delete a message from the chat.
 *   reloadMessages, // A function to reload the messages from the API.
 *   stopGeneration, // A function to stop the generation of the next message.
 *   isLoading, // A boolean indicating if the chat is loading.
 * } = useCopilotChat();
 * ```
 */
import { useRef, useEffect, useCallback } from "react";
import { useCopilotContext } from "../context/copilot-context";
import { Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { SystemMessageFunction } from "../types";
import { useChat } from "./use-chat";
import { defaultCopilotContextCategories } from "../components";
import { MessageStatusCode } from "@copilotkit/runtime-client-gql";
import { CoagentActionHandlerArguments } from "@copilotkit/shared";

export interface UseCopilotChatOptions {
  /**
   * A unique identifier for the chat. If not provided, a random one will be
   * generated. When provided, the `useChat` hook with the same `id` will
   * have shared states across components.
   */
  id?: string;

  /**
   * HTTP headers to be sent with the API request.
   */
  headers?: Record<string, string> | Headers;
  /**
   * System messages of the chat. Defaults to an empty array.
   */
  initialMessages?: Message[];

  /**
   * A function to generate the system message. Defaults to `defaultSystemMessage`.
   */
  makeSystemMessage?: SystemMessageFunction;
}

export interface UseCopilotChatReturn {
  visibleMessages: Message[];
  appendMessage: (message: Message) => Promise<void>;
  setMessages: (messages: Message[]) => void;
  deleteMessage: (messageId: string) => void;
  reloadMessages: () => Promise<void>;
  stopGeneration: () => void;
  isLoading: boolean;
}

export function useCopilotChat({
  makeSystemMessage,
  ...options
}: UseCopilotChatOptions = {}): UseCopilotChatReturn {
  const {
    getContextString,
    getFunctionCallHandler,
    copilotApiConfig,
    messages,
    setMessages,
    isLoading,
    setIsLoading,
    chatInstructions,
    actions,

    coagentStates,
    setCoagentStates,
    coagentActions,
    agentSession,
    setAgentSession,
  } = useCopilotContext();

  // We need to ensure that makeSystemMessageCallback always uses the latest
  // useCopilotReadable data.
  const latestGetContextString = useUpdatedRef(getContextString);
  const deleteMessage = useCallback(
    (messageId: string) => {
      setMessages((prev) => prev.filter((message) => message.id !== messageId));
    },
    [setMessages],
  );

  const makeSystemMessageCallback = useCallback(() => {
    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;
    // this always gets the latest context string
    const contextString = latestGetContextString.current([], defaultCopilotContextCategories); // TODO: make the context categories configurable

    return new TextMessage({
      content: systemMessageMaker(contextString, chatInstructions),
      role: Role.System,
    });
  }, [getContextString, makeSystemMessage, chatInstructions]);

  const onCoagentAction = useCallback(
    async (args: CoagentActionHandlerArguments) => {
      const { name, nodeName, state } = args;
      let action = Object.values(coagentActions).find(
        (action) => action.name === name && action.nodeName === nodeName,
      );
      if (!action) {
        action = Object.values(coagentActions).find(
          (action) => action.name === name && !action.nodeName,
        );
      }
      if (action) {
        await action.handler?.({ state, nodeName });
      }
    },
    [coagentActions],
  );

  const { append, reload, stop } = useChat({
    ...options,
    actions: Object.values(actions),
    copilotConfig: copilotApiConfig,
    initialMessages: options.initialMessages || [],
    onFunctionCall: getFunctionCallHandler(),
    onCoagentAction,
    messages,
    setMessages,
    makeSystemMessageCallback,
    isLoading,
    setIsLoading,
    coagentStates,
    setCoagentStates,
    agentSession,
    setAgentSession,
  });

  // this is a workaround born out of a bug that Athena insessently ran into.
  // We could not find the origin of the bug, however, it was clear that an outdated version of the append function was being used somehow --
  // it referecned the old state of the messages array, and not the latest one.
  //
  // We want to make copilotkit as abuse-proof as possible, so we are adding this workaround to ensure that the latest version of the append function is always used.
  //
  // How does this work?
  // we store the relevant function in a ref that is always up-to-date, and then we use that ref in the callback.
  const latestAppend = useUpdatedRef(append);
  const latestAppendFunc = useCallback(
    (message: Message) => {
      return latestAppend.current(message);
    },
    [latestAppend],
  );

  const latestReload = useUpdatedRef(reload);
  const latestReloadFunc = useCallback(() => {
    return latestReload.current();
  }, [latestReload]);

  const latestStop = useUpdatedRef(stop);
  const latestStopFunc = useCallback(() => {
    return latestStop.current();
  }, [latestStop]);

  const latestDelete = useUpdatedRef(deleteMessage);
  const latestDeleteFunc = useCallback(
    (messageId: string) => {
      return latestDelete.current(messageId);
    },
    [latestDelete],
  );

  const latestSetMessages = useUpdatedRef(setMessages);
  const latestSetMessagesFunc = useCallback(
    (messages: Message[]) => {
      return latestSetMessages.current(messages);
    },
    [latestSetMessages],
  );

  return {
    visibleMessages: messages,
    appendMessage: latestAppendFunc,
    setMessages: latestSetMessagesFunc,
    reloadMessages: latestReloadFunc,
    stopGeneration: latestStopFunc,
    deleteMessage: latestDeleteFunc,
    isLoading,
  };
}

// store `value` in a ref and update
// it whenever it changes.
function useUpdatedRef<T>(value: T) {
  const ref = useRef(value);

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref;
}

export function defaultSystemMessage(
  contextString: string,
  additionalInstructions?: string,
): string {
  return (
    `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.

Please assist them as best you can.

You can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.

If you would like to call a function, call it without saying anything else.
` + (additionalInstructions ? `\n\n${additionalInstructions}` : "")
  );
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-copilot-readable.ts
---

/**
 * `useCopilotReadable` is a React hook that provides app-state and other information
 * to the Copilot. Optionally, the hook can also handle hierarchical state within your
 * application, passing these parent-child relationships to the Copilot.
 *
 * ## Usage
 *
 * ### Simple Usage
 *
 * In its most basic usage, useCopilotReadable accepts a single string argument
 * representing any piece of app state, making it available for the Copilot to use
 * as context when responding to user input.
 *
 * ```tsx
 * import { useCopilotReadable } from "@copilotkit/react-core";
 *
 * export function MyComponent() {
 *   const [employees, setEmployees] = useState([]);
 *
 *   useCopilotReadable({
 *     description: "The list of employees",
 *     value: employees,
 *   });
 * }
 * ```
 *
 * ### Nested Components
 *
 * Optionally, you can maintain the hierarchical structure of information by passing
 * `parentId`. This allows you to use `useCopilotReadable` in nested components:
 *
 * ```tsx /employeeContextId/1 {17,23}
 * import { useCopilotReadable } from "@copilotkit/react-core";
 *
 * function Employee(props: EmployeeProps) {
 *   const { employeeName, workProfile, metadata } = props;
 *
 *   // propagate any information to copilot
 *   const employeeContextId = useCopilotReadable({
 *     description: "Employee name",
 *     value: employeeName
 *   });
 *
 *   // Pass a parentID to maintain a hierarchical structure.
 *   // Especially useful with child React components, list elements, etc.
 *   useCopilotReadable({
 *     description: "Work profile",
 *     value: workProfile.description(),
 *     parentId: employeeContextId
 *   });
 *
 *   useCopilotReadable({
 *     description: "Employee metadata",
 *     value: metadata.description(),
 *     parentId: employeeContextId
 *   });
 *
 *   return (
 *     // Render as usual...
 *   );
 * }
 * ```
 */
import { useEffect, useRef } from "react";
import { useCopilotContext } from "../context/copilot-context";

/**
 * Options for the useCopilotReadable hook.
 */
export interface UseCopilotReadableOptions {
  /**
   * The description of the information to be added to the Copilot context.
   */
  description: string;
  /**
   * The value to be added to the Copilot context. Object values are automatically stringified.
   */
  value: any;
  /**
   * The ID of the parent context, if any.
   */
  parentId?: string;
  /**
   * An array of categories to control which context are visible where. Particularly useful
   * with CopilotTextarea (see `useMakeAutosuggestionFunction`)
   */
  categories?: string[];

  /**
   * A custom conversion function to use to serialize the value to a string. If not provided, the value
   * will be serialized using `JSON.stringify`.
   */
  convert?: (description: string, value: any) => string;
}

function convertToJSON(description: string, value: any): string {
  return `${description}: ${typeof value === "string" ? value : JSON.stringify(value)}`;
}

/**
 * Adds the given information to the Copilot context to make it readable by Copilot.
 */
export function useCopilotReadable(
  { description, value, parentId, categories, convert }: UseCopilotReadableOptions,
  dependencies?: any[],
): string | undefined {
  const { addContext, removeContext } = useCopilotContext();
  const idRef = useRef<string>();
  convert = convert || convertToJSON;

  const information = convert(description, value);

  useEffect(() => {
    const id = addContext(information, parentId, categories);
    idRef.current = id;

    return () => {
      removeContext(id);
    };
  }, [information, parentId, addContext, removeContext, ...(dependencies || [])]);

  return idRef.current;
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-flat-category-store.ts
---

import { useCallback, useReducer } from "react";
import { randomId } from "@copilotkit/shared";

export type FlatCategoryStoreId = string;

export interface UseFlatCategoryStoreReturn<T> {
  addElement: (value: T, categories: string[]) => FlatCategoryStoreId;
  removeElement: (id: FlatCategoryStoreId) => void;
  allElements: (categories: string[]) => T[];
}

interface FlatCategoryStoreElement<T> {
  id: FlatCategoryStoreId;
  value: T;
  categories: Set<string>;
}

const useFlatCategoryStore = <T>(): UseFlatCategoryStoreReturn<T> => {
  const [elements, dispatch] = useReducer<
    React.Reducer<Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>, Action<T>>
  >(flatCategoryStoreReducer, new Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>());

  const addElement = useCallback((value: T, categories: string[]): FlatCategoryStoreId => {
    const newId = randomId();
    dispatch({
      type: "ADD_ELEMENT",
      value,
      id: newId,
      categories,
    });
    return newId;
  }, []);

  const removeElement = useCallback((id: FlatCategoryStoreId): void => {
    dispatch({ type: "REMOVE_ELEMENT", id });
  }, []);

  const allElements = useCallback(
    (categories: string[]): T[] => {
      const categoriesSet = new Set(categories);
      const result: T[] = [];
      elements.forEach((element) => {
        if (setsHaveIntersection(categoriesSet, element.categories)) {
          result.push(element.value);
        }
      });
      return result;
    },
    [elements],
  );

  return { addElement, removeElement, allElements };
};

export default useFlatCategoryStore;

// Action types
type Action<T> =
  | {
      type: "ADD_ELEMENT";
      value: T;
      id: FlatCategoryStoreId;
      categories: string[];
    }
  | { type: "REMOVE_ELEMENT"; id: FlatCategoryStoreId };

// Reducer
function flatCategoryStoreReducer<T>(
  state: Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>>,
  action: Action<T>,
): Map<FlatCategoryStoreId, FlatCategoryStoreElement<T>> {
  switch (action.type) {
    case "ADD_ELEMENT": {
      const { value, id, categories } = action;
      const newElement: FlatCategoryStoreElement<T> = {
        id,
        value,
        categories: new Set(categories),
      };
      const newState = new Map(state);
      newState.set(id, newElement);
      return newState;
    }
    case "REMOVE_ELEMENT": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
    default:
      return state;
  }
}

function setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];

  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }

  return false;
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-make-copilot-document-readable.ts
---

import { useEffect, useRef } from "react";
import { useCopilotContext } from "../context/copilot-context";
import { DocumentPointer } from "../types";

/**
 * Makes a document readable by Copilot.
 * @param document The document to make readable.
 * @param categories The categories to associate with the document.
 * @param dependencies The dependencies to use for the effect.
 * @returns The id of the document.
 */
export function useMakeCopilotDocumentReadable(
  document: DocumentPointer,
  categories?: string[],
  dependencies: any[] = [],
): string | undefined {
  const { addDocumentContext, removeDocumentContext } = useCopilotContext();
  const idRef = useRef<string>();

  useEffect(() => {
    const id = addDocumentContext(document, categories);
    idRef.current = id;

    return () => {
      removeDocumentContext(id);
    };
  }, [addDocumentContext, removeDocumentContext, ...dependencies]);

  return idRef.current;
}



---
File: /CopilotKit/packages/react-core/src/hooks/use-tree.ts
---

import { randomId } from "@copilotkit/shared";
import { useCallback, useReducer } from "react";

export type TreeNodeId = string;

export interface TreeNode {
  id: TreeNodeId;
  value: string;
  children: TreeNode[];
  parentId?: TreeNodeId;
  categories: Set<string>;
}

export type Tree = TreeNode[];

export interface UseTreeReturn {
  tree: Tree;
  addElement: (value: string, categories: string[], parentId?: TreeNodeId) => TreeNodeId;
  printTree: (categories: string[]) => string;
  removeElement: (id: TreeNodeId) => void;
}

const findNode = (nodes: Tree, id: TreeNodeId): TreeNode | undefined => {
  for (const node of nodes) {
    if (node.id === id) {
      return node;
    }
    const result = findNode(node.children, id);
    if (result) {
      return result;
    }
  }
  return undefined;
};

const removeNode = (nodes: Tree, id: TreeNodeId): Tree => {
  return nodes.reduce((result: Tree, node) => {
    if (node.id !== id) {
      const newNode = { ...node, children: removeNode(node.children, id) };
      result.push(newNode);
    }
    return result;
  }, []);
};

const addNode = (nodes: Tree, newNode: TreeNode, parentId?: TreeNodeId): Tree => {
  if (!parentId) {
    return [...nodes, newNode];
  }
  return nodes.map((node) => {
    if (node.id === parentId) {
      return { ...node, children: [...node.children, newNode] };
    } else if (node.children.length) {
      return { ...node, children: addNode(node.children, newNode, parentId) };
    }
    return node;
  });
};

const treeIndentationRepresentation = (index: number, indentLevel: number): string => {
  if (indentLevel === 0) {
    return (index + 1).toString();
  } else if (indentLevel === 1) {
    return String.fromCharCode(65 + index); // 65 is the ASCII value for 'A'
  } else if (indentLevel === 2) {
    return String.fromCharCode(97 + index); // 97 is the ASCII value for 'a'
  } else {
    return "-";
  }
};

const printNode = (node: TreeNode, prefix = "", indentLevel = 0): string => {
  const indent = " ".repeat(3).repeat(indentLevel);

  const prefixPlusIndentLength = prefix.length + indent.length;
  const subsequentLinesPrefix = " ".repeat(prefixPlusIndentLength);

  const valueLines = node.value.split("\n");

  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;
  const outputSubsequentLines = valueLines
    .slice(1)
    .map((line) => `${subsequentLinesPrefix}${line}`)
    .join("\n");

  let output = `${outputFirstLine}\n`;
  if (outputSubsequentLines) {
    output += `${outputSubsequentLines}\n`;
  }

  const childPrePrefix = " ".repeat(prefix.length);

  node.children.forEach(
    (child, index) =>
      (output += printNode(
        child,
        `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,
        indentLevel + 1,
      )),
  );
  return output;
};

// Action types
type Action =
  | {
      type: "ADD_NODE";
      value: string;
      parentId?: string;
      id: string;
      categories: string[];
    }
  | { type: "REMOVE_NODE"; id: string };

// Reducer function
function treeReducer(state: Tree, action: Action): Tree {
  switch (action.type) {
    case "ADD_NODE": {
      const { value, parentId, id: newNodeId } = action;
      const newNode: TreeNode = {
        id: newNodeId,
        value,
        children: [],
        categories: new Set(action.categories),
      };

      try {
        return addNode(state, newNode, parentId);
      } catch (error) {
        console.error(`Error while adding node with id ${newNodeId}: ${error}`);
        return state;
      }
    }
    case "REMOVE_NODE":
      return removeNode(state, action.id);
    default:
      return state;
  }
}

// useTree hook
const useTree = (): UseTreeReturn => {
  const [tree, dispatch] = useReducer(treeReducer, []);

  const addElement = useCallback(
    (value: string, categories: string[], parentId?: string): TreeNodeId => {
      const newNodeId = randomId(); // Generate new ID outside of dispatch
      dispatch({
        type: "ADD_NODE",
        value,
        parentId,
        id: newNodeId,
        categories: categories,
      });
      return newNodeId; // Return the new ID
    },
    [],
  );

  const removeElement = useCallback((id: TreeNodeId): void => {
    dispatch({ type: "REMOVE_NODE", id });
  }, []);

  const printTree = useCallback(
    (categories: string[]): string => {
      const categoriesSet = new Set(categories);

      let output = "";
      tree.forEach((node, index) => {
        // if the node does not have any of the desired categories, continue to the next node
        if (!setsHaveIntersection(categoriesSet, node.categories)) {
          return;
        }

        // add a new line before each node except the first one
        if (index !== 0) {
          output += "\n";
        }

        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);
      });
      return output;
    },
    [tree],
  );

  return { tree, addElement, printTree, removeElement };
};

export default useTree;

function setsHaveIntersection<T>(setA: Set<T>, setB: Set<T>): boolean {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];

  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }

  return false;
}



---
File: /CopilotKit/packages/react-core/src/lib/copilot-task.ts
---

/**
 * This class is used to execute one-off tasks, for example on button press. It can use the context available via [useCopilotReadable](/reference/hooks/useCopilotReadable) and the actions provided by [useCopilotAction](/reference/hooks/useCopilotAction), or you can provide your own context and actions.
 *
 * ## Example
 * In the simplest case, use CopilotTask in the context of your app by giving it instructions on what to do.
 *
 * ```tsx
 * import { CopilotTask, useCopilotContext } from "@copilotkit/react-core";
 *
 * export function MyComponent() {
 *   const context = useCopilotContext();
 *
 *   const task = new CopilotTask({
 *     instructions: "Set a random message",
 *     actions: [
 *       {
 *         name: "setMessage",
 *       description: "Set the message.",
 *       argumentAnnotations: [
 *         {
 *           name: "message",
 *           type: "string",
 *           description:
 *             "A message to display.",
 *           required: true,
 *         },
 *       ],
 *
 *       implementation: async (message) => {
 *         // ...
 *       },
 *     }
 *     ]
 *   });
 *
 *   const executeTask = async () => {
 *     await task.run(context, action);
 *   }
 *
 *   return (
 *     <>
 *       <button onClick={executeTask}>
 *         Execute task
 *       </button>
 *     </>
 *   )
 * }
 * ```
 *
 * Have a look at the [Presentation Example App](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/examples/next-openai/src/app/presentation/page.tsx) for a more complete example.
 */

import {
  ActionExecutionMessage,
  CopilotRuntimeClient,
  Message,
  Role,
  TextMessage,
  convertGqlOutputToMessages,
  convertMessagesToGqlInput,
  filterAgentStateMessages,
  CopilotRequestType,
} from "@copilotkit/runtime-client-gql";
import { FrontendAction } from "../types/frontend-action";
import { CopilotContextParams } from "../context";
import { defaultCopilotContextCategories } from "../components";
import { MessageStatusCode } from "@copilotkit/runtime-client-gql";
import { actionParametersToJsonSchema } from "@copilotkit/shared";

export interface CopilotTaskConfig {
  /**
   * The instructions to be given to the assistant.
   */
  instructions: string;
  /**
   * An array of action definitions that can be called.
   */
  actions?: FrontendAction<any>[];
  /**
   * Whether to include the copilot readable context in the task.
   */
  includeCopilotReadable?: boolean;

  /**
   * Whether to include actions defined via useCopilotAction in the task.
   */
  includeCopilotActions?: boolean;
}

export class CopilotTask<T = any> {
  private instructions: string;
  private actions: FrontendAction<any>[];
  private includeCopilotReadable: boolean;
  private includeCopilotActions: boolean;

  constructor(config: CopilotTaskConfig) {
    this.instructions = config.instructions;
    this.actions = config.actions || [];
    this.includeCopilotReadable = config.includeCopilotReadable !== false;
    this.includeCopilotActions = config.includeCopilotActions !== false;
  }

  /**
   * Run the task.
   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.
   * @param data The data to use for the task.
   */
  async run(context: CopilotContextParams, data?: T): Promise<void> {
    const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};

    // merge functions into entry points
    for (const fn of this.actions) {
      actions[fn.name] = fn;
    }

    let contextString = "";

    if (data) {
      contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
    }

    if (this.includeCopilotReadable) {
      contextString += context.getContextString([], defaultCopilotContextCategories);
    }

    const systemMessage = new TextMessage({
      content: taskSystemMessage(contextString, this.instructions),
      role: Role.System,
    });

    const messages: Message[] = [systemMessage];

    const runtimeClient = new CopilotRuntimeClient({
      url: context.copilotApiConfig.chatApiEndpoint,
      publicApiKey: context.copilotApiConfig.publicApiKey,
      headers: context.copilotApiConfig.headers,
      credentials: context.copilotApiConfig.credentials,
    });

    const response = await runtimeClient
      .generateCopilotResponse({
        data: {
          frontend: {
            actions: Object.values(actions).map((action) => ({
              name: action.name,
              description: action.description || "",
              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),
            })),
            url: window.location.href,
          },
          messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),
          metadata: {
            requestType: CopilotRequestType.Task,
          },
          forwardedParameters: {
            toolChoice: "required",
          },
        },
        properties: context.copilotApiConfig.properties,
      })
      .toPromise();

    const functionCallHandler = context.getFunctionCallHandler(actions);
    const functionCalls = convertGqlOutputToMessages(
      response.data?.generateCopilotResponse?.messages || [],
    ).filter((m): m is ActionExecutionMessage => m instanceof ActionExecutionMessage);

    for (const functionCall of functionCalls) {
      await functionCallHandler({
        messages,
        name: functionCall.name,
        args: functionCall.arguments,
      });
    }
  }
}

function taskSystemMessage(contextString: string, instructions: string): string {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call a function without saying anything else.

The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`
`;
}



---
File: /CopilotKit/packages/react-core/src/lib/index.ts
---

export * from "./copilot-task";



---
File: /CopilotKit/packages/react-core/src/types/chat-suggestion-configuration.ts
---

export interface CopilotChatSuggestionConfiguration {
  /**
   * A prompt or instructions for the GPT to generate suggestions.
   */
  instructions: string;

  /**
   * The minimum number of suggestions to generate. Defaults to `1`.
   * @default 1
   */
  minSuggestions?: number;

  /**
   * The maximum number of suggestions to generate. Defaults to `3`.
   * @default 1
   */
  maxSuggestions?: number;

  /**
   * An optional class name to apply to the suggestions.
   */
  className?: string;
}



---
File: /CopilotKit/packages/react-core/src/types/coagent-action.ts
---

export type CoagentActionRenderProps<T> = {
  state: T;
  nodeName: string;
  status: "inProgress" | "complete";
};

export type CoagentActionHandlerArguments<T> = {
  nodeName: string;
  state: T;
};

export type CoagentAction<T = any> = {
  name: string;
  nodeName?: string;
  handler?: (props: CoagentActionHandlerArguments<T>) => void | Promise<void>;
  render?: ((props: CoagentActionRenderProps<T>) => string | React.ReactElement) | string;
};



---
File: /CopilotKit/packages/react-core/src/types/coagent-state.ts
---

export interface CoagentState {
  name: string;
  state: any;
  running: boolean;
  active: boolean;
  threadId?: string;
  nodeName?: string;
  runId?: string;
}



---
File: /CopilotKit/packages/react-core/src/types/document-pointer.ts
---

export interface DocumentPointer {
  id: string;
  name: string;
  sourceApplication: string;
  iconImageUri: string;
  getContents: () => string;
}



---
File: /CopilotKit/packages/react-core/src/types/frontend-action.ts
---

import { Action, Parameter, MappedParameterTypes } from "@copilotkit/shared";
import React from "react";

interface InProgressState<T extends Parameter[] | [] = []> {
  status: "inProgress";
  args: Partial<MappedParameterTypes<T>>;
  result: undefined;
}

interface ExecutingState<T extends Parameter[] | [] = []> {
  status: "executing";
  args: MappedParameterTypes<T>;
  result: undefined;
}

interface CompleteState<T extends Parameter[] | [] = []> {
  status: "complete";
  args: MappedParameterTypes<T>;
  result: any;
}

interface InProgressStateNoArgs<T extends Parameter[] | [] = []> {
  status: "inProgress";
  args: Partial<MappedParameterTypes<T>>;
  result: undefined;
}

interface ExecutingStateNoArgs<T extends Parameter[] | [] = []> {
  status: "executing";
  args: MappedParameterTypes<T>;
  result: undefined;
}

interface CompleteStateNoArgs<T extends Parameter[] | [] = []> {
  status: "complete";
  args: MappedParameterTypes<T>;
  result: any;
}

interface InProgressStateWait<T extends Parameter[] | [] = []> {
  status: "inProgress";
  args: Partial<MappedParameterTypes<T>>;
  handler: undefined;
  result: undefined;
}

interface ExecutingStateWait<T extends Parameter[] | [] = []> {
  status: "executing";
  args: MappedParameterTypes<T>;
  handler: (result: any) => void;
  result: undefined;
}

interface CompleteStateWait<T extends Parameter[] | [] = []> {
  status: "complete";
  args: MappedParameterTypes<T>;
  handler: undefined;
  result: any;
}

interface InProgressStateNoArgsWait<T extends Parameter[] | [] = []> {
  status: "inProgress";
  args: Partial<MappedParameterTypes<T>>;
  handler: undefined;
  result: undefined;
}

interface ExecutingStateNoArgsWait<T extends Parameter[] | [] = []> {
  status: "executing";
  args: MappedParameterTypes<T>;
  handler: (result: any) => void;
  result: undefined;
}

interface CompleteStateNoArgsWait<T extends Parameter[] | [] = []> {
  status: "complete";
  args: MappedParameterTypes<T>;
  handler: undefined;
  result: any;
}

export type ActionRenderProps<T extends Parameter[] | [] = []> =
  | CompleteState<T>
  | ExecutingState<T>
  | InProgressState<T>;

export type ActionRenderPropsNoArgs<T extends Parameter[] | [] = []> =
  | CompleteStateNoArgs<T>
  | ExecutingStateNoArgs<T>
  | InProgressStateNoArgs<T>;

export type ActionRenderPropsWait<T extends Parameter[] | [] = []> =
  | CompleteStateWait<T>
  | ExecutingStateWait<T>
  | InProgressStateWait<T>;

export type ActionRenderPropsNoArgsWait<T extends Parameter[] | [] = []> =
  | CompleteStateNoArgsWait<T>
  | ExecutingStateNoArgsWait<T>
  | InProgressStateNoArgsWait<T>;

export type FrontendAction<T extends Parameter[] | [] = []> = Action<T> & {
  disabled?: boolean;
} & (
    | {
        render?:
          | string
          | (T extends []
              ? (props: ActionRenderPropsNoArgs<T>) => string | React.ReactElement
              : (props: ActionRenderProps<T>) => string | React.ReactElement);
        renderAndWait?: never;
      }
    | {
        render?: never;
        renderAndWait: T extends []
          ? (props: ActionRenderPropsNoArgsWait<T>) => React.ReactElement
          : (props: ActionRenderPropsWait<T>) => React.ReactElement;
        handler?: never;
      }
  );

export type RenderFunctionStatus = ActionRenderProps<any>["status"];



---
File: /CopilotKit/packages/react-core/src/types/index.ts
---

export type { DocumentPointer } from "./document-pointer";
export type { SystemMessageFunction } from "./system-message";
export type { ActionRenderProps, RenderFunctionStatus } from "./frontend-action";
export type { CopilotChatSuggestionConfiguration } from "./chat-suggestion-configuration";



---
File: /CopilotKit/packages/react-core/src/types/system-message.ts
---

export type SystemMessageFunction = (
  contextString: string,
  additionalInstructions?: string,
) => string;



---
File: /CopilotKit/packages/react-core/src/utils/extract.ts
---

import {
  Action,
  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,
  MappedParameterTypes,
  Parameter,
  actionParametersToJsonSchema,
} from "@copilotkit/shared";
import {
  ActionExecutionMessage,
  Message,
  Role,
  TextMessage,
  convertGqlOutputToMessages,
  CopilotRequestType,
} from "@copilotkit/runtime-client-gql";
import { CopilotContextParams } from "../context";
import { defaultCopilotContextCategories } from "../components";
import { CopilotRuntimeClient } from "@copilotkit/runtime-client-gql";
import {
  convertMessagesToGqlInput,
  filterAgentStateMessages,
} from "@copilotkit/runtime-client-gql";

interface InitialState<T extends Parameter[] | [] = []> {
  status: "initial";
  args: Partial<MappedParameterTypes<T>>;
}

interface InProgressState<T extends Parameter[] | [] = []> {
  status: "inProgress";
  args: Partial<MappedParameterTypes<T>>;
}

interface CompleteState<T extends Parameter[] | [] = []> {
  status: "complete";
  args: MappedParameterTypes<T>;
}

type StreamHandlerArgs<T extends Parameter[] | [] = []> =
  | InitialState<T>
  | InProgressState<T>
  | CompleteState<T>;

interface ExtractOptions<T extends Parameter[]> {
  context: CopilotContextParams;
  instructions: string;
  parameters: T;
  include?: IncludeOptions;
  data?: any;
  abortSignal?: AbortSignal;
  stream?: (args: StreamHandlerArgs<T>) => void;
  requestType?: CopilotRequestType;
}

interface IncludeOptions {
  readable?: boolean;
  messages?: boolean;
}

export async function extract<const T extends Parameter[]>({
  context,
  instructions,
  parameters,
  include,
  data,
  abortSignal,
  stream,
  requestType = CopilotRequestType.Task,
}: ExtractOptions<T>): Promise<MappedParameterTypes<T>> {
  const { messages } = context;

  const action: Action<any> = {
    name: "extract",
    parameters,
    handler: (args: any) => {},
  };

  const includeReadable = include?.readable ?? false;
  const includeMessages = include?.messages ?? false;

  let contextString = "";

  if (data) {
    contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
  }

  if (includeReadable) {
    contextString += context.getContextString([], defaultCopilotContextCategories);
  }

  const systemMessage: Message = new TextMessage({
    content: makeSystemMessage(contextString, instructions),
    role: Role.System,
  });

  const headers = {
    ...(context.copilotApiConfig.headers || {}),
    ...(context.copilotApiConfig.publicApiKey
      ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: context.copilotApiConfig.publicApiKey }
      : {}),
  };

  const runtimeClient = new CopilotRuntimeClient({
    url: context.copilotApiConfig.chatApiEndpoint,
    publicApiKey: context.copilotApiConfig.publicApiKey,
    headers,
    credentials: context.copilotApiConfig.credentials,
  });

  const response = CopilotRuntimeClient.asStream(
    runtimeClient.generateCopilotResponse({
      data: {
        frontend: {
          actions: [
            {
              name: action.name,
              description: action.description || "",
              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),
            },
          ],
          url: window.location.href,
        },

        messages: convertMessagesToGqlInput(
          includeMessages
            ? [systemMessage, ...filterAgentStateMessages(messages)]
            : [systemMessage],
        ),
        metadata: {
          requestType: requestType,
        },
        forwardedParameters: {
          toolChoice: "function",
          toolChoiceFunctionName: action.name,
        },
      },
      properties: context.copilotApiConfig.properties,
      signal: abortSignal,
    }),
  );

  const reader = response.getReader();

  let isInitial = true;

  let actionExecutionMessage: ActionExecutionMessage | undefined = undefined;

  while (true) {
    const { done, value } = await reader.read();

    if (done) {
      break;
    }

    if (abortSignal?.aborted) {
      throw new Error("Aborted");
    }

    actionExecutionMessage = convertGqlOutputToMessages(
      value.generateCopilotResponse.messages,
    ).find((msg) => msg instanceof ActionExecutionMessage) as ActionExecutionMessage | undefined;

    if (!actionExecutionMessage) {
      continue;
    }

    stream?.({
      status: isInitial ? "initial" : "inProgress",
      args: actionExecutionMessage.arguments as Partial<MappedParameterTypes<T>>,
    });

    isInitial = false;
  }

  if (!actionExecutionMessage) {
    throw new Error("extract() failed: No function call occurred");
  }

  stream?.({
    status: "complete",
    args: actionExecutionMessage.arguments as MappedParameterTypes<T>,
  });

  return actionExecutionMessage.arguments as MappedParameterTypes<T>;
}

function makeSystemMessage(contextString: string, instructions: string): string {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with a function called extract you MUST call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call the function without saying anything else.

The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`

Any additional messages provided are for providing context only and should not be used to ask questions or engage in conversation.
`;
}



---
File: /CopilotKit/packages/react-core/src/utils/index.ts
---

export { extract } from "./extract";



---
File: /CopilotKit/packages/react-core/src/utils/utils.test.ts
---

import * as utils from "./utils";

describe("emptyTest", () => {
  it("should be truthy", () => {
    expect(true).toBeTruthy();
  });
});



---
File: /CopilotKit/packages/react-core/src/utils/utils.ts
---

export {};



---
File: /CopilotKit/packages/react-core/src/index.tsx
---

"use client";
export * from "./components";
export * from "./context";
export * from "./hooks";
export * from "./types";
export * from "./lib";
export * from "./utils";



---
File: /CopilotKit/packages/react-core/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/react-core/tsup.config.ts
---

import { defineConfig, Options } from "tsup";

export default defineConfig((options: Options) => ({
  entry: ["src/**/*.{ts,tsx}"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: ["react"],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
  ...options,
}));



---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/base-copilot-textarea.css
---

.copilot-textarea.with-branding::after {
    content: ''; /* Initially empty because we overrdie this CSS dynamically and we want to avoid flashing */
    position: absolute;
}
    
  
.copilot-textarea.no-branding::after {
    content: '';
}


---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/base-copilot-textarea.tsx
---

import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Descendant, Editor } from "slate";
import { Editable, Slate } from "slate-react";
import { twMerge } from "tailwind-merge";
import { useAutosuggestions } from "../../hooks/base-copilot-textarea-implementation/use-autosuggestions";
import { useCopilotTextareaEditor } from "../../hooks/base-copilot-textarea-implementation/use-copilot-textarea-editor";
import { usePopulateCopilotTextareaRef } from "../../hooks/base-copilot-textarea-implementation/use-populate-copilot-textarea-ref";
import {
  getFullEditorTextWithNewlines,
  getTextAroundCollapsedCursor,
} from "../../lib/get-text-around-cursor";
import { addAutocompletionsToEditor } from "../../lib/slatejs-edits/add-autocompletions";
import { clearAutocompletionsFromEditor } from "../../lib/slatejs-edits/clear-autocompletions";
import { replaceEditorText } from "../../lib/slatejs-edits/replace-text";
import { BaseAutosuggestionsConfig, defaultBaseAutosuggestionsConfig } from "../../types/base";
import { AutosuggestionState } from "../../types/base/autosuggestion-state";
import { BaseCopilotTextareaProps } from "../../types/base/base-copilot-textarea-props";
import "./base-copilot-textarea.css";
import { HoveringToolbar } from "../hovering-toolbar/hovering-toolbar";
import { makeRenderElementFunction } from "./render-element";
import { makeRenderPlaceholderFunction } from "./render-placeholder";
import { useAddBrandingCss } from "./use-add-branding-css";
import {
  HoveringEditorProvider,
  useHoveringEditorContext,
} from "../hovering-toolbar/hovering-editor-provider";
import { TrackerTextEditedSinceLastCursorMovement } from "./track-cursor-moved-since-last-text-change";

/**
 * Purpose: to be used as the `ref` type for `CopilotTextarea` and `BaseCopilotTextarea`.
 *
 * This interface extends `HTMLElement`, and is the subset of `HTMLTextAreaElement` that "actually matters".
 * It provides the core functionality that consumers of `HTMLTextAreaElement` need 99.9% of the time:
 * - `value`: the current value of the textarea
 * - `focus`: make the textarea focused
 * - `blur`: make the textarea unfocused
 */
export interface HTMLCopilotTextAreaElement extends HTMLElement {
  /**
   * The current value of the textarea.
   */
  value: string;

  /**
   * focus on the textarea
   */
  focus: () => void;

  /**
   * unfocus the textarea.
   *
   * Called `blur` for syntactic compatibility with `HTMLTextAreaElement`.
   */
  blur: () => void;
}

/**
 * Not intended for direct use. Use CopilotTextarea instead.
 *
 * The `BaseCopilotTextarea` includes the basic UX component,
 * without the business logic / AI logic that makes the content useful and coherent.
 *
 * It is useful if you want to build your own backend, with fully custom business logic
 * for figuring out which contnet to fill in.
 */
export const BaseCopilotTextarea = React.forwardRef(
  (props: BaseCopilotTextareaProps, ref: React.Ref<HTMLCopilotTextAreaElement>) => {
    return (
      <HoveringEditorProvider>
        <BaseCopilotTextareaWithHoveringContext {...props} ref={ref} />
      </HoveringEditorProvider>
    );
  },
);

/**
 * Not intended for direct use. Use `CopilotTextarea` instead.
 *
 * This is the private core of the `BaseCopilotTextarea` component.
 * For practical purposes the implementation is cleaner assuming containment in a `HoveringEditorProviderContext`.
 *
 * Therefore we separate the core logic into this component,
 * and wrap it in a `HoveringEditorProviderContext` in `BaseCopilotTextarea`.
 */
const BaseCopilotTextareaWithHoveringContext = React.forwardRef(
  (props: BaseCopilotTextareaProps, ref: React.Ref<HTMLCopilotTextAreaElement>) => {
    const autosuggestionsConfig: BaseAutosuggestionsConfig = {
      ...defaultBaseAutosuggestionsConfig,
      ...props.baseAutosuggestionsConfig,
    };

    const valueOnInitialRender = useMemo(() => props.value ?? "", []);
    const [lastKnownFullEditorText, setLastKnownFullEditorText] = useState(valueOnInitialRender);
    const [cursorMovedSinceLastTextChange, setCursorMovedSinceLastTextChange] = useState(false);

    // // When the editor text changes, we want to reset the `textEditedSinceLastCursorMovement` state.
    // useEffect(() => {
    //   setCursorMovedSinceLastTextChange(false);
    // }, [lastKnownFullEditorText]);

    const initialValue: Descendant[] = useMemo(() => {
      return [
        {
          type: "paragraph",
          children: [{ text: valueOnInitialRender }],
        },
      ];
    }, [valueOnInitialRender]);

    const editor = useCopilotTextareaEditor();

    const { isDisplayed: hoveringEditorIsDisplayed, setIsDisplayed: setHoveringEditorIsDisplayed } =
      useHoveringEditorContext();

    const insertText = useCallback(
      (autosuggestion: AutosuggestionState) => {
        Editor.insertText(editor, autosuggestion.text, {
          at: autosuggestion.point,
        });
      },
      [editor],
    );

    const shouldDisableAutosuggestions =
      // textarea is manually disabled:
      autosuggestionsConfig.disabled ||
      // hovering editor is displayed:
      hoveringEditorIsDisplayed ||
      // the cursor has moved since the last text change AND we are configured to disable autosuggestions in this case:
      (cursorMovedSinceLastTextChange &&
        autosuggestionsConfig.temporarilyDisableWhenMovingCursorWithoutChangingText);

    const {
      currentAutocompleteSuggestion,
      onChangeHandler: onChangeHandlerForAutocomplete,
      onKeyDownHandler: onKeyDownHandlerForAutocomplete,
      onTouchStartHandler: onTouchStartHandlerForAutocomplete,
    } = useAutosuggestions(
      autosuggestionsConfig.debounceTime,
      autosuggestionsConfig.shouldAcceptAutosuggestionOnKeyPress,
      autosuggestionsConfig.shouldAcceptAutosuggestionOnTouch,
      autosuggestionsConfig.apiConfig.autosuggestionsFunction,
      insertText,
      autosuggestionsConfig.disableWhenEmpty,
      shouldDisableAutosuggestions,
    );

    const onKeyDownHandlerForHoveringEditor = useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (
          autosuggestionsConfig.shouldToggleHoveringEditorOnKeyPress(event, props.shortcut ?? "k")
        ) {
          event.preventDefault();
          setHoveringEditorIsDisplayed(!hoveringEditorIsDisplayed);
        }
      },
      [
        hoveringEditorIsDisplayed,
        setHoveringEditorIsDisplayed,
        autosuggestionsConfig.shouldToggleHoveringEditorOnKeyPress,
      ],
    );

    // sync autosuggestions state with the editor
    useEffect(() => {
      clearAutocompletionsFromEditor(editor);
      if (currentAutocompleteSuggestion) {
        addAutocompletionsToEditor(
          editor,
          currentAutocompleteSuggestion.text,
          currentAutocompleteSuggestion.point,
        );
      }
    }, [currentAutocompleteSuggestion]);

    const suggestionStyleAugmented: React.CSSProperties = useMemo(() => {
      return {
        fontStyle: "italic",
        color: "gray",
        ...props.suggestionsStyle,
      };
    }, [props.suggestionsStyle]);

    const renderElementMemoized = useMemo(() => {
      return makeRenderElementFunction(suggestionStyleAugmented);
    }, [suggestionStyleAugmented]);

    const renderPlaceholderMemoized = useMemo(() => {
      // For some reason slateJS specifies a top value of 0, which makes for strange styling. We override this here.
      const placeholderStyleSlatejsOverrides: React.CSSProperties = {
        top: undefined,
      };

      const placeholderStyleAugmented: React.CSSProperties = {
        ...placeholderStyleSlatejsOverrides,
        ...props.placeholderStyle,
      };

      return makeRenderPlaceholderFunction(placeholderStyleAugmented);
    }, [props.placeholderStyle]);

    // update the editor text, but only when the value changes from outside the component
    useEffect(() => {
      if (props.value === lastKnownFullEditorText) {
        return;
      }

      setLastKnownFullEditorText(props.value ?? "");
      replaceEditorText(editor, props.value ?? "");
    }, [props.value]);

    // separate into TextareaHTMLAttributes<HTMLDivElement> and CopilotTextareaProps
    const {
      placeholderStyle,
      value,
      hoverMenuClassname,
      onValueChange,
      baseAutosuggestionsConfig: autosuggestionsConfigFromProps,
      className,
      onChange,
      onKeyDown,
      disableBranding,
      ...propsToForward
    } = props;

    useAddBrandingCss(suggestionStyleAugmented, disableBranding);
    usePopulateCopilotTextareaRef(editor, ref);

    const moddedClassName = (() => {
      const baseClassName = "copilot-textarea";
      const brandingClass = disableBranding ? "no-branding" : "with-branding";
      const defaultTailwindClassName = "bg-white overflow-y-auto resize-y";
      const mergedClassName = twMerge(defaultTailwindClassName, className ?? "");
      return `${baseClassName} ${brandingClass} ${mergedClassName}`;
    })();

    return (
      <Slate
        editor={editor}
        initialValue={initialValue}
        onChange={(value) => {
          const newEditorState = getTextAroundCollapsedCursor(editor);

          const fullEditorText = newEditorState
            ? newEditorState.textBeforeCursor + newEditorState.textAfterCursor
            : getFullEditorTextWithNewlines(editor); // we don't double-parse the editor. When `newEditorState` is null, we didn't parse the editor yet.

          setLastKnownFullEditorText((prev) => {
            if (prev !== fullEditorText) {
              setCursorMovedSinceLastTextChange(false);
            }
            return fullEditorText;
          });
          onChangeHandlerForAutocomplete(newEditorState);

          props.onValueChange?.(fullEditorText);
          props.onChange?.(makeSemiFakeReactTextAreaEvent(fullEditorText));
        }}
      >
        <TrackerTextEditedSinceLastCursorMovement
          setCursorMovedSinceLastTextChange={setCursorMovedSinceLastTextChange}
        />
        <HoveringToolbar
          apiConfig={autosuggestionsConfig.apiConfig}
          contextCategories={autosuggestionsConfig.contextCategories}
          hoverMenuClassname={hoverMenuClassname}
        />
        <Editable
          renderElement={renderElementMemoized}
          renderPlaceholder={renderPlaceholderMemoized}
          onKeyDown={(event) => {
            onKeyDownHandlerForHoveringEditor(event); // forward the event for internal use
            onKeyDownHandlerForAutocomplete(event); // forward the event for internal use
            props.onKeyDown?.(event); // forward the event for external use
          }}
          onTouchStart={(event) => {
            onTouchStartHandlerForAutocomplete(event); // forward the event for internal use
          }}
          className={moddedClassName}
          onBlur={(ev) => {
            // clear autocompletion on blur
            props.onBlur?.(ev);
            clearAutocompletionsFromEditor(editor);
          }}
          {...propsToForward}
        />
      </Slate>
    );
  },
);

// Consumers of <textarea> expect a `onChange: (React.ChangeEvent<HTMLTextAreaElement>) => void` event handler to be passed in.
// This is *extremely* common, and we want to support it.
//
// We can't support the full functionality, but in 99% of cases, the consumer only cares about the `event.target.value` property --
// that's how they get the new value of the textarea.
//
// So, the tradeoff we are making is minimizing compiler complaint, with a small chance of runtime error.
// The alternative would be defining a different onChange entrypoint (we actually do have that in `onValueChange`),
// And starting to explain subtleties to users the moment they try to use the component for the first time for very basic functionality.
//
// If this proves problematic, we can always revisit this decision.
function makeSemiFakeReactTextAreaEvent(
  currentText: string,
): React.ChangeEvent<HTMLTextAreaElement> {
  return {
    target: {
      value: currentText,
      type: "copilot-textarea",
    },
    currentTarget: {
      value: currentText,
      type: "copilot-textarea",
    },
  } as React.ChangeEvent<HTMLTextAreaElement>;
}



---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/render-element.tsx
---

import { RenderElementProps } from "slate-react";

export type RenderElementFunction = (props: RenderElementProps) => JSX.Element;

export function makeRenderElementFunction(
  suggestionsStyle: React.CSSProperties,
): RenderElementFunction {
  return (props: RenderElementProps) => {
    switch (props.element.type) {
      case "paragraph":
        return <DefaultElement {...props} />;
      case "suggestion":
        return <SuggestionElement {...props} suggestionsStyle={suggestionsStyle} />;
    }
  };
}

const DefaultElement = (props: RenderElementProps) => {
  return <div {...props.attributes}>{props.children}</div>;
};
const SuggestionElement = (
  props: RenderElementProps & {
    suggestionsStyle: React.CSSProperties;
  },
) => {
  return (
    <span
      {...props.attributes}
      style={{
        ...props.suggestionsStyle,
      }}
      contentEditable={false}
    >
      {props.children /* https://github.com/ianstormtaylor/slate/issues/3930 */}
      {props.element.type === "suggestion" && props.element.content}
    </span>
  );
};



---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/render-placeholder.tsx
---

import { RenderPlaceholderProps } from "slate-react";

export type RenderPlaceholderFunction = (props: RenderPlaceholderProps) => JSX.Element;

export function makeRenderPlaceholderFunction(
  placeholderStyle?: React.CSSProperties,
): RenderPlaceholderFunction {
  return (props: RenderPlaceholderProps) => {
    const { style, ...restAttributes } = props.attributes;

    return (
      <div
        {...restAttributes}
        style={{
          ...style,
          ...placeholderStyle,
        }}
      >
        {props.children}
      </div>
    );
  };
}



---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/track-cursor-moved-since-last-text-change.tsx
---

import { useEffect, useRef } from "react";
import { BaseSelection } from "slate";
import { useSlateSelector } from "slate-react";
import { Range } from "slate";
import { editorToText } from "../../lib/editor-to-text";

interface TrackerTextEditedSinceLastCursorMovementProps {
  setCursorMovedSinceLastTextChange: (value: boolean) => void;
}
export function TrackerTextEditedSinceLastCursorMovement(
  props: TrackerTextEditedSinceLastCursorMovementProps,
) {
  const cursorState: RelevantEditorState = useSlateSelector((state) => ({
    selection: state.selection,
    text: editorToText(state),
  }));

  const previousState = usePrevious(cursorState);

  useEffect(() => {
    if (!previousState) {
      return;
    }

    if (cursorChangedWithoutTextChanged(previousState, cursorState)) {
      props.setCursorMovedSinceLastTextChange(true);
    }
  }, [props.setCursorMovedSinceLastTextChange, cursorState]);

  return <></>;
}

type RelevantEditorState = {
  selection: BaseSelection;
  text: string;
};

const cursorChangedWithoutTextChanged = (
  prev: RelevantEditorState,
  next: RelevantEditorState,
): boolean => {
  // Check if the selection has changed
  const isSelectionChanged = !isSelectionEqual(prev.selection, next.selection);

  // Check if the text content remains the same
  const isTextSame = prev.text === next.text;

  return isSelectionChanged && isTextSame;
};

const isSelectionEqual = (a: BaseSelection, b: BaseSelection) => {
  if (!a && !b) return true;
  if (!a || !b) return false;
  return Range.equals(a, b);
};

/**
 * Easily keep track of the *previous* value of a variable.
 *
 * Example:
 * ```
 * const [count, setCount] = useState(0);
 * const prevCount = usePrevious(count);
 *
 * useEffect(() => {
 *  if (count > prevCount) {
 *   console.log('Now I know that count is bigger than before');
 * }
 * }, [count, prevCount]);
 * ```
 */
function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  });

  return ref.current;
}



---
File: /CopilotKit/packages/react-textarea/src/components/base-copilot-textarea/use-add-branding-css.tsx
---

import { useEffect } from "react";

export function useAddBrandingCss(
  suggestionStyleAugmented: React.CSSProperties,
  disableBranding: boolean | undefined,
) {
  const cssSelector = ".copilot-textarea.with-branding";
  useEffect(() => {
    if (disableBranding) {
      return;
    }

    // ---
    // 1: Add the CSS to the DOM
    const styleEl = document.createElement("style");
    styleEl.id = "dynamic-styles";

    // Build the CSS string dynamically
    let dynamicStyles = Object.entries(suggestionStyleAugmented)
      .map(([key, value]) => {
        const kebabCaseKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
        return `${kebabCaseKey}: ${value};`;
      })
      .join(" ");

    // Append overrides for italics and font-size
    dynamicStyles += `font-style: normal; font-size: x-small;`;
    dynamicStyles += `content: "CopilotKit";`;
    dynamicStyles += `bottom: 6px;`;
    dynamicStyles += `right: 6px;`;
    dynamicStyles += `pointer-events: none;`;
    dynamicStyles += `font-weight: 200;`;
    dynamicStyles += `padding: 0;`;
    dynamicStyles += `margin: 0;`;
    dynamicStyles += `border: 0;`;
    dynamicStyles += `line-height: 1;`;
    dynamicStyles += `position: absolute;`;

    // Append it to the ::after class
    styleEl.innerHTML = `
      ${cssSelector}::after {
        ${dynamicStyles}
      }
    `;

    document.head.appendChild(styleEl);

    // ---
    // 2: Add the scroll listener (to keep the branding in the bottom right as the textarea scrolls)
    const textarea = document.querySelector(cssSelector);
    const handleScroll = () => {
      const styleEl = document.getElementById("dynamic-styles");
      if (styleEl && textarea) {
        const offsetFromBottom = -textarea.scrollTop + 6;
        const offsetFromRight = -textarea.scrollLeft + 6;
        styleEl.innerHTML = `
          ${cssSelector}::after {
            ${dynamicStyles}
            bottom: ${offsetFromBottom}px;
            right: ${offsetFromRight}px;
          }
        `;
      }
    };

    textarea?.addEventListener("scroll", handleScroll);

    // Cleanup
    return () => {
      document.getElementById("dynamic-styles")?.remove();
      textarea?.removeEventListener("scroll", handleScroll);
    };
  }, [disableBranding, suggestionStyleAugmented]);
}



---
File: /CopilotKit/packages/react-textarea/src/components/copilot-textarea/copilot-textarea.tsx
---

/**
 * <br/>
 * <img src="/images/CopilotTextarea.gif" width="500" />
 *
 * `<CopilotTextarea>` is a React component that acts as a drop-in replacement for the standard `<textarea>`,
 *  offering enhanced autocomplete features powered by AI. It is context-aware, integrating seamlessly with the
 * [`useCopilotReadable`](/reference/hooks/useCopilotReadable) hook to provide intelligent suggestions based on the application context.
 *
 * In addition, it provides a hovering editor window (available by default via `Cmd + K` on Mac and `Ctrl + K` on Windows) that allows the user to
 * suggest changes to the text, for example providing a summary or rephrasing the text.
 *
 * ## Example
 *
 * ```tsx
 * import { CopilotTextarea } from '@copilotkit/react-textarea';
 * import "@copilotkit/react-textarea/styles.css";
 *
 * <CopilotTextarea
 *   autosuggestionsConfig={{
 *     textareaPurpose:
 *      "the body of an email message",
 *     chatApiConfigs: {},
 *   }}
 * />
 * ```
 *
 * ## Usage
 *
 * ### Install Dependencies
 *
 * This component is part of the [@copilotkit/react-textarea](https://npmjs.com/package/@copilotkit/react-textarea) package.
 *
 * ```shell npm2yarn \"@copilotkit/react-textarea"\
 * npm install @copilotkit/react-core @copilotkit/react-textarea
 * ```
 *
 * ### Usage
 *
 * Use the CopilotTextarea component in your React application similarly to a standard `<textarea />`,
 * with additional configurations for AI-powered features.
 *
 * For example:
 *
 * ```tsx
 * import { useState } from "react";
 * import { CopilotTextarea } from "@copilotkit/react-textarea";
 * import "@copilotkit/react-textarea/styles.css";
 *
 * export function ExampleComponent() {
 *   const [text, setText] = useState("");
 *
 *   return (
 *     <CopilotTextarea
 *       className="custom-textarea-class"
 *       value={text}
 *       onValueChange={(value: string) => setText(value)}
 *       placeholder="Enter your text here..."
 *       autosuggestionsConfig={{
 *         textareaPurpose: "Provide context or purpose of the textarea.",
 *         chatApiConfigs: {
 *           suggestionsApiConfig: {
 *             maxTokens: 20,
 *             stop: [".", "?", "!"],
 *           },
 *         },
 *       }}
 *     />
 *   );
 * }
 * ```
 *
 * ### Look & Feel
 *
 * By default, CopilotKit components do not have any styles. You can import CopilotKit's stylesheet at the root of your project:
 * ```tsx title="YourRootComponent.tsx"
 * ...
 * import "@copilotkit/react-textarea/styles.css"; // [!code highlight]
 *
 * export function YourRootComponent() {
 *   return (
 *     <CopilotKit>
 *       ...
 *     </CopilotKit>
 *   );
 * }
 * ```
 * For more information about how to customize the styles, check out the [Customize Look & Feel](/concepts/customize-look-and-feel) guide.
 * */
import React from "react";
import { useMakeStandardAutosuggestionFunction } from "../../hooks/make-autosuggestions-function/use-make-standard-autosuggestions-function";
import { HTMLCopilotTextAreaElement } from "../../types";
import { BaseCopilotTextareaProps } from "../../types/base/base-copilot-textarea-props";
import {
  AutosuggestionsConfig,
  defaultAutosuggestionsConfig,
} from "../../types/autosuggestions-config";
import { BaseCopilotTextarea } from "../base-copilot-textarea/base-copilot-textarea";
import { useMakeStandardInsertionOrEditingFunction } from "../../hooks/make-autosuggestions-function/use-make-standard-insertion-function";
import merge from "lodash.merge";
import { AutosuggestionsConfigUserSpecified } from "../../types/autosuggestions-config/autosuggestions-config-user-specified";

// Like the base copilot textarea props,
// but with baseAutosuggestionsConfig replaced with autosuggestionsConfig.
export interface CopilotTextareaProps
  extends Omit<BaseCopilotTextareaProps, "baseAutosuggestionsConfig"> {
  /**
   * Configuration settings for the autosuggestions feature.
   * For full reference, [check the interface on GitHub](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/packages/react-textarea/src/types/base/base-copilot-textarea-props.tsx#L8).
   *
   * <PropertyReference name="textareaPurpose" type="string" required={true} >
   *   The purpose of the text area in plain text.
   *
   *   Example: *"The body of the email response"*
   * </PropertyReference>
   *
   * <PropertyReference name="chatApiConfigs" type="ChatApiConfigs" >
   *   The chat API configurations.
   *
   *   <strong>NOTE:</strong> You must provide specify at least one of `suggestionsApiConfig` or `insertionApiConfig`.
   *
   *   <PropertyReference name="suggestionsApiConfig" type="SuggestionsApiConfig">
   *       For full reference, please [click here](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/packages/react-textarea/src/types/autosuggestions-config/suggestions-api-config.tsx#L4).
   *   </PropertyReference>
   *   <PropertyReference name="insertionApiConfig" type="InsertionApiConfig">
   *       For full reference, please [click here](https://github.com/CopilotKit/CopilotKit/blob/main/CopilotKit/packages/react-textarea/src/types/autosuggestions-config/insertions-api-config.tsx#L4).
   *   </PropertyReference>
   * </PropertyReference>
   *
   * <PropertyReference name="disabled" type="boolean" >
   *   Whether the textarea is disabled.
   * </PropertyReference>
   *
   * <PropertyReference name="disableBranding" type="boolean" >
   *   Whether to disable the CopilotKit branding.
   * </PropertyReference>
   *
   * <PropertyReference name="placeholderStyle" type="React.CSSProperties" >
   *   Specifies the CSS styles to apply to the placeholder text.
   * </PropertyReference>
   *
   * <PropertyReference name="suggestionsStyle" type="React.CSSProperties" >
   *   Specifies the CSS styles to apply to the suggestions list.
   * </PropertyReference>
   *
   * <PropertyReference name="hoverMenuClassname" type="string" >
   *   A class name to apply to the editor popover window.
   * </PropertyReference>
   *
   * <PropertyReference name="value" type="string" >
   *   The initial value of the textarea. Can be controlled via `onValueChange`.
   * </PropertyReference>
   *
   * <PropertyReference name="onValueChange" type="(value: string) => void" >
   *   Callback invoked when the value of the textarea changes.
   * </PropertyReference>
   *
   * <PropertyReference name="onChange" type="(event: React.ChangeEvent<HTMLTextAreaElement>) => void" >
   *   Callback invoked when a `change` event is triggered on the textarea element.
   * </PropertyReference>
   *
   * <PropertyReference name="shortcut" type="string" >
   *   The shortcut to use to open the editor popover window. Default is `"Cmd-k"`.
   * </PropertyReference>
   */
  autosuggestionsConfig: AutosuggestionsConfigUserSpecified;
}

/**
 * A copilot textarea that uses the standard autosuggestions function.
 */
export const CopilotTextarea = React.forwardRef(
  (props: CopilotTextareaProps, ref: React.Ref<HTMLCopilotTextAreaElement>) => {
    // separate the AutosuggestionsConfigUserSpecified from the rest of the props
    const { autosuggestionsConfig: autosuggestionsConfigUserSpecified, ...forwardedProps } = props;

    const autosuggestionsConfig: AutosuggestionsConfig = merge(
      defaultAutosuggestionsConfig,
      autosuggestionsConfigUserSpecified,
    );

    const autosuggestionsFunction = useMakeStandardAutosuggestionFunction(
      autosuggestionsConfig.textareaPurpose,
      autosuggestionsConfig.contextCategories,
      autosuggestionsConfig.chatApiConfigs.suggestionsApiConfig,
    );

    const insertionOrEditingFunction = useMakeStandardInsertionOrEditingFunction(
      autosuggestionsConfig.textareaPurpose,
      autosuggestionsConfig.contextCategories,
      autosuggestionsConfig.chatApiConfigs.insertionApiConfig,
      autosuggestionsConfig.chatApiConfigs.editingApiConfig,
    );

    return (
      <>
        <BaseCopilotTextarea
          ref={ref}
          {...forwardedProps}
          baseAutosuggestionsConfig={{
            ...autosuggestionsConfig,
            apiConfig: {
              insertionOrEditingFunction: insertionOrEditingFunction,
              autosuggestionsFunction: autosuggestionsFunction,
            },
          }}
        />
      </>
    );
  },
);



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/text-insertion-prompt-box/hovering-insertion-prompt-box-core.tsx
---

import useAutosizeTextArea from "../../../hooks/misc/use-autosize-textarea";
import {
  EditingEditorState,
  Generator_InsertionOrEditingSuggestion,
} from "../../../types/base/autosuggestions-bare-function";
import { SourceSearchBox } from "../../source-search-box/source-search-box";
import { DocumentPointer, useCopilotContext } from "@copilotkit/react-core";
import { Button } from "../../ui/button";
import { Label } from "../../ui/label";
import { useCallback, useEffect, useRef, useState } from "react";

import { streamPromiseFlatten } from "../../../lib/stream-promise-flatten";
import { IncludedFilesPreview } from "./included-files-preview";
import { useHoveringEditorContext } from "../hovering-editor-provider";

export type SuggestionState = {
  editorState: EditingEditorState;
};

export interface HoveringInsertionPromptBoxCoreProps {
  state: SuggestionState;
  performInsertion: (insertedText: string) => void;
  insertionOrEditingFunction: Generator_InsertionOrEditingSuggestion;
  contextCategories: string[];
}

export const HoveringInsertionPromptBoxCore = ({
  performInsertion,
  state,
  insertionOrEditingFunction,
  contextCategories,
}: HoveringInsertionPromptBoxCoreProps) => {
  const { getDocumentsContext } = useCopilotContext();

  const [editSuggestion, setEditSuggestion] = useState<string>("");
  const [suggestionIsLoading, setSuggestionIsLoading] = useState<boolean>(false);

  const [adjustmentPrompt, setAdjustmentPrompt] = useState<string>("");

  const [generatingSuggestion, setGeneratingSuggestion] = useState<ReadableStream<string> | null>(
    null,
  );

  const adjustmentTextAreaRef = useRef<HTMLTextAreaElement>(null);
  const suggestionTextAreaRef = useRef<HTMLTextAreaElement>(null);

  const [filePointers, setFilePointers] = useState<DocumentPointer[]>([]);

  const [suggestedFiles, setSuggestedFiles] = useState<DocumentPointer[]>([]);
  useEffect(() => {
    setSuggestedFiles(getDocumentsContext(contextCategories));
  }, [contextCategories, getDocumentsContext]);

  useAutosizeTextArea(suggestionTextAreaRef, editSuggestion || "");
  useAutosizeTextArea(adjustmentTextAreaRef, adjustmentPrompt || "");

  // initially focus on the adjustment prompt text area
  useEffect(() => {
    adjustmentTextAreaRef.current?.focus();
  }, []);

  // continuously read the generating suggestion stream and update the edit suggestion
  useEffect(() => {
    // if no generating suggestion, do nothing
    if (!generatingSuggestion) {
      return;
    }

    // Check if the stream is already locked (i.e. already reading from it)
    if (generatingSuggestion.locked) {
      return;
    }

    // reset the edit suggestion
    setEditSuggestion("");

    // read the generating suggestion stream and continuously update the edit suggestion
    const reader = generatingSuggestion.getReader();
    const read = async () => {
      setSuggestionIsLoading(true);
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        setEditSuggestion((prev) => {
          const newSuggestion = prev + value;

          // Scroll to the bottom of the textarea. We call this here to make sure scroll-to-bottom is synchronous with the state update.
          if (suggestionTextAreaRef.current) {
            suggestionTextAreaRef.current.scrollTop = suggestionTextAreaRef.current.scrollHeight;
          }
          return newSuggestion;
        });
      }

      setSuggestionIsLoading(false);
    };
    read();

    return () => {
      // release the lock if the reader is not closed on unmount
      const releaseLockIfNotClosed = async () => {
        try {
          await reader.closed;
        } catch {
          reader.releaseLock();
        }
      };

      releaseLockIfNotClosed();
    };
  }, [generatingSuggestion]);

  // generate an adjustment to the completed text, based on the adjustment prompt
  const beginGeneratingAdjustment = useCallback(async () => {
    // don't generate text if the prompt is empty
    if (!adjustmentPrompt.trim()) {
      return;
    }

    // editor state includes the text being edited, and the text before/after the selection
    // if the current edit suggestion is not empty, then use *it* as the "selected text" - instead of the editor state's selected text
    let modificationState = state.editorState;
    if (editSuggestion !== "") {
      modificationState.selectedText = editSuggestion;
    }

    // generate the adjustment suggestion
    const adjustmentSuggestionTextStreamPromise = insertionOrEditingFunction(
      modificationState,
      adjustmentPrompt,
      filePointers,
      new AbortController().signal,
    );
    const adjustmentSuggestionTextStream = streamPromiseFlatten(
      adjustmentSuggestionTextStreamPromise,
    );

    setGeneratingSuggestion(adjustmentSuggestionTextStream);
  }, [
    adjustmentPrompt,
    editSuggestion,
    state.editorState,
    insertionOrEditingFunction,
    filePointers,
  ]);

  const isLoading = suggestionIsLoading;

  const textToEdit = editSuggestion || state.editorState.selectedText;
  const adjustmentLabel =
    textToEdit === ""
      ? "Describe the text you want to insert"
      : "Describe adjustments to the suggested text";
  const placeholder =
    textToEdit === ""
      ? "e.g. 'summarize the client's top 3 pain-points from @CallTranscript'"
      : "e.g. 'make it more formal', 'be more specific', ...";

  const { setIsDisplayed } = useHoveringEditorContext();

  const AdjustmentPromptComponent = (
    <>
      <Label className="">{adjustmentLabel}</Label>
      <div className="relative w-full flex items-center">
        <textarea
          disabled={suggestionIsLoading}
          ref={adjustmentTextAreaRef}
          value={adjustmentPrompt}
          onChange={(e) => setAdjustmentPrompt(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && e.shiftKey) {
              e.preventDefault();
              setAdjustmentPrompt(adjustmentPrompt + "\n");
            } else if (e.key === "Enter") {
              e.preventDefault();
              beginGeneratingAdjustment();
            } else if (e.key == "Escape") {
              e.preventDefault();
              setIsDisplayed(false);
            }
          }}
          placeholder={placeholder}
          style={{ minHeight: "3rem" }}
          className="w-full bg-slate-100 h-auto h-min-14 text-sm p-2 rounded-md resize-none overflow-visible focus:outline-none focus:ring-0 focus:border-non pr-[3rem]"
          rows={1}
        />
        <button
          onClick={beginGeneratingAdjustment}
          className="absolute right-2 bg-blue-500 text-white w-8 h-8 rounded-full flex items-center justify-center"
        >
          <i className="material-icons">arrow_forward</i>
        </button>
      </div>
    </>
  );

  const SuggestionComponent = (
    <>
      <div className="flex justify-between items-end w-full">
        <Label className="mt-4">Suggested:</Label>
        <div className="ml-auto">
          {isLoading && (
            <div className="flex justify-center items-center">
              <div
                className="inline-block h-4 w-4 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
                role="status"
              >
                <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                  Loading...
                </span>
              </div>
            </div>
          )}
        </div>
      </div>
      <textarea
        ref={suggestionTextAreaRef}
        value={editSuggestion}
        disabled={suggestionIsLoading}
        onChange={(e) => setEditSuggestion(e.target.value)}
        className="w-full text-base p-2 border border-gray-300 rounded-md resize-none bg-green-50"
        style={{ overflow: "auto", maxHeight: "10em" }}
      />
    </>
  );

  const SubmitComponent = (
    <div className="flex w-full gap-4 justify-start">
      <Button
        className=" bg-green-700 text-white"
        onClick={() => {
          performInsertion(editSuggestion);
        }}
      >
        Insert <i className="material-icons">check</i>
      </Button>
    </div>
  );

  // show source search if the last word in the adjustment prompt BEGINS with an @
  const sourceSearchCandidate = adjustmentPrompt.split(" ").pop();
  // if the candidate is @someCandidate, then 'someCandidate', otherwise undefined
  const sourceSearchWord = sourceSearchCandidate?.startsWith("@")
    ? sourceSearchCandidate.slice(1)
    : undefined;

  return (
    <div className="w-full flex flex-col items-start relative gap-2">
      {AdjustmentPromptComponent}
      {filePointers.length > 0 && (
        <IncludedFilesPreview includedFiles={filePointers} setIncludedFiles={setFilePointers} />
      )}
      {sourceSearchWord !== undefined && (
        <SourceSearchBox
          searchTerm={sourceSearchWord}
          suggestedFiles={suggestedFiles}
          onSelectedFile={(filePointer) => {
            setAdjustmentPrompt(adjustmentPrompt.replace(new RegExp(`@${sourceSearchWord}$`), ""));
            setFilePointers((prev) => [...prev, filePointer]);

            // focus back on the adjustment prompt, and move the cursor to the end
            adjustmentTextAreaRef.current?.focus();
          }}
        />
      )}
      {generatingSuggestion ? SuggestionComponent : null}
      {generatingSuggestion ? SubmitComponent : null}
    </div>
  );
};



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/text-insertion-prompt-box/hovering-insertion-prompt-box.tsx
---

import { HoveringInsertionPromptBoxCore } from "./hovering-insertion-prompt-box-core";
import {
  EditingEditorState,
  InsertionEditorApiConfig,
} from "../../../types/base/autosuggestions-bare-function";

export interface Props {
  editorState: EditingEditorState;
  apiConfig: InsertionEditorApiConfig;
  performInsertion: (insertedText: string) => void;
  closeWindow: () => void;
  contextCategories: string[];
}

export const HoveringInsertionPromptBox = (props: Props) => {
  return (
    <div
      className="flex flex-col justify-center items-center space-y-4 rounded-md border shadow-lg p-4 border-gray- bg-white"
      style={{ width: "35rem" }}
    >
      <HoveringInsertionPromptBoxCore
        state={{
          editorState: props.editorState,
        }}
        insertionOrEditingFunction={props.apiConfig.insertionOrEditingFunction}
        performInsertion={props.performInsertion}
        contextCategories={props.contextCategories}
      />
    </div>
  );
};



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/text-insertion-prompt-box/included-files-preview.tsx
---

import { DocumentPointer } from "@copilotkit/react-core";
import { Label } from "../../ui/label";
import React from "react";
import Chip from "@mui/material/Chip/Chip.js";
import Avatar from "@mui/material/Avatar/Avatar.js";

export interface IncludedFilesPreviewProps {
  includedFiles: DocumentPointer[];
  setIncludedFiles: React.Dispatch<React.SetStateAction<DocumentPointer[]>>;
}

export const IncludedFilesPreview = ({
  includedFiles,
  setIncludedFiles,
}: IncludedFilesPreviewProps) => {
  return (
    <div className="flex flex-col gap-2 mt-2">
      <Label className="">Included context:</Label>
      <div className="flex flex-wrap gap-2">
        {includedFiles.map((filePointer, index) => {
          return (
            <FileChipPreview
              key={`file-${filePointer.sourceApplication}.${filePointer.name}`}
              filePointer={filePointer}
              onDelete={() => {
                setIncludedFiles((prev) => prev.filter((fp) => fp !== filePointer));
              }}
            />
          );
        })}
      </div>
    </div>
  );
};

export interface FileChipPreviewProps {
  filePointer: DocumentPointer;
  onDelete: () => void;
}

export const FileChipPreview = ({ filePointer, onDelete }: FileChipPreviewProps) => {
  return (
    <Chip
      label={filePointer.name}
      onDelete={onDelete}
      avatar={
        <Avatar
          src={filePointer.iconImageUri}
          alt={filePointer.sourceApplication}
          sx={{ backgroundColor: "transparent" }}
        ></Avatar>
      }
    />
  );
};



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/text-insertion-prompt-box/index.ts
---

export { HoveringInsertionPromptBox } from "./hovering-insertion-prompt-box";
export type { Props } from "./hovering-insertion-prompt-box";



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/hovering-editor-provider.tsx
---

import { createContext, useState, useContext, ReactNode } from "react";

interface HoveringEditorContextProps {
  isDisplayed: boolean;
  setIsDisplayed: (value: boolean) => void;
}

const HoveringEditorContext = createContext<HoveringEditorContextProps>({
  isDisplayed: false,
  setIsDisplayed: () => {},
});

export interface HoveringEditorProviderProps {
  children: ReactNode;
}

/**
 * A context provider for the hovering editor over the `CopilotTextarea`
 * (used to edit and insert text into the `CopilotTextarea`).
 */
export const HoveringEditorProvider = ({ children }: HoveringEditorProviderProps) => {
  const [isDisplayed, setIsDisplayed] = useState<boolean>(false);

  return (
    <HoveringEditorContext.Provider value={{ isDisplayed, setIsDisplayed }}>
      {children}
    </HoveringEditorContext.Provider>
  );
};

export const useHoveringEditorContext = () => useContext(HoveringEditorContext);



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/hovering-toolbar-components.tsx
---

import { css, cx } from "@emotion/css";
import React, { PropsWithChildren, Ref } from "react";
import ReactDOM from "react-dom";

interface BaseProps {
  className: string;
  [key: string]: unknown;
}

export const Button = React.forwardRef(
  (
    {
      className,
      active,
      reversed,
      ...props
    }: PropsWithChildren<
      {
        active: boolean;
        reversed: boolean;
      } & BaseProps
    >,
    ref: Ref<HTMLSpanElement | null>,
  ) => (
    <span
      {...props}
      ref={ref as Ref<HTMLSpanElement>}
      className={cx(
        className,
        css`
          cursor: pointer;
          color: ${reversed ? (active ? "white" : "#aaa") : active ? "black" : "#ccc"};
        `,
      )}
    />
  ),
);

export const Icon = React.forwardRef(
  ({ className, ...props }: PropsWithChildren<BaseProps>, ref: Ref<HTMLSpanElement | null>) => (
    <span
      {...props}
      ref={ref as Ref<HTMLSpanElement>}
      className={cx(
        "material-icons",
        className,
        css`
          font-size: 18px;
          vertical-align: text-bottom;
        `,
      )}
    />
  ),
);

export const Menu = React.forwardRef(
  ({ className, ...props }: PropsWithChildren<BaseProps>, ref: Ref<HTMLDivElement | null>) => {
    return (
      <div
        {...props}
        data-test-id="menu"
        ref={ref as Ref<HTMLDivElement>}
        className={cx(
          className,
          css`
            & > * {
              display: inline-block;
            }

            & > * + * {
              margin-left: 15px;
            }
          `,
        )}
      />
    );
  },
);
export const Portal = ({ children }: { children: React.ReactNode }) => {
  return typeof document === "object" ? ReactDOM.createPortal(children, document.body) : null;
};

export const Toolbar = React.forwardRef(
  ({ className, ...props }: PropsWithChildren<BaseProps>, ref?: Ref<HTMLDivElement>) => (
    <Menu
      {...props}
      ref={ref}
      className={cx(
        className,
        css`
          position: relative;
          padding: 1px 18px 17px;
          margin: 0 -20px;
          border-bottom: 2px solid #eee;
          margin-bottom: 20px;
        `,
      )}
    />
  ),
);



---
File: /CopilotKit/packages/react-textarea/src/components/hovering-toolbar/hovering-toolbar.tsx
---

import { useEffect, useRef, useState } from "react";
import { Editor, Location, Transforms } from "slate";
import { useSlate, useSlateSelection } from "slate-react";
import { HoveringInsertionPromptBox } from "./text-insertion-prompt-box";
import { Menu, Portal } from "./hovering-toolbar-components";
import { useHoveringEditorContext } from "./hovering-editor-provider";
import {
  getFullEditorTextWithNewlines,
  getTextAroundSelection,
} from "../../lib/get-text-around-cursor";
import {
  EditingEditorState,
  InsertionEditorApiConfig,
} from "../../types/base/autosuggestions-bare-function";

export interface HoveringToolbarProps {
  apiConfig: InsertionEditorApiConfig;
  contextCategories: string[];
  hoverMenuClassname: string | undefined;
}

export const HoveringToolbar = (props: HoveringToolbarProps) => {
  const ref = useRef<HTMLDivElement>(null);
  const editor = useSlate();
  const selection = useSlateSelection();
  const { isDisplayed, setIsDisplayed } = useHoveringEditorContext();

  // only render on client
  const [isClient, setIsClient] = useState(false);
  useEffect(() => {
    setIsClient(true);
  }, []);

  useEffect(() => {
    const el = ref.current;
    const { selection } = editor;

    if (!el) {
      return;
    }

    if (!selection) {
      el.removeAttribute("style");
      return;
    }

    const domSelection = window.getSelection();
    if (!domSelection || domSelection.rangeCount === 0) {
      return;
    }

    const domRange = domSelection.getRangeAt(0);
    const rect = domRange.getBoundingClientRect();

    // We use window = (0,0,0,0) as a signal that the selection is not in the original copilot-textarea,
    // but inside the hovering window.
    //
    // in such case, we simply do nothing.
    if (rect.top === 0 && rect.left === 0 && rect.width === 0 && rect.height === 0) {
      return;
    }
    const minGapFromEdge = 60;
    const verticalOffsetFromCorner = 35;
    const horizontalOffsetFromCorner = 15;
    let top = rect.top + window.scrollY - el.offsetHeight + verticalOffsetFromCorner;
    // make sure top is in the viewport and not too close to the edge
    if (top < minGapFromEdge) {
      top = rect.bottom + window.scrollY + minGapFromEdge;
    } else if (top + el.offsetHeight > window.innerHeight - minGapFromEdge) {
      top = rect.top + window.scrollY - el.offsetHeight - minGapFromEdge;
    }

    let left =
      rect.left + window.scrollX - el.offsetWidth / 2 + rect.width / 2 + horizontalOffsetFromCorner;
    // make sure left is in the viewport and not too close to the edge
    if (left < minGapFromEdge) {
      left = minGapFromEdge;
    } else if (left + el.offsetWidth > window.innerWidth - minGapFromEdge) {
      left = window.innerWidth - el.offsetWidth - minGapFromEdge;
    }

    el.style.opacity = "1";
    el.style.position = "absolute";

    el.style.top = `${top}px`;
    el.style.left = `${left}px`;
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (ref.current && !ref.current.contains(event.target as Node)) {
        setIsDisplayed(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [ref, setIsDisplayed]);

  if (!isClient) {
    return null;
  }

  return (
    <Portal>
      <Menu
        ref={ref}
        className={
          "copilot-kit-textarea-css-scope " +
          (props.hoverMenuClassname ||
            "p-2 absolute z-10 top-[-10000px] left-[-10000px] mt-[-6px] opacity-0 transition-opacity duration-700")
        }
      >
        {isDisplayed && selection && (
          <HoveringInsertionPromptBox
            editorState={editorState(editor, selection)}
            apiConfig={props.apiConfig}
            closeWindow={() => {
              setIsDisplayed(false);
            }}
            performInsertion={(insertedText) => {
              // replace the selection with the inserted text
              Transforms.delete(editor, { at: selection });
              Transforms.insertText(editor, insertedText, {
                at: selection,
              });
              setIsDisplayed(false);
            }}
            contextCategories={props.contextCategories}
          />
        )}
      </Menu>
    </Portal>
  );
};

function editorState(editor: Editor, selection: Location): EditingEditorState {
  const textAroundCursor = getTextAroundSelection(editor);
  if (textAroundCursor) {
    return textAroundCursor;
  }

  return {
    textBeforeCursor: getFullEditorTextWithNewlines(editor),
    textAfterCursor: "",
    selectedText: "",
  };
}



---
File: /CopilotKit/packages/react-textarea/src/components/manual-ui/chip-with-icon.tsx
---

export interface ChipWithIconProps {
  label: string;
  onDelete: () => void;
  iconUrl: string;
}

export const ChipWithIcon = ({ label, onDelete, iconUrl }: ChipWithIconProps) => {
  return (
    <span className="inline-flex items-center px-3 py-1 rounded-full bg-slate-200 text-sm font-medium text-white">
      {iconUrl && <img src={iconUrl} alt="icon" className="w-4 h-4 rounded-full mr-2" />}
      {label}
      <button className="ml-2 text-white hover:text-gray-200 focus:outline-none" onClick={onDelete}>
        x
      </button>
    </span>
  );
};



---
File: /CopilotKit/packages/react-textarea/src/components/source-search-box/source-search-box.tsx
---

import { useState } from "react";
import {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
} from "../ui/command";

import { Calculator, Calendar, CreditCard, Settings, Smile, User } from "lucide-react";

import { DocumentPointer } from "@copilotkit/react-core";

export interface SourceSearchBoxProps {
  searchTerm: string;
  suggestedFiles: DocumentPointer[];
  onSelectedFile: (filePointer: DocumentPointer) => void;
}

export function SourceSearchBox(props: SourceSearchBoxProps) {
  const [selectedValue, setSelectedValue] = useState<string>("");

  return (
    <Command
      className="rounded-lg border shadow-md"
      value={selectedValue}
      onValueChange={(value) => {
        setSelectedValue(value);
      }}
      filter={(value, search) => {
        // if the search term is empty, show all commands
        if (props.searchTerm === "") return 1;

        // if the search term is a prefix of the command, show it
        if (value.startsWith(props.searchTerm)) return 1;

        // otherwise, don't show it
        return 0;
      }}
    >
      <CommandInput
        value={props.searchTerm}
        className="rounded-t-lg hidden"
        placeholder="Search for a command..."
      />
      <CommandList>
        <CommandEmpty>No results found.</CommandEmpty>

        <CommandGroup heading="Available resources">
          {props.suggestedFiles.map((filePointer) => {
            return (
              <CommandItem
                key={`word-${filePointer.sourceApplication}.${filePointer.name}`}
                value={filePointer.name}
                onSelect={(value) => {
                  props.onSelectedFile(filePointer);
                }}
              >
                <div className=" px-3  flex flex-row gap-1 items-center">
                  <Logo width="20px" height="20px">
                    <img
                      src={filePointer.iconImageUri}
                      alt={filePointer.sourceApplication}
                      className="w-full h-full"
                    />
                  </Logo>
                  {filePointer.name}
                </div>
              </CommandItem>
            );
          })}
        </CommandGroup>

        {/* <CommandGroup heading="Suggestions">
          <CommandItem
            onSelect={(value) => {
              console.log(value);
              console.log(value);
            }}
          >
            <Calendar className="mr-2 h-4 w-4" />
            <span>Calendar</span>
          </CommandItem>
          <CommandItem>
            <Smile className="mr-2 h-4 w-4" />
            <span>Search Emoji</span>
          </CommandItem>
          <CommandItem>
            <Calculator className="mr-2 h-4 w-4" />
            <span>Calculator</span>
          </CommandItem>
        </CommandGroup> */}
        <CommandSeparator />
      </CommandList>
    </Command>
  );
}

export function Logo({
  children,
  width,
  height,
}: {
  children: React.ReactNode;
  width: string;
  height: string;
}) {
  return (
    <div className="flex items-center justify-center" style={{ width: width, height: height }}>
      {children}
    </div>
  );
}



---
File: /CopilotKit/packages/react-textarea/src/components/ui/button.tsx
---

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "../../lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };



---
File: /CopilotKit/packages/react-textarea/src/components/ui/command.tsx
---

import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { cn } from "../../lib/utils";
import { Dialog, DialogContent } from "./dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    {/* <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" /> */}
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden pb-2", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};



---
File: /CopilotKit/packages/react-textarea/src/components/ui/dialog.tsx
---

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "../../lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = ({
  className,
  children,
  ...props
}: DialogPrimitive.DialogPortalProps & { className?: string }) => (
  <DialogPrimitive.Portal {...props}>
    <div className={cn(className)}>{children}</div>
  </DialogPrimitive.Portal>
);

DialogPortal.displayName = DialogPrimitive.Portal.displayName;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};



---
File: /CopilotKit/packages/react-textarea/src/components/ui/label.tsx
---

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "../../lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };



---
File: /CopilotKit/packages/react-textarea/src/components/index.ts
---

export { BaseCopilotTextarea } from "./base-copilot-textarea/base-copilot-textarea";

export { CopilotTextarea } from "./copilot-textarea/copilot-textarea";
export type { CopilotTextareaProps } from "./copilot-textarea/copilot-textarea";



---
File: /CopilotKit/packages/react-textarea/src/context/index.ts
---

export {};



---
File: /CopilotKit/packages/react-textarea/src/hooks/base-copilot-textarea-implementation/use-autosuggestions.ts
---

import { useCallback, useEffect, useMemo, useState } from "react";
import { Debouncer } from "../../lib/debouncer";
import { nullableCompatibleEqualityCheck } from "../../lib/utils";
import { AutosuggestionsBareFunction } from "../../types/base";
import { AutosuggestionState } from "../../types/base/autosuggestion-state";
import {
  EditorAutocompleteState,
  areEqual_autocompleteState,
} from "../../types/base/editor-autocomplete-state";

export interface UseAutosuggestionsResult {
  currentAutocompleteSuggestion: AutosuggestionState | null;
  onChangeHandler: (newEditorState: EditorAutocompleteState | null) => void;
  onKeyDownHandler: (event: React.KeyboardEvent<HTMLDivElement>) => void;
  onTouchStartHandler: (event: React.TouchEvent<HTMLDivElement>) => void;
}

export function useAutosuggestions(
  debounceTime: number,
  shouldAcceptAutosuggestionOnKeyPress: (event: React.KeyboardEvent<HTMLDivElement>) => boolean,
  shouldAcceptAutosuggestionOnTouch: (event: React.TouchEvent<HTMLDivElement>) => boolean,
  autosuggestionFunction: AutosuggestionsBareFunction,
  insertAutocompleteSuggestion: (suggestion: AutosuggestionState) => void,
  disableWhenEmpty: boolean,
  disabled: boolean,
): UseAutosuggestionsResult {
  const [previousAutocompleteState, setPreviousAutocompleteState] =
    useState<EditorAutocompleteState | null>(null);

  const [currentAutocompleteSuggestion, setCurrentAutocompleteSuggestion] =
    useState<AutosuggestionState | null>(null);

  const awaitForAndAppendSuggestion: (
    editorAutocompleteState: EditorAutocompleteState,
    abortSignal: AbortSignal,
  ) => Promise<void> = useCallback(
    async (editorAutocompleteState: EditorAutocompleteState, abortSignal: AbortSignal) => {
      // early return if disabled
      if (disabled) {
        return;
      }

      if (
        disableWhenEmpty &&
        editorAutocompleteState.textBeforeCursor === "" &&
        editorAutocompleteState.textAfterCursor === ""
      ) {
        return;
      }

      // fetch the suggestion
      const suggestion = await autosuggestionFunction(editorAutocompleteState, abortSignal);

      // We'll assume for now that the autocomplete function might or might not respect the abort signal.
      if (!suggestion || abortSignal.aborted) {
        throw new DOMException("Aborted", "AbortError");
      }

      setCurrentAutocompleteSuggestion({
        text: suggestion,
        point: editorAutocompleteState.cursorPoint,
      });
    },
    [autosuggestionFunction, setCurrentAutocompleteSuggestion, disableWhenEmpty, disabled],
  );

  const debouncedFunction = useMemo(
    () => new Debouncer<[editorAutocompleteState: EditorAutocompleteState]>(debounceTime),
    [debounceTime],
  );

  // clean current state when unmounting or disabling
  useEffect(() => {
    return () => {
      debouncedFunction.cancel();
      setCurrentAutocompleteSuggestion(null);
    };
  }, [debouncedFunction, disabled]);

  const onChange = useCallback(
    (newEditorState: EditorAutocompleteState | null) => {
      const editorStateHasChanged = !nullableCompatibleEqualityCheck(
        areEqual_autocompleteState,
        previousAutocompleteState,
        newEditorState,
      );
      setPreviousAutocompleteState(newEditorState);

      // if no change, do nothing
      if (!editorStateHasChanged) {
        return;
      }

      // if change, then first null out the current suggestion
      setCurrentAutocompleteSuggestion(null);

      // then try to get a new suggestion, debouncing to avoid too many requests while typing
      if (newEditorState) {
        debouncedFunction.debounce(awaitForAndAppendSuggestion, newEditorState);
      } else {
        debouncedFunction.cancel();
      }
    },
    [
      previousAutocompleteState,
      setPreviousAutocompleteState,
      debouncedFunction,
      awaitForAndAppendSuggestion,
      setCurrentAutocompleteSuggestion,
    ],
  );

  const keyDownOrTouchHandler = useCallback(
    (event: React.KeyboardEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {
      if (currentAutocompleteSuggestion) {
        const shouldAcceptSuggestion =
          event.type === "touchstart"
            ? shouldAcceptAutosuggestionOnTouch(event as React.TouchEvent<HTMLDivElement>)
            : shouldAcceptAutosuggestionOnKeyPress(event as React.KeyboardEvent<HTMLDivElement>);

        if (shouldAcceptSuggestion) {
          event.preventDefault();
          insertAutocompleteSuggestion(currentAutocompleteSuggestion);
          setCurrentAutocompleteSuggestion(null);
        }
      }
    },
    [
      currentAutocompleteSuggestion,
      setCurrentAutocompleteSuggestion,
      insertAutocompleteSuggestion,
      shouldAcceptAutosuggestionOnKeyPress,
    ],
  );

  return {
    currentAutocompleteSuggestion,
    onChangeHandler: onChange,
    onKeyDownHandler: keyDownOrTouchHandler,
    onTouchStartHandler: keyDownOrTouchHandler,
  };
}



---
File: /CopilotKit/packages/react-textarea/src/hooks/base-copilot-textarea-implementation/use-copilot-textarea-editor.tsx
---

import { useMemo } from "react";
import { createEditor, Element } from "slate";
import { withReact } from "slate-react";
import {
  defaultShouldSave,
  ShouldSaveToHistory,
  withPartialHistory,
} from "../../lib/slatejs-edits/with-partial-history";
import { CustomEditor } from "../../types/base/custom-editor";

const shouldSave: ShouldSaveToHistory = (op, prev) => {
  const excludedNodeType = "suggestion";
  // Check if the operation involves the suggestion inline node type
  if (
    op.type === "insert_node" &&
    Element.isElement(op.node) &&
    op.node.type === excludedNodeType
  ) {
    return false;
  }

  if (
    op.type === "remove_node" &&
    Element.isElement(op.node) &&
    op.node.type === excludedNodeType
  ) {
    return false;
  }

  if (
    op.type === "set_node" &&
    "type" in op.newProperties &&
    op.newProperties.type === excludedNodeType
  ) {
    return false;
  }

  if (op.type == "set_node" && "type" in op.properties && op.properties.type === excludedNodeType) {
    return false;
  }

  if (
    op.type === "merge_node" &&
    "type" in op.properties &&
    op.properties.type === excludedNodeType
  ) {
    return false;
  }

  if (
    op.type === "split_node" &&
    "type" in op.properties &&
    op.properties.type === excludedNodeType
  ) {
    return false;
  }

  // Otherwise, save the operation to history
  return defaultShouldSave(op, prev);
};

export function useCopilotTextareaEditor(): CustomEditor {
  const editor = useMemo(() => {
    const editor = withPartialHistory(withReact(createEditor()), shouldSave);

    const { isVoid } = editor;
    editor.isVoid = (element) => {
      switch (element.type) {
        case "suggestion":
          return true;
        default:
          return isVoid(element);
      }
    };

    const { markableVoid } = editor;
    editor.markableVoid = (element) => {
      switch (element.type) {
        case "suggestion":
          return true;
        default:
          return markableVoid(element);
      }
    };

    const { isInline } = editor;
    editor.isInline = (element) => {
      switch (element.type) {
        case "suggestion":
          return element.inline;
        default:
          return isInline(element);
      }
    };

    return editor;
  }, []);

  return editor;
}



---
File: /CopilotKit/packages/react-textarea/src/hooks/base-copilot-textarea-implementation/use-populate-copilot-textarea-ref.ts
---

import React from "react";
import { Editor } from "slate";
import { ReactEditor } from "slate-react";
import { getFullEditorTextWithNewlines } from "../../lib/get-text-around-cursor";
import { replaceEditorText } from "../../lib/slatejs-edits/replace-text";
import { HTMLCopilotTextAreaElement } from "../../types";
import { CustomEditor } from "../../types/base/custom-editor";

export function usePopulateCopilotTextareaRef(
  editor: Editor,
  ref: React.Ref<HTMLCopilotTextAreaElement>,
) {
  React.useImperativeHandle(ref, () => {
    class Combined {
      constructor(
        private customMethods: CustomMethods,
        private editorHtmlElement: HTMLElement,
      ) {}

      [key: string]: any;

      get(target: any, propKey: string): any {
        if (this.isKeyOfCustomMethods(propKey)) {
          const value = this.customMethods[propKey];
          if (typeof value === "function") {
            return value.bind(this.customMethods);
          }
          return value;
        } else if (this.isKeyOfHTMLElement(propKey)) {
          const value = this.editorHtmlElement[propKey];
          if (typeof value === "function") {
            return value.bind(this.editorHtmlElement);
          }
          return value;
        }
      }

      set(target: any, propKey: string, value: any): boolean {
        if (this.isKeyOfCustomMethods(propKey)) {
          (this.customMethods as any)[propKey] = value;
        } else if (this.isKeyOfHTMLElement(propKey)) {
          (this.editorHtmlElement as any)[propKey] = value;
        } else {
          // Default behavior (optional)
          target[propKey] = value;
        }
        return true;
      }

      private isKeyOfCustomMethods(key: string): key is keyof CustomMethods {
        return key in this.customMethods;
      }

      private isKeyOfHTMLElement(key: string): key is keyof HTMLElement {
        return key in this.editorHtmlElement;
      }
    }

    const handler = {
      get(target: any, propKey: keyof CustomMethods | keyof HTMLElement) {
        return target.get(target, propKey);
      },
      set(target: any, propKey: keyof CustomMethods | keyof HTMLElement, value: any) {
        return target.set(target, propKey, value);
      },
    };

    class CustomMethods {
      constructor(private editor: CustomEditor) {}

      focus() {
        ReactEditor.focus(this.editor);
      }

      blur() {
        ReactEditor.blur(this.editor);
      }

      get value() {
        return getFullEditorTextWithNewlines(this.editor);
      }
      set value(value: string) {
        replaceEditorText(this.editor, value);
      }
    }

    const editorHtmlElement = ReactEditor.toDOMNode(editor, editor);
    const customMethods = new CustomMethods(editor);

    const combined = new Combined(customMethods, editorHtmlElement);
    return new Proxy(combined, handler);
  }, [editor]);
}



---
File: /CopilotKit/packages/react-textarea/src/hooks/make-autosuggestions-function/use-make-standard-autosuggestions-function.tsx
---

import { COPILOT_CLOUD_PUBLIC_API_KEY_HEADER } from "@copilotkit/shared";
import { useCopilotContext } from "@copilotkit/react-core";
import { useCallback } from "react";
import { AutosuggestionsBareFunction } from "../../types";
import { retry } from "../../lib/retry";
import { InsertionEditorState } from "../../types/base/autosuggestions-bare-function";
import { SuggestionsApiConfig } from "../../types/autosuggestions-config/suggestions-api-config";
import {
  CopilotRuntimeClient,
  Message,
  Role,
  TextMessage,
  convertGqlOutputToMessages,
  convertMessagesToGqlInput,
  filterAgentStateMessages,
  CopilotRequestType,
} from "@copilotkit/runtime-client-gql";

/**
 * Returns a memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.
 * The function takes in the text before and after the cursor, and an abort signal.
 * It sends a POST request to the API endpoint with the messages array containing the system message, few shot messages, and user messages.
 * The function returns the suggestion from the API response.
 *
 * @param textareaPurpose - The purpose of the textarea. This is included in the system message.
 * @param apiEndpoint - The API endpoint to send the autosuggestion request to.
 * @param makeSystemMessage - A function that takes in a context string and returns a system message to include in the autosuggestion request.
 * @param fewShotMessages - An array of few shot messages to include in the autosuggestion request.
 * @param contextCategories - The categories of context strings we want to include. By default, we include the (default) "global" context category.
 * @returns A memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.
 */
export function useMakeStandardAutosuggestionFunction(
  textareaPurpose: string,
  contextCategories: string[],
  apiConfig: SuggestionsApiConfig,
): AutosuggestionsBareFunction {
  const { getContextString, copilotApiConfig } = useCopilotContext();
  const { chatApiEndpoint: url, publicApiKey, credentials, properties } = copilotApiConfig;
  const headers = {
    ...copilotApiConfig.headers,
    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),
  };
  const { maxTokens, stop } = apiConfig;

  return useCallback(
    async (editorState: InsertionEditorState, abortSignal: AbortSignal) => {
      const res = await retry(async () => {
        const messages: Message[] = [
          new TextMessage({
            role: Role.System,
            content: apiConfig.makeSystemPrompt(
              textareaPurpose,
              getContextString([], contextCategories),
            ),
          }),
          ...apiConfig.fewShotMessages,
          new TextMessage({
            role: Role.User,
            content: editorState.textAfterCursor,
          }),
          new TextMessage({
            role: Role.User,
            content: `<TextAfterCursor>${editorState.textAfterCursor}</TextAfterCursor>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<TextBeforeCursor>${editorState.textBeforeCursor}</TextBeforeCursor>`,
          }),
        ];

        const runtimeClient = new CopilotRuntimeClient({
          url,
          publicApiKey,
          headers,
          credentials,
        });

        const response = await runtimeClient
          .generateCopilotResponse({
            data: {
              frontend: {
                actions: [],
                url: window.location.href,
              },
              messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),
              metadata: {
                requestType: CopilotRequestType.TextareaCompletion,
              },
              forwardedParameters: {
                maxTokens,
                stop,
              },
            },
            properties,
            signal: abortSignal,
          })
          .toPromise();

        let result = "";
        for (const message of convertGqlOutputToMessages(
          response.data?.generateCopilotResponse?.messages ?? [],
        )) {
          if (abortSignal.aborted) {
            break;
          }
          if (message instanceof TextMessage) {
            result += message.content;
          }
        }

        return result;
      });

      return res;
    },
    [apiConfig, getContextString, contextCategories, textareaPurpose],
  );
}



---
File: /CopilotKit/packages/react-textarea/src/hooks/make-autosuggestions-function/use-make-standard-insertion-function.tsx
---

import { COPILOT_CLOUD_PUBLIC_API_KEY_HEADER } from "@copilotkit/shared";
import { useCopilotContext } from "@copilotkit/react-core";
import { useCallback } from "react";
import {
  CopilotRuntimeClient,
  Message,
  Role,
  TextMessage,
  convertGqlOutputToMessages,
  convertMessagesToGqlInput,
  filterAgentStateMessages,
  CopilotRequestType,
} from "@copilotkit/runtime-client-gql";
import { retry } from "../../lib/retry";
import {
  EditingEditorState,
  Generator_InsertionOrEditingSuggestion,
} from "../../types/base/autosuggestions-bare-function";
import { InsertionsApiConfig } from "../../types/autosuggestions-config/insertions-api-config";
import { EditingApiConfig } from "../../types/autosuggestions-config/editing-api-config";
import { DocumentPointer } from "@copilotkit/react-core";

/**
 * Returns a memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.
 * The function takes in the text before and after the cursor, and an abort signal.
 * It sends a POST request to the API endpoint with the messages array containing the system message, few shot messages, and user messages.
 * The function returns the suggestion from the API response.
 *
 * @param textareaPurpose - The purpose of the textarea. This is included in the system message.
 * @param apiEndpoint - The API endpoint to send the autosuggestion request to.
 * @param makeSystemMessage - A function that takes in a context string and returns a system message to include in the autosuggestion request.
 * @param fewShotMessages - An array of few shot messages to include in the autosuggestion request.
 * @param contextCategories - The categories of context strings we want to include. By default, we include the (default) "global" context category.
 * @returns A memoized function that sends a request to the specified API endpoint to get an autosuggestion for the user's input.
 */
export function useMakeStandardInsertionOrEditingFunction(
  textareaPurpose: string,
  contextCategories: string[],
  insertionApiConfig: InsertionsApiConfig,
  editingApiConfig: EditingApiConfig,
): Generator_InsertionOrEditingSuggestion {
  const { getContextString, copilotApiConfig } = useCopilotContext();
  const headers = {
    ...(copilotApiConfig.publicApiKey
      ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey }
      : {}),
  };

  const runtimeClient = new CopilotRuntimeClient({
    url: copilotApiConfig.chatApiEndpoint,
    publicApiKey: copilotApiConfig.publicApiKey,
    headers,
    credentials: copilotApiConfig.credentials,
  });

  async function runtimeClientResponseToStringStream(
    responsePromise: ReturnType<typeof runtimeClient.generateCopilotResponse>,
  ) {
    const messagesStream = await CopilotRuntimeClient.asStream(responsePromise);

    return new ReadableStream({
      async start(controller) {
        const reader = messagesStream.getReader();
        let sentContent = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }

          const messages = convertGqlOutputToMessages(value.generateCopilotResponse.messages);

          let newContent = "";

          for (const message of messages) {
            if (message instanceof TextMessage) {
              newContent += message.content;
            }
          }
          if (newContent) {
            const contentToSend = newContent.slice(sentContent.length);
            controller.enqueue(contentToSend);
            sentContent += contentToSend;
          }
        }
        controller.close();
      },
    });
  }

  const insertionFunction = useCallback(
    async (
      editorState: EditingEditorState,
      insertionPrompt: string,
      documents: DocumentPointer[],
      abortSignal: AbortSignal,
    ) => {
      const res = await retry(async () => {
        const messages: Message[] = [
          new TextMessage({
            role: Role.System,
            content: insertionApiConfig.makeSystemPrompt(
              textareaPurpose,
              getContextString(documents, contextCategories),
            ),
          }),
          ...insertionApiConfig.fewShotMessages,
          new TextMessage({
            role: Role.User,
            content: `<TextAfterCursor>${editorState.textAfterCursor}</TextAfterCursor>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<TextBeforeCursor>${editorState.textBeforeCursor}</TextBeforeCursor>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<InsertionPrompt>${insertionPrompt}</InsertionPrompt>`,
          }),
        ];

        return runtimeClientResponseToStringStream(
          runtimeClient.generateCopilotResponse({
            data: {
              frontend: {
                actions: [],
                url: window.location.href,
              },
              messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),
              metadata: {
                requestType: CopilotRequestType.TextareaCompletion,
              },
            },
            properties: copilotApiConfig.properties,
            signal: abortSignal,
          }),
        );
      });

      return res;
    },
    [insertionApiConfig, getContextString, contextCategories, textareaPurpose],
  );

  const editingFunction = useCallback(
    async (
      editorState: EditingEditorState,
      editingPrompt: string,
      documents: DocumentPointer[],
      abortSignal: AbortSignal,
    ) => {
      const res = await retry(async () => {
        const messages: Message[] = [
          new TextMessage({
            role: Role.System,
            content: editingApiConfig.makeSystemPrompt(
              textareaPurpose,
              getContextString(documents, contextCategories),
            ),
          }),
          ...editingApiConfig.fewShotMessages,
          new TextMessage({
            role: Role.User,
            content: `<TextBeforeCursor>${editorState.textBeforeCursor}</TextBeforeCursor>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<TextToEdit>${editorState.selectedText}</TextToEdit>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<TextAfterCursor>${editorState.textAfterCursor}</TextAfterCursor>`,
          }),
          new TextMessage({
            role: Role.User,
            content: `<EditingPrompt>${editingPrompt}</EditingPrompt>`,
          }),
        ];

        const runtimeClient = new CopilotRuntimeClient({
          url: copilotApiConfig.chatApiEndpoint,
          publicApiKey: copilotApiConfig.publicApiKey,
          headers,
          credentials: copilotApiConfig.credentials,
        });

        return runtimeClientResponseToStringStream(
          runtimeClient.generateCopilotResponse({
            data: {
              frontend: {
                actions: [],
                url: window.location.href,
              },
              messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),
              metadata: {
                requestType: CopilotRequestType.TextareaCompletion,
              },
            },
            properties: copilotApiConfig.properties,
            signal: abortSignal,
          }),
        );
      });

      return res;
    },
    [editingApiConfig, getContextString, contextCategories, textareaPurpose],
  );

  const insertionOrEditingFunction = useCallback(
    async (
      editorState: EditingEditorState,
      insertionPrompt: string,
      documents: DocumentPointer[],
      abortSignal: AbortSignal,
    ) => {
      if (editorState.selectedText === "") {
        return await insertionFunction(editorState, insertionPrompt, documents, abortSignal);
      } else {
        return await editingFunction(editorState, insertionPrompt, documents, abortSignal);
      }
    },
    [insertionFunction, editingFunction],
  );

  return insertionOrEditingFunction;
}



---
File: /CopilotKit/packages/react-textarea/src/hooks/misc/use-autosize-textarea.tsx
---

import { Ref, RefObject, useEffect } from "react";

// Updates the height of a <textarea> when the value changes.
const useAutosizeTextArea = (textAreaRef: RefObject<HTMLTextAreaElement>, value: string) => {
  useEffect(() => {
    if (textAreaRef.current !== null) {
      // We need to reset the height momentarily to get the correct scrollHeight for the textarea
      textAreaRef.current.style.height = "0px";
      const scrollHeight = textAreaRef.current.scrollHeight;

      // We then set the height directly, outside of the render loop
      // Trying to set this with state or a ref will product an incorrect value.
      textAreaRef.current.style.height = scrollHeight + "px";
    }
  }, [textAreaRef, value]);
};

export default useAutosizeTextArea;



---
File: /CopilotKit/packages/react-textarea/src/hooks/index.ts
---

export {};



---
File: /CopilotKit/packages/react-textarea/src/lib/slatejs-edits/add-autocompletions.ts
---

import { BasePoint, Transforms } from "slate";
import { CustomEditor } from "../../types/base/custom-editor";

export function addAutocompletionsToEditor(
  editor: CustomEditor,
  newSuggestion: string,
  point: BasePoint,
) {
  const editorPosition = editor.selection;

  Transforms.insertNodes(
    editor,
    [
      {
        type: "suggestion",
        inline: true,
        content: newSuggestion,
        children: [{ text: "" }],
      },
    ],
    {
      at: point,
    },
  );

  // restore cursor position
  if (editorPosition) {
    editor.selection = editorPosition;
  }
}



---
File: /CopilotKit/packages/react-textarea/src/lib/slatejs-edits/clear-autocompletions.ts
---

import { Element, Node, Path, Transforms } from "slate";
import { CustomEditor } from "../../types/base/custom-editor";

export function clearAutocompletionsFromEditor(editor: CustomEditor) {
  // clear previous suggestion
  const paths: Path[] = [];
  for (const [node, path] of Node.nodes(editor)) {
    if (Element.isElement(node) && node.type === "suggestion") {
      paths.push(path);
    }
  }
  for (const path of paths) {
    try {
      Transforms.removeNodes(editor, { at: path });
    } catch (e) {
      console.log("CopilotTextarea.clearAutocompletionsFromEditor: error removing node", e);
    }
  }
}



---
File: /CopilotKit/packages/react-textarea/src/lib/slatejs-edits/replace-text.ts
---

import { Editor, Transforms } from "slate";

export function replaceEditorText(editor: Editor, newText: string) {
  // clear all previous text
  Transforms.delete(editor, {
    at: {
      anchor: Editor.start(editor, []),
      focus: Editor.end(editor, []),
    },
  });

  // insert new text
  if (newText && newText !== "") {
    // don't insert empty text - results in strange visual behavior
    Transforms.insertNodes(
      editor,
      [
        {
          type: "paragraph",
          children: [{ text: newText }],
        },
      ],
      {
        at: [0],
      },
    );
  }
}



---
File: /CopilotKit/packages/react-textarea/src/lib/slatejs-edits/with-partial-history.ts
---

import { Editor, Operation, Path, Range, Transforms } from "slate";
import { HistoryEditor } from "slate-history";

// Copy-pasted from `https://github.com/ianstormtaylor/slate/blob/main/packages/slate-history/src/with-history.ts`
// With one exception: the `shouldSave` function is passed in as an argument to `withPartialHistory` instead of being hardcoded
export type ShouldSaveToHistory = (op: Operation, prev: Operation | undefined) => boolean;

export const withPartialHistory = <T extends Editor>(
  editor: T,
  shouldSave: ShouldSaveToHistory,
) => {
  const e = editor as T & HistoryEditor;
  const { apply } = e;
  e.history = { undos: [], redos: [] };

  e.redo = () => {
    const { history } = e;
    const { redos } = history;

    if (redos.length > 0) {
      const batch = redos[redos.length - 1];

      if (batch.selectionBefore) {
        Transforms.setSelection(e, batch.selectionBefore);
      }

      HistoryEditor.withoutSaving(e, () => {
        Editor.withoutNormalizing(e, () => {
          for (const op of batch.operations) {
            e.apply(op);
          }
        });
      });

      history.redos.pop();
      e.writeHistory("undos", batch);
    }
  };

  e.undo = () => {
    const { history } = e;
    const { undos } = history;

    if (undos.length > 0) {
      const batch = undos[undos.length - 1];

      HistoryEditor.withoutSaving(e, () => {
        Editor.withoutNormalizing(e, () => {
          const inverseOps = batch.operations.map(Operation.inverse).reverse();

          for (const op of inverseOps) {
            e.apply(op);
          }
          if (batch.selectionBefore) {
            Transforms.setSelection(e, batch.selectionBefore);
          }
        });
      });

      e.writeHistory("redos", batch);
      history.undos.pop();
    }
  };

  e.apply = (op: Operation) => {
    const { operations, history } = e;
    const { undos } = history;
    const lastBatch = undos[undos.length - 1];
    const lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
    let save = HistoryEditor.isSaving(e);
    let merge = HistoryEditor.isMerging(e);

    if (save == null) {
      save = shouldSave(op, lastOp);
    }

    if (save) {
      if (merge == null) {
        if (lastBatch == null) {
          merge = false;
        } else if (operations.length !== 0) {
          merge = true;
        } else {
          merge = shouldMerge(op, lastOp);
        }
      }

      if (lastBatch && merge) {
        lastBatch.operations.push(op);
      } else {
        const batch = {
          operations: [op],
          selectionBefore: e.selection,
        };
        e.writeHistory("undos", batch);
      }

      while (undos.length > 100) {
        undos.shift();
      }

      history.redos = [];
    }

    apply(op);
  };

  e.writeHistory = (stack: "undos" | "redos", batch: any) => {
    e.history[stack].push(batch);
  };

  return e;
};

/**
 * Check whether to merge an operation into the previous operation.
 */

const shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {
  if (
    prev &&
    op.type === "insert_text" &&
    prev.type === "insert_text" &&
    op.offset === prev.offset + prev.text.length &&
    Path.equals(op.path, prev.path)
  ) {
    return true;
  }

  if (
    prev &&
    op.type === "remove_text" &&
    prev.type === "remove_text" &&
    op.offset + op.text.length === prev.offset &&
    Path.equals(op.path, prev.path)
  ) {
    return true;
  }

  return false;
};

export const defaultShouldSave = (op: Operation, prev: Operation | undefined): boolean => {
  if (op.type === "set_selection") {
    return false;
  }

  return true;
};



---
File: /CopilotKit/packages/react-textarea/src/lib/debouncer.ts
---

export type AsyncFunction<T extends any[]> = (...args: [...T, AbortSignal]) => Promise<void>;

export class Debouncer<T extends any[]> {
  private timeoutId?: ReturnType<typeof setTimeout>;
  private activeAbortController?: AbortController;

  constructor(private wait: number) {}

  debounce = async (func: AsyncFunction<T>, ...args: T) => {
    // Abort the previous promise immediately
    this.cancel();

    this.timeoutId = setTimeout(async () => {
      try {
        this.activeAbortController = new AbortController();

        // Pass the signal to the async function, assuming it supports it
        await func(...args, this.activeAbortController.signal);

        this.activeAbortController = undefined;
      } catch (error) {}
    }, this.wait);
  };

  cancel = () => {
    if (this.activeAbortController) {
      this.activeAbortController.abort();
      this.activeAbortController = undefined;
    }

    if (this.timeoutId !== undefined) {
      clearTimeout(this.timeoutId);
      this.timeoutId = undefined;
    }
  };
}



---
File: /CopilotKit/packages/react-textarea/src/lib/editor-to-text.ts
---

import { BaseEditor, Descendant, Element } from "slate";
import { HistoryEditor } from "slate-history";
import { ReactEditor } from "slate-react";
import { SuggestionAwareText } from "../types/base/custom-editor";

function nodeChildrenToTextComponents(
  editor: BaseEditor & ReactEditor & HistoryEditor,
  nodes: Descendant[],
): SuggestionAwareText[] {
  // find inlineable elements
  const indeciesOfInlineElements = new Set(
    nodes
      .map((node, index) => {
        if (Element.isElement(node) && editor.isInline(node)) {
          return index;
        }
        return -1;
      })
      .filter((index) => index !== -1),
  );

  // ignorable elements = inline elements,
  // or neighbors of inline elements that are {text: ""}
  const nonIgnorableItems = nodes.filter((node, index) => {
    const isInline = indeciesOfInlineElements.has(index);
    if (isInline) {
      return false;
    }

    const isNeighbourOfInline =
      indeciesOfInlineElements.has(index - 1) || indeciesOfInlineElements.has(index + 1);
    if (isNeighbourOfInline) {
      return (node as any).text !== "";
    }

    return true;
  });

  return nonIgnorableItems
    .map((node) => {
      if (Element.isElement(node)) {
        switch (node.type) {
          case "paragraph":
            return nodeChildrenToTextComponents(editor, node.children);
          case "suggestion":
            return [];
        }
      } else {
        return [node];
      }
    })
    .reduce((acc, val) => acc.concat(val), []);
}

export const editorToText = (editor: BaseEditor & ReactEditor & HistoryEditor) => {
  const flattened = nodeChildrenToTextComponents(editor, editor.children);

  const text = flattened.map((textComponent) => textComponent.text).join("\n");

  return text;
};



---
File: /CopilotKit/packages/react-textarea/src/lib/get-text-around-cursor.ts
---

import { Editor, Node, Path, Range, Text, Element, BasePoint, BaseRange, Point } from "slate";
import { EditorAutocompleteState } from "../types/base/editor-autocomplete-state";

export interface EditorTextState {
  selection: BaseRange;

  textBeforeCursor: string;
  selectedText: string;
  textAfterCursor: string;
}

export function getTextAroundCollapsedCursor(editor: Editor): EditorAutocompleteState | null {
  const { selection } = editor;
  if (!selection || !Range.isCollapsed(selection)) {
    return null;
  }

  const cursorPoint = selection.anchor;

  // Create two ranges: one before the anchor and one after
  const beforeRange: Range = {
    anchor: Editor.start(editor, []),
    focus: cursorPoint,
  };
  const afterRange: Range = {
    anchor: cursorPoint,
    focus: Editor.end(editor, []),
  };

  // Extract text for these ranges
  const before = extractTextWithNewlines(editor, beforeRange);
  const after = extractTextWithNewlines(editor, afterRange);

  return {
    cursorPoint: cursorPoint,
    textBeforeCursor: before,
    textAfterCursor: after,
  };
}

export function getTextAroundSelection(editor: Editor): EditorTextState | null {
  const { selection } = editor;
  if (!selection) {
    return null;
  }

  const wellOrderedSelection = wellOrderedRange(selection);

  // Create two ranges: one before the anchor and one after
  const beforeRange: Range = {
    anchor: Editor.start(editor, []),
    focus: wellOrderedSelection.anchor,
  };
  const afterRange: Range = {
    anchor: wellOrderedSelection.focus,
    focus: Editor.end(editor, []),
  };

  // Extract text for these ranges
  const before = extractTextWithNewlines(editor, beforeRange);
  const after = extractTextWithNewlines(editor, afterRange);
  const selectedText = extractTextWithNewlines(editor, wellOrderedSelection);

  return {
    selection: wellOrderedSelection,
    textBeforeCursor: before,
    selectedText,
    textAfterCursor: after,
  };
}

export function getFullEditorTextWithNewlines(editor: Editor): string {
  const fullDocumentRange: Range = {
    anchor: Editor.start(editor, []),
    focus: Editor.end(editor, []),
  };
  return extractTextWithNewlines(editor, fullDocumentRange);
}

// Helper function to extract text with newlines
export function extractTextWithNewlines(editor: Editor, range: Range): string {
  const voids = false;
  const [start, end] = Range.edges(range);
  let text = "";
  let lastBlock: Node | null = null;

  for (const [node, path] of Editor.nodes(editor, {
    at: range,
    match: Text.isText,
    voids,
  })) {
    let t = node.text;

    // Determine the parent block of the current text node
    const [block] = Editor.above(editor, {
      at: path,
      match: (n) => Element.isElement(n) && n.type === "paragraph",
    }) || [null];

    // If we encounter a new block, prepend a newline
    if (lastBlock !== block && block) {
      // check that lastBlock is not null to avoid adding a newline at the beginning
      if (lastBlock) {
        text += "\n";
      }
      lastBlock = block;
    }

    if (Path.equals(path, end.path)) {
      t = t.slice(0, end.offset);
    }

    if (Path.equals(path, start.path)) {
      t = t.slice(start.offset);
    }

    text += t;
  }

  return text;
}

function wellOrderedRange(range: BaseRange): BaseRange {
  const { anchor, focus } = range;
  // if anchor is before focus, return range as is
  if (Point.isBefore(anchor, focus)) {
    return range;
  }

  // if focus is before anchor, return range with anchor and focus swapped
  return {
    anchor: focus,
    focus: anchor,
  };
}



---
File: /CopilotKit/packages/react-textarea/src/lib/retry.tsx
---

export function retry<T>(
  fn: () => Promise<T>,
  retriesLeft: number = 2,
  interval: number = 200,
  backoff: number = 1.5,
): Promise<T> {
  return new Promise((resolve, reject) => {
    fn()
      .then(resolve)
      .catch((error) => {
        if (retriesLeft === 1) {
          reject(error);
          return;
        }

        setTimeout(() => {
          retry(fn, retriesLeft - 1, interval * backoff, backoff)
            .then(resolve)
            .catch(reject);
        }, interval);
      });
  });
}



---
File: /CopilotKit/packages/react-textarea/src/lib/stream-promise-flatten.ts
---

/**
 * Flatten a promise of a stream, into a stream.
 *
 * Useful because a stream already includes the notion of async value delivery,
 * so it often makes sense to simply await the values rather than the generator of the values.
 *
 * @param {Promise<ReadableStream<A>>} promise - The promise to flatten.
 * @returns {ReadableStream<A>} - The flattened stream.
 */

export function streamPromiseFlatten<A>(promise: Promise<ReadableStream<A>>): ReadableStream<A> {
  return new ReadableStream<A>({
    async start(controller) {
      try {
        const stream = await promise;
        const reader = stream.getReader();

        while (true) {
          const { done, value } = await reader.read();

          if (done) {
            controller.close();
            return;
          }

          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
  });
}



---
File: /CopilotKit/packages/react-textarea/src/lib/utils.test.ts
---

import * as utils from "./utils";

describe("emptyTest", () => {
  it("should be truthy", () => {
    expect(true).toBeTruthy();
  });
});



---
File: /CopilotKit/packages/react-textarea/src/lib/utils.ts
---

import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export async function fetcher<JSON = any>(input: RequestInfo, init?: RequestInit): Promise<JSON> {
  const res = await fetch(input, init);

  if (!res.ok) {
    const json = await res.json();
    if (json.error) {
      const error = new Error(json.error) as Error & {
        status: number;
      };
      error.status = res.status;
      throw error;
    } else {
      throw new Error("An unexpected error occurred");
    }
  }

  return res.json();
}

export function formatDate(input: string | number | Date): string {
  const date = new Date(input);
  return date.toLocaleDateString("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
  });
}

export const arraysAreEqual = (arr1: number[], arr2: number[]): boolean =>
  arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);

export function nullableCompatibleEqualityCheck<T>(
  naiveEqualityCheck: (a: T, b: T) => boolean,
  a: T | null | undefined,
  b: T | null | undefined,
): boolean {
  if (a === null || a === undefined || b === null || b === undefined) {
    return a === b;
  }

  return naiveEqualityCheck(a, b);
}



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/subtypes/make-system-prompt.ts
---

export type MakeSystemPrompt = (textareaPurpose: string, contextString: string) => string;



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/autosuggestions-config-user-specified.tsx
---

import { AutosuggestionsConfig } from ".";
import { InsertionsApiConfig } from "./insertions-api-config";
import { SuggestionsApiConfig } from "./suggestions-api-config";

// Mostly mirrors a partial SuggestionsApiConfig, but with some fields MANDATORY.
export interface SuggestionsApiConfigUserSpecified extends Partial<SuggestionsApiConfig> {}

// Mostly mirrors a partial InsertionsApiConfig, but with some fields MANDATORY.
export interface InsertionsApiConfigUserSpecified extends Partial<InsertionsApiConfig> {}

// Mostly mirrors a partial AutosuggestionsConfig, but with some fields MANDATORY.
export interface AutosuggestionsConfigUserSpecified
  extends Partial<Omit<AutosuggestionsConfig, "chatApiConfigs" | "textareaPurpose">> {
  textareaPurpose: string; // the user MUST specify textareaPurpose - it's not optional
  chatApiConfigs: {
    suggestionsApiConfig?: SuggestionsApiConfigUserSpecified;
    insertionApiConfig?: InsertionsApiConfigUserSpecified;
  };
}



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/autosuggestions-config.tsx
---

import { BaseAutosuggestionsConfig, defaultBaseAutosuggestionsConfig } from "../base";
import { SuggestionsApiConfig, defaultSuggestionsApiConfig } from "./suggestions-api-config";
import { InsertionsApiConfig, defaultInsertionsApiConfig } from "./insertions-api-config";
import { EditingApiConfig, defaultEditingApiConfig } from "./editing-api-config";
import { defaultCopilotContextCategories } from "@copilotkit/react-core";

// Like the base autosuggestions config, with 2 additional fields:
// 1. contextCategories: string[] | undefined;
// 2. instead of apiConfigs, we have chatApiConfigs: a higher-level abstraction that uses a ChatGPT-like API endpoint.
export interface AutosuggestionsConfig extends Omit<BaseAutosuggestionsConfig, "apiConfig"> {
  contextCategories: string[];
  chatApiConfigs: {
    suggestionsApiConfig: SuggestionsApiConfig;
    insertionApiConfig: InsertionsApiConfig;
    editingApiConfig: EditingApiConfig;
  };
}

export const defaultAutosuggestionsConfig: Omit<
  AutosuggestionsConfig,
  "textareaPurpose" | "apiEndpoint"
> = {
  ...defaultBaseAutosuggestionsConfig,
  contextCategories: defaultCopilotContextCategories,
  chatApiConfigs: {
    suggestionsApiConfig: defaultSuggestionsApiConfig,
    insertionApiConfig: defaultInsertionsApiConfig,
    editingApiConfig: defaultEditingApiConfig,
  },
};



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/editing-api-config.tsx
---

import { Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { MakeSystemPrompt } from "./subtypes/make-system-prompt";

export interface EditingApiConfig {
  makeSystemPrompt: MakeSystemPrompt;
  fewShotMessages: Message[];
  forwardedParams: { [key: string]: any } | undefined;
}

export const defaultEditingMakeSystemPrompt: MakeSystemPrompt = (
  textareaPurpose,
  contextString,
) => {
  return `You are a versatile writing assistant helping the user edit a portion of their text.
  
The user is writing some text.
The purpose is: \"${textareaPurpose}\"

The following external context is also provided. Use it when relevant.
\`\`\`
${contextString}
\`\`\`

The user has provided you with a PROMPT for EDITING a PORTION of the text. 
Your job is to come up with a new EDITED version OF THE SEGMENT IN QUESTION - AS BEST YOU CAN.
Only rewrite the portion of the text that the user has marked as "TextToEdit"!!!

Adjust yourself to the user's style and implied intent.

The conversation will be structured as follows:
<TextBeforeCursor>
<TextToEdit>
<TextAfterCursor>
<EditingPrompt>

<YourEditSuggestion>
`;
};

export const defaultEditingFewShotMessages: Message[] = [
  new TextMessage({
    role: Role.User,
    content:
      "<TextBeforeCursor>This morning I woke up and went straight to the grocery store. </TextBeforeCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextToEdit>While I was there I picked up some apples, oranges, and bananas. </TextToEdit>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>The grocery store was having a sale on fruit, so I decided to stock up.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content: "<EditingPrompt>I also bought a big watermelon</EditingPrompt>",
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      "While I was there I picked up some apples, oranges, and bananas, and a big watermelon.",
  }),

  new TextMessage({
    role: Role.User,
    content:
      "<TextBeforeCursor>Yesterday, I spent the afternoon working on my new project.</TextBeforeCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content: "<TextToEdit>It's quite challenging and requires a lot of focus.</TextToEdit>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>I'm really excited about the potential outcomes of this project.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<EditingPrompt>emphasize the complexity and my enthusiasm for the project</EditingPrompt>",
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      "It's a highly complex task that demands intense concentration, but I'm incredibly enthusiastic about the promising prospects of this project.",
  }),
];

export const defaultEditingApiConfig: EditingApiConfig = {
  makeSystemPrompt: defaultEditingMakeSystemPrompt,
  fewShotMessages: defaultEditingFewShotMessages,
  forwardedParams: undefined,
};



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/index.ts
---

export { defaultAutosuggestionsConfig } from "./autosuggestions-config";
export type { AutosuggestionsConfig } from "./autosuggestions-config";

export type { MakeSystemPrompt } from "./subtypes/make-system-prompt";

export type { AutosuggestionsConfigUserSpecified } from "./autosuggestions-config-user-specified";
export type { SuggestionsApiConfigUserSpecified } from "./autosuggestions-config-user-specified";
export type { InsertionsApiConfigUserSpecified } from "./autosuggestions-config-user-specified";



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/insertions-api-config.tsx
---

import { Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { MakeSystemPrompt } from "./subtypes/make-system-prompt";

export interface InsertionsApiConfig {
  makeSystemPrompt: MakeSystemPrompt;
  fewShotMessages: Message[];
  forwardedParams: { [key: string]: any } | undefined;
}

export const defaultInsertionsMakeSystemPrompt: MakeSystemPrompt = (
  textareaPurpose,
  contextString,
) => {
  return `You are a versatile writing assistant helping the user insert new text into their existing work.
  
The user is writing some text.
The purpose is: \"${textareaPurpose}\"

The following external context is also provided. Use it to inform your suggestions when relevant!!!
\`\`\`
${contextString}
\`\`\`

The user will provide you with a prompt for an INSERTION into the text they are writing. 
Your job is to come up with an INSERTION into the text that the user would like to use, AS BEST YOU CAN.
Only insert a SHORT segment. Usually 1 sentence, or at most 1 paragraph.

Adjust yourself to the user's style and implied intent.


The user will provide the text before and after the cursor, as well as the INSERTION prompt. You should use this to infer the best relevant insertion.
The conversation will be structured as follows:
<TextAfterCursor>
<TextBeforeCursor>
<InsertionPrompt>

<YourInsertionSuggestion>
`;
};

export const defaultInsertionsFewShotMessages: Message[] = [
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>While I was there I also picked up some apples, oranges, and bananas.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextBeforeCursor>This morning I woke up and went straight to the grocery store.</TextBeforeCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content: "<InsertionPrompt>I bought a big watermelon</InsertionPrompt>",
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      "When I arrived I went straight to the produce section and picked out a big watermelon.",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>and (iii) to the appointment of the Equityholders' Representative pursuant to Section 10.7 of the Merger Agreement and to the provisions thereof.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      '<TextBeforeCursor>The Optionholder, in the Optionholder\'s capacity as a holder of vested Options, hereby irrevocably and unconditionally agrees: (i) that the Optionholder shall be deemed an "Equityholder" under the Merger Agreement and shall be entitled to the rights and benefits, and subject to the obligations, of an "Equityholder" thereunder;</TextBeforeCursor>',
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<InsertionPrompt>add section about the optionholder's pro rata share</InsertionPrompt>",
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      ' (ii) that, for purposes of this Agreement and the Merger Agreement, the applicable percentage set forth opposite the name of the Optionholder in the Distribution Waterfall shall be such the Optionholder\'s "Pro Rata Share"; ',
  }),
];

export const defaultInsertionsApiConfig: InsertionsApiConfig = {
  makeSystemPrompt: defaultInsertionsMakeSystemPrompt,
  fewShotMessages: defaultInsertionsFewShotMessages,
  forwardedParams: undefined,
};



---
File: /CopilotKit/packages/react-textarea/src/types/autosuggestions-config/suggestions-api-config.tsx
---

import { Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { MakeSystemPrompt } from "./subtypes/make-system-prompt";

export interface SuggestionsApiConfig {
  makeSystemPrompt: MakeSystemPrompt;
  fewShotMessages: Message[];
  maxTokens?: number;
  stop?: string[];
}

export const defaultSuggestionsMakeSystemPrompt: MakeSystemPrompt = (
  textareaPurpose,
  contextString,
) => {
  return `You are a versatile writing assistant.
  
The user is writing some text.
The purpose is: \"${textareaPurpose}\"

Your job is to guess what the user will write next AS BEST YOU CAN.
Only guess a SHORT distance ahead. Usually 1 sentence, or at most 1 paragraph.

Adjust yourself to the user's style and implied intent.

The user will provide both the text before and after the cursor. You should use this to infer what the user is likely to write next.
<TextAfterCursor>
<TextBeforeCursor>
<YourSuggestion>

If we need to add a whitespace character to the suggested text, make sure to explicitly add it in.

The following external context is also provided. Use it to help you make better suggestions!!!
\`\`\`
${contextString}
\`\`\`
`;
};

export const defaultSuggestionsFewShotMessages: Message[] = [
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>While I was there I also picked up some apples, oranges, and bananas.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content: "This morning I woke up and went straight to the grocery store.",
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      " When I arrived I went straight to the produce section and picked out a big watermelon. ",
  }),
  new TextMessage({
    role: Role.User,
    content:
      "<TextAfterCursor>and (iii) to the appointment of the Equityholders' Representative pursuant to Section 10.7 of the Merger Agreement and to the provisions thereof.</TextAfterCursor>",
  }),
  new TextMessage({
    role: Role.User,
    content:
      '<TextBeforeCursor>The Optionholder, in the Optionholder\'s capacity as a holder of vested Options, hereby irrevocably and unconditionally agrees: (i) that the Optionholder shall be deemed an "Equityholder" under the Merger Agreement and shall be entitled to the rights and benefits, and subject to the obligations, of an "Equityholder" thereunder;</TextBeforeCursor>',
  }),
  new TextMessage({
    role: Role.Assistant,
    content:
      ' (ii) that, for purposes of this Agreement and the Merger Agreement, the applicable percentage set forth opposite the name of the Optionholder in the Distribution Waterfall shall be such the Optionholder\'s "Pro Rata Share"; ',
  }),
];

export const defaultSuggestionsApiConfig: SuggestionsApiConfig = {
  makeSystemPrompt: defaultSuggestionsMakeSystemPrompt,
  fewShotMessages: defaultSuggestionsFewShotMessages,
};



---
File: /CopilotKit/packages/react-textarea/src/types/base/autosuggestion-state.ts
---

import { BasePoint } from "slate";

export interface AutosuggestionState {
  text: string;
  point: BasePoint;
}



---
File: /CopilotKit/packages/react-textarea/src/types/base/autosuggestions-bare-function.ts
---

import { DocumentPointer } from "@copilotkit/react-core";

export interface InsertionEditorState {
  textBeforeCursor: string;
  textAfterCursor: string;
}

export interface EditingEditorState extends InsertionEditorState {
  selectedText: string;
}

export type AutosuggestionsBareFunction = (
  editorState: InsertionEditorState,
  abortSignal: AbortSignal,
) => Promise<string>;

export type Generator_InsertionOrEditingSuggestion = (
  editorState: EditingEditorState,
  prompt: string,
  documents: DocumentPointer[],
  abortSignal: AbortSignal,
) => Promise<ReadableStream<string>>;

export interface InsertionEditorApiConfig {
  insertionOrEditingFunction: Generator_InsertionOrEditingSuggestion;
}

export interface BaseCopilotTextareaApiConfig extends InsertionEditorApiConfig {
  autosuggestionsFunction: AutosuggestionsBareFunction;
}



---
File: /CopilotKit/packages/react-textarea/src/types/base/base-autosuggestions-config.tsx
---

import { BaseCopilotTextareaApiConfig } from "./autosuggestions-bare-function";
import { defaultCopilotContextCategories } from "@copilotkit/react-core";

/**
 * @interface BaseAutosuggestionsConfig
 *
 * @property {string} textareaPurpose - The purpose of the textarea. This is used to guide the autosuggestions.
 *
 * @property {string[]} contextCategories - The categories of context to consider when providing autosuggestions.
 *
 * @property {number} debounceTime - The amount of time (in milliseconds) to wait before triggering autosuggestions after the user has stopped typing.
 *
 * @property {BaseCopilotTextareaApiConfig} apiConfig - The configuration for the API that provides the autosuggestions.
 *
 * @property {boolean} disableWhenEmpty - Whether to disable autosuggestions when the textarea is empty.
 *
 * @property {boolean} disabled - Whether to disable autosuggestions entirely.
 *
 * @property {boolean} temporarilyDisableWhenMovingCursorWithoutChangingText - Whether to temporarily disable autosuggestions when the user moves the cursor without changing the text.
 *
 * @property {(event: React.KeyboardEvent<HTMLDivElement>) => boolean} shouldAcceptAutosuggestionOnKeyPress - A function that determines whether to accept the current autosuggestion based on a key press event. By default, the Tab key is used to accept the autosuggestion. Example code:
 *
 * ```typescript
 * const defaultShouldAcceptAutosuggestionOnKeyPress =  (event: React.KeyboardEvent<HTMLDivElement>) => {
 *   // if tab, accept the autosuggestion
 *   if (event.key === "Tab") {
 *     return true;
 *   }
 *   return false;
 * }
 * ```
 *
 * @property {(event: React.TouchEvent<HTMLDivElement>) => boolean} shouldAcceptAutosuggestionOnTouch - A function that determines whether to accept the current autosuggestion based on a mobile touch event. By default, the touching the end of a suggestion will accept it. Example code:
 *
 * ```typescript
 * const shouldAcceptAutosuggestionOnTouch =  (event: React.TouchEvent<HTMLDivElement>) => {
 *   // if tab, accept the autosuggestion
 *   if (event.type === "touchstart") {
 *     return true;
 *   }
 *   return false;
 * }
 * ```
 *
 * @property {(event: React.KeyboardEvent<HTMLDivElement>) => boolean} shouldToggleHoveringEditorOnKeyPress - A function that determines whether to toggle the hovering editor based on a key press event. By default, the Command + K key combination is used to toggle the hovering editor. Example code:
 *
 * ```typescript
 * const defaultShouldToggleHoveringEditorOnKeyPress =  (event: React.KeyboardEvent<HTMLDivElement>) => {
 *   // if command-k, toggle the hovering editor
 *   if (event.key === "k" && event.metaKey) {
 *     return true;
 *   }
 *   return false;
 * }
 * ```
 */
export interface BaseAutosuggestionsConfig {
  textareaPurpose: string;
  contextCategories: string[];
  debounceTime: number;
  apiConfig: BaseCopilotTextareaApiConfig;

  disableWhenEmpty: boolean;
  disabled: boolean;
  temporarilyDisableWhenMovingCursorWithoutChangingText: boolean;
  shouldAcceptAutosuggestionOnKeyPress: (event: React.KeyboardEvent<HTMLDivElement>) => boolean;
  shouldAcceptAutosuggestionOnTouch: (event: React.TouchEvent<HTMLDivElement>) => boolean;
  shouldToggleHoveringEditorOnKeyPress: (
    event: React.KeyboardEvent<HTMLDivElement>,
    shortcut: string,
  ) => boolean;
}

// by default, command-k toggles the hovering editor
const defaultShouldToggleHoveringEditorOnKeyPress = (
  event: React.KeyboardEvent<HTMLDivElement>,
  shortcut: string,
) => {
  // if command-k, toggle the hovering editor
  if (event.key === shortcut && event.metaKey) {
    return true;
  }
  return false;
};

const defaultShouldAcceptAutosuggestionOnKeyPress = (
  event: React.KeyboardEvent<HTMLDivElement>,
) => {
  // if tab, accept the autosuggestion
  if (event.key === "Tab") {
    return true;
  }
  return false;
};

const defaultShouldAcceptAutosuggestionOnTouch = () => false;

/**
 * Default configuration for the BaseAutosuggestions.
 *
 * @property {number} debounceTime - The amount of time to wait before triggering the autosuggestions API call.
 * @property {string[]} contextCategories - The categories to use for context when making the autosuggestions API call.
 * @property {boolean} disableWhenEmpty - Whether to disable the autosuggestions when the textarea is empty.
 * @property {boolean} disabled - Whether to disable the autosuggestions feature entirely.
 * @property {boolean} temporarilyDisableWhenMovingCursorWithoutChangingText - Whether to temporarily disable the autosuggestions when the cursor is moved without changing the text.
 * @property {(event: React.KeyboardEvent<HTMLDivElement>) => boolean} shouldToggleHoveringEditorOnKeyPress - A function that determines whether to toggle the hovering editor based on a key press event.
 * @property {(event: React.KeyboardEvent<HTMLDivElement>) => boolean} shouldAcceptAutosuggestionOnKeyPress - A function that determines whether to accept the autosuggestion based on a key press event.
 * @property {() => boolean} defaultShouldAcceptAutosuggestionOnTouch - A function that determines whether to accept the autosuggestion based on a mobile touch event.
 */

export const defaultBaseAutosuggestionsConfig: Omit<
  BaseAutosuggestionsConfig,
  "textareaPurpose" | "apiConfig"
> = {
  debounceTime: 250,
  contextCategories: defaultCopilotContextCategories,
  disableWhenEmpty: true,
  disabled: false,
  temporarilyDisableWhenMovingCursorWithoutChangingText: true,
  shouldToggleHoveringEditorOnKeyPress: defaultShouldToggleHoveringEditorOnKeyPress,
  shouldAcceptAutosuggestionOnKeyPress: defaultShouldAcceptAutosuggestionOnKeyPress,
  shouldAcceptAutosuggestionOnTouch: defaultShouldAcceptAutosuggestionOnTouch,
};



---
File: /CopilotKit/packages/react-textarea/src/types/base/base-copilot-textarea-props.tsx
---

import { TextareaHTMLAttributes } from "react";
import { BaseAutosuggestionsConfig } from ".";
import { BaseCopilotTextareaApiConfig } from "./autosuggestions-bare-function";

/**
 * `BaseCopilotTextareaProps` defines the properties for the `BaseCopilotTextarea` component.
 */
export interface BaseCopilotTextareaProps
  extends Omit<TextareaHTMLAttributes<HTMLDivElement>, "onChange"> {
  /**
   * Determines whether the CopilotKit branding should be disabled. Default is `false`.
   */
  disableBranding?: boolean;

  /**
   * Specifies the CSS styles to apply to the placeholder text.
   */
  placeholderStyle?: React.CSSProperties;

  /**
   * Specifies the CSS styles to apply to the suggestions list.
   */
  suggestionsStyle?: React.CSSProperties;

  /**
   * A class name to apply to the editor popover window.
   */
  hoverMenuClassname?: string;

  /**
   * The initial value of the textarea. Can be controlled via `onValueChange`.
   */
  value?: string;

  /**
   * Callback invoked when the value of the textarea changes.
   */
  onValueChange?: (value: string) => void;

  /**
   * Callback invoked when a `change` event is triggered on the textarea element.
   */
  onChange?: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;

  /**
   * The shortcut to use to open the editor popover window. Default is `"Cmd-k"`.
   */
  shortcut?: string;

  /**
   * Configuration settings for the autosuggestions feature.
   * Includes a mandatory `textareaPurpose` to guide the autosuggestions.
   */
  baseAutosuggestionsConfig: Partial<BaseAutosuggestionsConfig> & {
    textareaPurpose: string;
    apiConfig: BaseCopilotTextareaApiConfig;
  };
}



---
File: /CopilotKit/packages/react-textarea/src/types/base/custom-editor.tsx
---

import { BaseEditor } from "slate";
import { ReactEditor } from "slate-react";
import { HistoryEditor } from "slate-history";

export type CustomEditor = BaseEditor & ReactEditor & HistoryEditor;

export type ParagraphElement = {
  type: "paragraph";
  children: CustomText[];
};

export type SuggestionElement = {
  type: "suggestion";
  inline: boolean;
  content: string;
  children: CustomText[];
};

export type CustomElement = ParagraphElement | SuggestionElement;
export type SuggestionAwareText = { text: string };
export type CustomText = SuggestionAwareText;

declare module "slate" {
  interface CustomTypes {
    Editor: CustomEditor;
    Element: CustomElement;
    Text: CustomText;
  }
}



---
File: /CopilotKit/packages/react-textarea/src/types/base/editor-autocomplete-state.ts
---

import { BasePoint } from "slate";
import { arraysAreEqual } from "../../lib/utils";

export interface EditorAutocompleteState {
  cursorPoint: BasePoint;
  textBeforeCursor: string;
  textAfterCursor: string;
}

export function areEqual_autocompleteState(
  prev: EditorAutocompleteState,
  next: EditorAutocompleteState,
) {
  return (
    prev.cursorPoint.offset === next.cursorPoint.offset &&
    arraysAreEqual(prev.cursorPoint.path, next.cursorPoint.path) &&
    prev.textBeforeCursor === next.textBeforeCursor &&
    prev.textAfterCursor === next.textAfterCursor
  );
}



---
File: /CopilotKit/packages/react-textarea/src/types/base/index.ts
---

export { defaultBaseAutosuggestionsConfig } from "./base-autosuggestions-config";

export type { AutosuggestionsBareFunction } from "./autosuggestions-bare-function";
export type { BaseAutosuggestionsConfig } from "./base-autosuggestions-config";

export type { BaseCopilotTextareaProps } from "./base-copilot-textarea-props";



---
File: /CopilotKit/packages/react-textarea/src/types/html-copilot-textarea-element.ts
---

export interface HTMLCopilotTextAreaElement extends HTMLElement {
  value: string;
  focus: () => void;
  blur: () => void;
}



---
File: /CopilotKit/packages/react-textarea/src/types/index.ts
---

export * from "./base";
export * from "./html-copilot-textarea-element";
export * from "./autosuggestions-config";



---
File: /CopilotKit/packages/react-textarea/src/index.tsx
---

"use client";
import "./styles.css";

export * from "./components";
export * from "./context";
export * from "./hooks";
export * from "./types";



---
File: /CopilotKit/packages/react-textarea/src/styles.css
---

@import url("material-icons/iconfont/material-icons.css");

@tailwind utilities;



---
File: /CopilotKit/packages/react-textarea/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/react-textarea/postcss.config.js
---

// If you want to use other PostCSS plugins, see the following:
// https://tailwindcss.com/docs/using-with-preprocessors

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
    "postcss-prefix-selector": {
      prefix: ".copilot-kit-textarea-css-scope",
    },
  },
};



---
File: /CopilotKit/packages/react-textarea/tailwind.config.js
---

const sharedConfig = require("tailwind-config/tailwind.config.js");

module.exports = {
  // prefix ui lib classes to avoid conflicting with the app
  // prefix: "ui-",
  mode: "jit",
  presets: [sharedConfig],
  purge: sharedConfig.content, // Use the 'content' from the shared config for purging
};



---
File: /CopilotKit/packages/react-textarea/tsup.config.ts
---

import { defineConfig, Options } from "tsup";

export default defineConfig((options: Options) => ({
  entry: ["src/**/*.{ts,tsx}"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: ["react"],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
  ...options,
}));



---
File: /CopilotKit/packages/react-ui/src/components/chat/messages/RenderActionExecutionMessage.tsx
---

import { ActionExecutionMessage, MessageStatusCode } from "@copilotkit/runtime-client-gql";
import { RenderMessageProps } from "../props";
import { useChatContext } from "../ChatContext";
import { RenderFunctionStatus, useCopilotContext } from "@copilotkit/react-core";

export function RenderActionExecutionMessage(props: RenderMessageProps) {
  const { message, inProgress, index, isCurrentMessage, actionResult } = props;
  const { chatComponentsCache } = useCopilotContext();
  const { icons } = useChatContext();

  if (message instanceof ActionExecutionMessage) {
    if (chatComponentsCache.current !== null && chatComponentsCache.current.actions[message.name]) {
      const render = chatComponentsCache.current.actions[message.name];
      // render a static string
      if (typeof render === "string") {
        // when render is static, we show it only when in progress
        if (isCurrentMessage && inProgress) {
          return (
            <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
              {icons.spinnerIcon} <span className="inProgressLabel">{render}</span>
            </div>
          );
        }
        // Done - silent by default to avoid a series of "done" messages
        else {
          return null;
        }
      }
      // render is a function
      else {
        const args = message.arguments;

        let status: RenderFunctionStatus = "inProgress";

        if (actionResult !== undefined) {
          status = "complete";
        } else if (message.status.code !== MessageStatusCode.Pending) {
          status = "executing";
        }

        try {
          const toRender = render({
            status: status as any,
            args,
            result: actionResult,
          });
          // No result and complete: stay silent
          if (!toRender && status === "complete") {
            return null;
          }
          if (typeof toRender === "string") {
            return (
              <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
                {isCurrentMessage && inProgress && icons.spinnerIcon} {toRender}
              </div>
            );
          } else {
            return (
              <div key={index} className="copilotKitCustomAssistantMessage">
                {toRender}
              </div>
            );
          }
        } catch (e) {
          console.error(`Error executing render function for action ${message.name}: ${e}`);
          return (
            <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
              {isCurrentMessage && inProgress && icons.spinnerIcon}
              <b>❌ Error executing render: {message.name}</b>
              <br />
              {e instanceof Error ? e.message : String(e)}
            </div>
          );
        }
      }
    }
    // No render function found- show the default message
    else if (!inProgress || !isCurrentMessage) {
      // Done - silent by default to avoid a series of "done" messages
      return null;
    } else {
      // In progress
      return (
        <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
          {icons.spinnerIcon}
        </div>
      );
    }
  }
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/messages/RenderAgentStateMessage.tsx
---

import { AgentStateMessage } from "@copilotkit/runtime-client-gql";
import { RenderMessageProps } from "../props";
import { useChatContext } from "../ChatContext";
import { CoagentInChatRenderFunction, useCopilotContext } from "@copilotkit/react-core";

export function RenderAgentStateMessage(props: RenderMessageProps) {
  const { message, inProgress, index, isCurrentMessage } = props;
  const { chatComponentsCache } = useCopilotContext();
  const { icons } = useChatContext();

  if (message instanceof AgentStateMessage) {
    let render: string | CoagentInChatRenderFunction | undefined;

    if (chatComponentsCache.current !== null) {
      render =
        chatComponentsCache.current.coagentActions[`${message.agentName}-${message.nodeName}`] ||
        chatComponentsCache.current.coagentActions[`${message.agentName}-global`];
    }

    if (render) {
      // render a static string
      if (typeof render === "string") {
        // when render is static, we show it only when in progress
        if (isCurrentMessage && inProgress) {
          return (
            <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
              {icons.spinnerIcon} <span className="inProgressLabel">{render}</span>
            </div>
          );
        }
        // Done - silent by default to avoid a series of "done" messages
        else {
          return null;
        }
      }
      // render is a function
      else {
        const state = message.state;

        let status = message.active ? "inProgress" : "complete";

        const toRender = render({
          status: status as any,
          state,
          nodeName: message.nodeName,
        });

        // No result and complete: stay silent
        if (!toRender && status === "complete") {
          return null;
        }

        if (typeof toRender === "string") {
          return (
            <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
              {isCurrentMessage && inProgress && icons.spinnerIcon} {toRender}
            </div>
          );
        } else {
          return (
            <div key={index} className="copilotKitCustomAssistantMessage">
              {toRender}
            </div>
          );
        }
      }
    }
    // No render function found- show the default message
    else if (!inProgress || !isCurrentMessage) {
      // Done - silent by default to avoid a series of "done" messages
      return null;
    } else {
      // In progress
      return (
        <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
          {icons.spinnerIcon}
        </div>
      );
    }
  }
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/messages/RenderResultMessage.tsx
---

import { ResultMessage } from "@copilotkit/runtime-client-gql";
import { RenderMessageProps } from "../props";
import { useChatContext } from "../ChatContext";

export function RenderResultMessage(props: RenderMessageProps) {
  const { message, inProgress, index, isCurrentMessage } = props;
  const { icons } = useChatContext();
  if (message instanceof ResultMessage && inProgress && isCurrentMessage) {
    return (
      <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
        {icons.spinnerIcon}
      </div>
    );
  }
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/messages/RenderTextMessage.tsx
---

import { TextMessage } from "@copilotkit/runtime-client-gql";
import { RenderMessageProps } from "../props";
import { Markdown } from "../Markdown";
import { useChatContext } from "../ChatContext";

export function RenderTextMessage(props: RenderMessageProps) {
  const { message, inProgress, index, isCurrentMessage } = props;
  const { icons } = useChatContext();
  if (message instanceof TextMessage) {
    if (message.role === "user") {
      return (
        <div key={index} className="copilotKitMessage copilotKitUserMessage">
          {message.content}
        </div>
      );
    } else if (message.role == "assistant") {
      return (
        <div key={index} className={`copilotKitMessage copilotKitAssistantMessage`}>
          {isCurrentMessage && inProgress && !message.content ? (
            icons.spinnerIcon
          ) : (
            <Markdown content={message.content} />
          )}
        </div>
      );
    }
  }
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/Button.tsx
---

import { ButtonProps } from "./props";
import { useChatContext } from "./ChatContext";

export const Button = ({}: ButtonProps) => {
  const { open, setOpen, icons } = useChatContext();

  return (
    <div onClick={() => setOpen(!open)}>
      <button
        className={`copilotKitButton ${open ? "open" : ""}`}
        aria-label={open ? "Close Chat" : "Open Chat"}
      >
        <div className="copilotKitButtonIcon copilotKitButtonIconOpen">{icons.openIcon}</div>
        <div className="copilotKitButtonIcon copilotKitButtonIconClose">{icons.closeIcon}</div>
      </button>
    </div>
  );
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Chat.tsx
---

/**
 * <br/>
 * <img src="/images/CopilotChat.gif" width="500" />
 *
 * A chatbot panel component for the CopilotKit framework. The component allows for a high degree
 * of customization through various props and custom CSS.
 *
 * ## Install Dependencies
 *
 * This component is part of the [@copilotkit/react-ui](https://npmjs.com/package/@copilotkit/react-ui) package.
 *
 * ```shell npm2yarn \"@copilotkit/react-ui"\
 * npm install @copilotkit/react-core @copilotkit/react-ui
 * ```
 *
 * ## Usage
 *
 * ```tsx
 * import { CopilotChat } from "@copilotkit/react-ui";
 * import "@copilotkit/react-ui/styles.css";
 *
 * <CopilotChat
 *   labels={{
 *     title: "Your Assistant",
 *     initial: "Hi! 👋 How can I assist you today?",
 *   }}
 * />
 * ```
 *
 * ### Look & Feel
 *
 * By default, CopilotKit components do not have any styles. You can import CopilotKit's stylesheet at the root of your project:
 * ```tsx title="YourRootComponent.tsx"
 * ...
 * import "@copilotkit/react-ui/styles.css"; // [!code highlight]
 *
 * export function YourRootComponent() {
 *   return (
 *     <CopilotKit>
 *       ...
 *     </CopilotKit>
 *   );
 * }
 * ```
 * For more information about how to customize the styles, check out the [Customize Look & Feel](/concepts/customize-look-and-feel) guide.
 */

import {
  ChatContext,
  ChatContextProvider,
  CopilotChatIcons,
  CopilotChatLabels,
} from "./ChatContext";
import { Messages as DefaultMessages } from "./Messages";
import { Input as DefaultInput } from "./Input";
import { ResponseButton as DefaultResponseButton } from "./Response";
import { RenderTextMessage as DefaultRenderTextMessage } from "./messages/RenderTextMessage";
import { RenderActionExecutionMessage as DefaultRenderActionExecutionMessage } from "./messages/RenderActionExecutionMessage";
import { RenderResultMessage as DefaultRenderResultMessage } from "./messages/RenderResultMessage";
import { RenderAgentStateMessage as DefaultRenderAgentStateMessage } from "./messages/RenderAgentStateMessage";
import { Suggestion } from "./Suggestion";
import React, { useEffect, useRef, useState } from "react";
import { SystemMessageFunction, useCopilotChat, useCopilotContext } from "@copilotkit/react-core";
import { reloadSuggestions } from "./Suggestion";
import { CopilotChatSuggestion } from "../../types/suggestions";
import { Message, Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { InputProps, MessagesProps, RenderMessageProps, ResponseButtonProps } from "./props";
import { randomId } from "@copilotkit/shared";

import { CopilotDevConsole } from "../dev-console";

/**
 * Props for CopilotChat component.
 */
export interface CopilotChatProps {
  /**
   * Custom instructions to be added to the system message. Use this property to
   * provide additional context or guidance to the language model, influencing
   * its responses. These instructions can include specific directions,
   * preferences, or criteria that the model should consider when generating
   * its output, thereby tailoring the conversation more precisely to the
   * user's needs or the application's requirements.
   */
  instructions?: string;

  /**
   * A callback that gets called when the in progress state changes.
   */
  onInProgress?: (inProgress: boolean) => void;

  /**
   * A callback that gets called when a new message it submitted.
   */
  onSubmitMessage?: (message: string) => void | Promise<void>;

  /**
   * Icons can be used to set custom icons for the chat window.
   */
  icons?: CopilotChatIcons;

  /**
   * Labels can be used to set custom labels for the chat window.
   */
  labels?: CopilotChatLabels;

  /**
   * A function that takes in context string and instructions and returns
   * the system message to include in the chat request.
   * Use this to completely override the system message, when providing
   * instructions is not enough.
   */
  makeSystemMessage?: SystemMessageFunction;

  /**
   * Whether to show the response button.
   * @default true
   */
  showResponseButton?: boolean;

  /**
   * A custom Messages component to use instead of the default.
   */
  Messages?: React.ComponentType<MessagesProps>;

  /**
   * A custom RenderTextMessage component to use instead of the default.
   */
  RenderTextMessage?: React.ComponentType<RenderMessageProps>;

  /**
   * A custom RenderActionExecutionMessage component to use instead of the default.
   */
  RenderActionExecutionMessage?: React.ComponentType<RenderMessageProps>;

  /**
   * A custom RenderAgentStateMessage component to use instead of the default.
   */
  RenderAgentStateMessage?: React.ComponentType<RenderMessageProps>;

  /**
   * A custom RenderResultMessage component to use instead of the default.
   */
  RenderResultMessage?: React.ComponentType<RenderMessageProps>;

  /**
   * A custom Input component to use instead of the default.
   */
  Input?: React.ComponentType<InputProps>;

  /**
   * A custom ResponseButton component to use instead of the default.
   */
  ResponseButton?: React.ComponentType<ResponseButtonProps>;

  /**
   * A class name to apply to the root element.
   */
  className?: string;

  /**
   * Children to render.
   */
  children?: React.ReactNode;
}

export function CopilotChat({
  instructions,
  onSubmitMessage,
  makeSystemMessage,
  showResponseButton = true,
  onInProgress,
  Messages = DefaultMessages,
  RenderTextMessage = DefaultRenderTextMessage,
  RenderActionExecutionMessage = DefaultRenderActionExecutionMessage,
  RenderAgentStateMessage = DefaultRenderAgentStateMessage,
  RenderResultMessage = DefaultRenderResultMessage,
  Input = DefaultInput,
  ResponseButton = DefaultResponseButton,
  className,
  icons,
  labels,
}: CopilotChatProps) {
  const context = useCopilotContext();

  useEffect(() => {
    context.setChatInstructions(instructions || "");
  }, [instructions]);

  const {
    visibleMessages,
    isLoading,
    currentSuggestions,
    sendMessage,
    stopGeneration,
    reloadMessages,
  } = useCopilotChatLogic(makeSystemMessage, onInProgress, onSubmitMessage);

  const chatContext = React.useContext(ChatContext);
  const isVisible = chatContext ? chatContext.open : true;

  return (
    <WrappedCopilotChat icons={icons} labels={labels} className={className}>
      <CopilotDevConsole />
      <Messages
        RenderTextMessage={RenderTextMessage}
        RenderActionExecutionMessage={RenderActionExecutionMessage}
        RenderAgentStateMessage={RenderAgentStateMessage}
        RenderResultMessage={RenderResultMessage}
        messages={visibleMessages}
        inProgress={isLoading}
      >
        {currentSuggestions.length > 0 && (
          <div>
            <h6>Suggested:</h6>
            <div className="suggestions">
              {currentSuggestions.map((suggestion, index) => (
                <Suggestion
                  key={index}
                  title={suggestion.title}
                  message={suggestion.message}
                  partial={suggestion.partial}
                  className={suggestion.className}
                  onClick={(message) => sendMessage(message)}
                />
              ))}
            </div>
          </div>
        )}
        {showResponseButton && visibleMessages.length > 0 && (
          <ResponseButton
            onClick={isLoading ? stopGeneration : reloadMessages}
            inProgress={isLoading}
          />
        )}
      </Messages>
      <Input inProgress={isLoading} onSend={sendMessage} isVisible={isVisible} />
    </WrappedCopilotChat>
  );
}

export function WrappedCopilotChat({
  children,
  icons,
  labels,
  className,
}: {
  children: React.ReactNode;
  icons?: CopilotChatIcons;
  labels?: CopilotChatLabels;
  className?: string;
}) {
  const chatContext = React.useContext(ChatContext);
  if (!chatContext) {
    return (
      <ChatContextProvider icons={icons} labels={labels} open={true} setOpen={() => {}}>
        <div className={`copilotKitChat ${className}`}>{children}</div>
      </ChatContextProvider>
    );
  }
  return <>{children}</>;
}

const SUGGESTIONS_DEBOUNCE_TIMEOUT = 1000;

export const useCopilotChatLogic = (
  makeSystemMessage?: SystemMessageFunction,
  onInProgress?: (isLoading: boolean) => void,
  onSubmitMessage?: (messageContent: string) => Promise<void> | void,
) => {
  const { visibleMessages, appendMessage, reloadMessages, stopGeneration, isLoading } =
    useCopilotChat({
      id: randomId(),
      makeSystemMessage,
    });

  const [currentSuggestions, setCurrentSuggestions] = useState<CopilotChatSuggestion[]>([]);
  const suggestionsAbortControllerRef = useRef<AbortController | null>(null);
  const debounceTimerRef = useRef<any>();

  const abortSuggestions = () => {
    suggestionsAbortControllerRef.current?.abort();
    suggestionsAbortControllerRef.current = null;
  };

  const context = useCopilotContext();

  useEffect(() => {
    onInProgress?.(isLoading);

    abortSuggestions();

    debounceTimerRef.current = setTimeout(
      () => {
        if (!isLoading && Object.keys(context.chatSuggestionConfiguration).length !== 0) {
          suggestionsAbortControllerRef.current = new AbortController();
          reloadSuggestions(
            context,
            context.chatSuggestionConfiguration,
            setCurrentSuggestions,
            suggestionsAbortControllerRef,
          );
        }
      },
      currentSuggestions.length == 0 ? 0 : SUGGESTIONS_DEBOUNCE_TIMEOUT,
    );

    return () => {
      clearTimeout(debounceTimerRef.current);
    };
  }, [isLoading, context.chatSuggestionConfiguration]);

  const sendMessage = async (messageContent: string) => {
    abortSuggestions();
    setCurrentSuggestions([]);

    const message: Message = new TextMessage({
      content: messageContent,
      role: Role.User,
    });

    // Append the message immediately to make it visible
    appendMessage(message);

    if (onSubmitMessage) {
      try {
        await onSubmitMessage(messageContent);
      } catch (error) {
        console.error("Error in onSubmitMessage:", error);
      }
    }

    return message;
  };

  return {
    visibleMessages,
    isLoading,
    currentSuggestions,
    sendMessage,
    stopGeneration,
    reloadMessages,
  };
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/ChatContext.tsx
---

import React, { useMemo, useState } from "react";
import * as DefaultIcons from "./Icons";

/**
 * Icons for CopilotChat component.
 */
export interface CopilotChatIcons {
  /**
   * The icon to use for the open chat button.
   * @default <OpenIcon />
   */
  openIcon?: React.ReactNode;

  /**
   * The icon to use for the close chat button.
   * @default <CloseIcon />
   */
  closeIcon?: React.ReactNode;

  /**
   * The icon to use for the close chat button in the header.
   * @default <HeaderCloseIcon />
   */
  headerCloseIcon?: React.ReactNode;

  /**
   * The icon to use for the send button.
   * @default <SendIcon />
   */
  sendIcon?: React.ReactNode;

  /**
   * The icon to use for the activity indicator.
   * @default <ActivityIcon />
   */
  activityIcon?: React.ReactNode;

  /**
   * The icon to use for the spinner.
   * @default <SpinnerIcon />
   */
  spinnerIcon?: React.ReactNode;

  /**
   * The icon to use for the stop button.
   * @default <StopIcon />
   */
  stopIcon?: React.ReactNode;

  /**
   * The icon to use for the regenerate button.
   * @default <RegenerateIcon />
   */
  regenerateIcon?: React.ReactNode;

  /**
   * The icons to use for push to talk.
   * @default <PushToTalkIcon />
   */

  pushToTalkIcon?: React.ReactNode;
}

/**
 * Labels for CopilotChat component.
 */
export interface CopilotChatLabels {
  /**
   * The initial message(s) to display in the chat window.
   */
  initial?: string | string[];

  /**
   * The title to display in the header.
   * @default "CopilotKit"
   */
  title?: string;

  /**
   * The placeholder to display in the input.
   * @default "Type a message..."
   */
  placeholder?: string;

  /**
   * The message to display when an error occurs.
   * @default "❌ An error occurred. Please try again."
   */
  error?: string;

  /**
   * The label to display on the stop button.
   * @default "Stop generating"
   */
  stopGenerating?: string;

  /**
   * The label to display on the regenerate button.
   * @default "Regenerate response"
   */
  regenerateResponse?: string;
}

interface ChatContext {
  labels: Required<CopilotChatLabels>;
  icons: Required<CopilotChatIcons>;
  open: boolean;
  setOpen: (open: boolean) => void;
}

export const ChatContext = React.createContext<ChatContext | undefined>(undefined);

export function useChatContext(): ChatContext {
  const context = React.useContext(ChatContext);
  if (context === undefined) {
    throw new Error(
      "Context not found. Did you forget to wrap your app in a <ChatContextProvider> component?",
    );
  }
  return context;
}

interface ChatContextProps {
  // temperature?: number;
  // instructions?: string;
  // maxFeedback?: number;
  labels?: CopilotChatLabels;
  icons?: CopilotChatIcons;
  children?: React.ReactNode;
  open: boolean;
  setOpen: (open: boolean) => void;
}

export const ChatContextProvider = ({
  // temperature,
  // instructions,
  // maxFeedback,
  labels,
  icons,
  children,
  open,
  setOpen,
}: ChatContextProps) => {
  const context = {
    labels: {
      ...{
        initial: "",
        title: "CopilotKit",
        placeholder: "Type a message...",
        error: "❌ An error occurred. Please try again.",
        stopGenerating: "Stop generating",
        regenerateResponse: "Regenerate response",
      },
      ...labels,
    },

    icons: {
      ...{
        openIcon: DefaultIcons.OpenIcon,
        closeIcon: DefaultIcons.CloseIcon,
        headerCloseIcon: DefaultIcons.HeaderCloseIcon,
        sendIcon: DefaultIcons.SendIcon,
        activityIcon: DefaultIcons.ActivityIcon,
        spinnerIcon: DefaultIcons.SpinnerIcon,
        stopIcon: DefaultIcons.StopIcon,
        regenerateIcon: DefaultIcons.RegenerateIcon,
        pushToTalkIcon: DefaultIcons.PushToTalkIcon,
      },
      ...icons,
    },
    open,
    setOpen,
  };
  return <ChatContext.Provider value={context}>{children}</ChatContext.Provider>;
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/CodeBlock.tsx
---

import { FC, memo } from "react";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { useCopyToClipboard } from "../../hooks/use-copy-to-clipboard";
import { CheckIcon, CopyIcon, DownloadIcon } from "./Icons";

interface CodeActionButtonProps {
  onClick: () => void;
  children: React.ReactNode;
}

interface Props {
  language: string;
  value: string;
}

interface languageMap {
  [key: string]: string | undefined;
}

export const programmingLanguages: languageMap = {
  javascript: ".js",
  python: ".py",
  java: ".java",
  c: ".c",
  cpp: ".cpp",
  "c++": ".cpp",
  "c#": ".cs",
  ruby: ".rb",
  php: ".php",
  swift: ".swift",
  "objective-c": ".m",
  kotlin: ".kt",
  typescript: ".ts",
  go: ".go",
  perl: ".pl",
  rust: ".rs",
  scala: ".scala",
  haskell: ".hs",
  lua: ".lua",
  shell: ".sh",
  sql: ".sql",
  html: ".html",
  css: ".css",
  // add more file extensions here, make sure the key is same as language prop in CodeBlock.tsx component
};

export const generateRandomString = (length: number, lowercase = false) => {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXY3456789"; // excluding similar looking characters like Z, 2, I, 1, O, 0
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return lowercase ? result.toLowerCase() : result;
};

const CodeBlock: FC<Props> = memo(({ language, value }) => {
  const { isCopied, copyToClipboard } = useCopyToClipboard({ timeout: 2000 });

  const downloadAsFile = () => {
    if (typeof window === "undefined") {
      return;
    }
    const fileExtension = programmingLanguages[language] || ".file";
    const suggestedFileName = `file-${generateRandomString(3, true)}${fileExtension}`;
    const fileName = window.prompt("Enter file name" || "", suggestedFileName);

    if (!fileName) {
      // User pressed cancel on prompt.
      return;
    }

    const blob = new Blob([value], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.download = fileName;
    link.href = url;
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const onCopy = () => {
    if (isCopied) return;
    copyToClipboard(value);
  };

  return (
    <div className="copilotKitCodeBlock">
      <div className="copilotKitCodeBlockToolbar">
        <span className="copilotKitCodeBlockToolbarLanguage">{language}</span>
        <div className="copilotKitCodeBlockToolbarButtons">
          <button className="copilotKitCodeBlockToolbarButton" onClick={downloadAsFile}>
            <DownloadIcon />
            <span className="sr-only">Download</span>
          </button>
          <button className="copilotKitCodeBlockToolbarButton" onClick={onCopy}>
            {isCopied ? <CheckIcon /> : <CopyIcon />}
            <span className="sr-only">Copy code</span>
          </button>
        </div>
      </div>
      <SyntaxHighlighter
        language={language}
        style={highlightStyle}
        PreTag="div"
        customStyle={{
          margin: 0,
          borderBottomLeftRadius: "0.375rem",
          borderBottomRightRadius: "0.375rem",
        }}
      >
        {value}
      </SyntaxHighlighter>
    </div>
  );
});
CodeBlock.displayName = "CodeBlock";

export { CodeBlock };

// import { vscDarkPlus as highlightStyle } from "react-syntax-highlighter/dist/esm/styles/prism";
// As a workaround, we inline the vscDarkPlus from react-syntax-highlighter.
// Importing it as recommended in the documentation leads to build errors in the non app router
// (Next.js classic) setup.
const highlightStyle: any = {
  'pre[class*="language-"]': {
    color: "#d4d4d4",
    fontSize: "13px",
    textShadow: "none",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    background: "#1e1e1e",
  },
  'code[class*="language-"]': {
    color: "#d4d4d4",
    fontSize: "13px",
    textShadow: "none",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#264F78",
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#264F78",
  },
  'pre[class*="language-"] *::selection': {
    textShadow: "none",
    background: "#264F78",
  },
  'code[class*="language-"] *::selection': {
    textShadow: "none",
    background: "#264F78",
  },
  ':not(pre) > code[class*="language-"]': {
    padding: ".1em .3em",
    borderRadius: ".3em",
    color: "#db4c69",
    background: "#1e1e1e",
  },
  ".namespace": {
    Opacity: ".7",
  },
  "doctype.doctype-tag": {
    color: "#569CD6",
  },
  "doctype.name": {
    color: "#9cdcfe",
  },
  comment: {
    color: "#6a9955",
  },
  prolog: {
    color: "#6a9955",
  },
  punctuation: {
    color: "#d4d4d4",
  },
  ".language-html .language-css .token.punctuation": {
    color: "#d4d4d4",
  },
  ".language-html .language-javascript .token.punctuation": {
    color: "#d4d4d4",
  },
  property: {
    color: "#9cdcfe",
  },
  tag: {
    color: "#569cd6",
  },
  boolean: {
    color: "#569cd6",
  },
  number: {
    color: "#b5cea8",
  },
  constant: {
    color: "#9cdcfe",
  },
  symbol: {
    color: "#b5cea8",
  },
  inserted: {
    color: "#b5cea8",
  },
  unit: {
    color: "#b5cea8",
  },
  selector: {
    color: "#d7ba7d",
  },
  "attr-name": {
    color: "#9cdcfe",
  },
  string: {
    color: "#ce9178",
  },
  char: {
    color: "#ce9178",
  },
  builtin: {
    color: "#ce9178",
  },
  deleted: {
    color: "#ce9178",
  },
  ".language-css .token.string.url": {
    textDecoration: "underline",
  },
  operator: {
    color: "#d4d4d4",
  },
  entity: {
    color: "#569cd6",
  },
  "operator.arrow": {
    color: "#569CD6",
  },
  atrule: {
    color: "#ce9178",
  },
  "atrule.rule": {
    color: "#c586c0",
  },
  "atrule.url": {
    color: "#9cdcfe",
  },
  "atrule.url.function": {
    color: "#dcdcaa",
  },
  "atrule.url.punctuation": {
    color: "#d4d4d4",
  },
  keyword: {
    color: "#569CD6",
  },
  "keyword.module": {
    color: "#c586c0",
  },
  "keyword.control-flow": {
    color: "#c586c0",
  },
  function: {
    color: "#dcdcaa",
  },
  "function.maybe-class-name": {
    color: "#dcdcaa",
  },
  regex: {
    color: "#d16969",
  },
  important: {
    color: "#569cd6",
  },
  italic: {
    fontStyle: "italic",
  },
  "class-name": {
    color: "#4ec9b0",
  },
  "maybe-class-name": {
    color: "#4ec9b0",
  },
  console: {
    color: "#9cdcfe",
  },
  parameter: {
    color: "#9cdcfe",
  },
  interpolation: {
    color: "#9cdcfe",
  },
  "punctuation.interpolation-punctuation": {
    color: "#569cd6",
  },
  variable: {
    color: "#9cdcfe",
  },
  "imports.maybe-class-name": {
    color: "#9cdcfe",
  },
  "exports.maybe-class-name": {
    color: "#9cdcfe",
  },
  escape: {
    color: "#d7ba7d",
  },
  "tag.punctuation": {
    color: "#808080",
  },
  cdata: {
    color: "#808080",
  },
  "attr-value": {
    color: "#ce9178",
  },
  "attr-value.punctuation": {
    color: "#ce9178",
  },
  "attr-value.punctuation.attr-equals": {
    color: "#d4d4d4",
  },
  namespace: {
    color: "#4ec9b0",
  },
  'pre[class*="language-javascript"]': {
    color: "#9cdcfe",
  },
  'code[class*="language-javascript"]': {
    color: "#9cdcfe",
  },
  'pre[class*="language-jsx"]': {
    color: "#9cdcfe",
  },
  'code[class*="language-jsx"]': {
    color: "#9cdcfe",
  },
  'pre[class*="language-typescript"]': {
    color: "#9cdcfe",
  },
  'code[class*="language-typescript"]': {
    color: "#9cdcfe",
  },
  'pre[class*="language-tsx"]': {
    color: "#9cdcfe",
  },
  'code[class*="language-tsx"]': {
    color: "#9cdcfe",
  },
  'pre[class*="language-css"]': {
    color: "#ce9178",
  },
  'code[class*="language-css"]': {
    color: "#ce9178",
  },
  'pre[class*="language-html"]': {
    color: "#d4d4d4",
  },
  'code[class*="language-html"]': {
    color: "#d4d4d4",
  },
  ".language-regex .token.anchor": {
    color: "#dcdcaa",
  },
  ".language-html .token.punctuation": {
    color: "#808080",
  },
  'pre[class*="language-"] > code[class*="language-"]': {
    position: "relative",
    zIndex: "1",
  },
  ".line-highlight.line-highlight": {
    background: "#f7ebc6",
    boxShadow: "inset 5px 0 0 #f7d87c",
    zIndex: "0",
  },
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Header.tsx
---

import { HeaderProps } from "./props";
import { useChatContext } from "./ChatContext";

export const Header = ({}: HeaderProps) => {
  const { setOpen, icons, labels } = useChatContext();

  return (
    <div className="copilotKitHeader">
      <div>{labels.title}</div>
      <button onClick={() => setOpen(false)} aria-label="Close">
        {icons.headerCloseIcon}
      </button>
    </div>
  );
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Icons.tsx
---

import React from "react";

export const OpenIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="currentColor"
    width="24"
    height="24"
  >
    <g transform="translate(24, 0) scale(-1, 1)">
      <path
        fillRule="evenodd"
        d="M5.337 21.718a6.707 6.707 0 01-.533-.074.75.75 0 01-.44-1.223 3.73 3.73 0 00.814-1.686c.023-.115-.022-.317-.254-.543C3.274 16.587 2.25 14.41 2.25 12c0-5.03 4.428-9 9.75-9s9.75 3.97 9.75 9c0 5.03-4.428 9-9.75 9-.833 0-1.643-.097-2.417-.279a6.721 6.721 0 01-4.246.997z"
        clipRule="evenodd"
      />
    </g>
  </svg>
);

export const CloseIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth="1.5"
    stroke="currentColor"
    width="24"
    height="24"
  >
    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
);

export const HeaderCloseIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth="1.5"
    stroke="currentColor"
    width="24"
    height="24"
  >
    <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
  </svg>
);

export const SendIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    width="24"
    height="24"
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5"
    />
  </svg>
);

export const SpinnerIcon = (
  <svg
    style={{
      animation: "copilotKitSpinAnimation 1s linear infinite",
      color: "rgb(107 114 128)",
    }}
    width="24"
    height="24"
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      style={{ opacity: 0.25 }}
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    ></circle>
    <path
      style={{ opacity: 0.75 }}
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    ></path>
  </svg>
);

export const SmallSpinnerIcon = (
  <svg
    style={{
      animation: "copilotKitSpinAnimation 1s linear infinite",
    }}
    width="13"
    height="13"
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      style={{ opacity: 0.25 }}
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    ></circle>
    <path
      style={{ opacity: 0.75 }}
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    ></path>
  </svg>
);

export const ActivityIcon = (
  <svg
    style={{
      display: "inline-block",
      marginLeft: "0.25rem",
      marginRight: "0.25rem",
    }}
    height="24"
    width="24"
    viewBox="0 0 27 27"
    xmlns="http://www.w3.org/2000/svg"
    fill="currentColor"
  >
    <circle className="copilotKitActivityDot1" cx="4" cy="12" r="3" />
    <circle className="copilotKitActivityDot1 copilotKitActivityDot2" cx="12" cy="12" r="3" />
    <circle className="copilotKitActivityDot1 copilotKitActivityDot3" cx="20" cy="12" r="3" />
  </svg>
);

export function CheckIcon({ className, ...props }: React.ComponentProps<"svg">) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 256 256"
      fill="currentColor"
      style={{ height: "1rem", width: "1rem" }}
      className={className}
      {...props}
    >
      <path d="m229.66 77.66-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32Z" />
    </svg>
  );
}

export function DownloadIcon({ className, ...props }: React.ComponentProps<"svg">) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 256 256"
      fill="currentColor"
      style={{ height: "1rem", width: "1rem" }}
      className={className}
      {...props}
    >
      <path d="M224 152v56a16 16 0 0 1-16 16H48a16 16 0 0 1-16-16v-56a8 8 0 0 1 16 0v56h160v-56a8 8 0 0 1 16 0Zm-101.66 5.66a8 8 0 0 0 11.32 0l40-40a8 8 0 0 0-11.32-11.32L136 132.69V40a8 8 0 0 0-16 0v92.69l-26.34-26.35a8 8 0 0 0-11.32 11.32Z" />
    </svg>
  );
}

export function CopyIcon({ className, ...props }: React.ComponentProps<"svg">) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 256 256"
      fill="currentColor"
      style={{ height: "1rem", width: "1rem" }}
      className={className}
      {...props}
    >
      <path d="M216 32H88a8 8 0 0 0-8 8v40H40a8 8 0 0 0-8 8v128a8 8 0 0 0 8 8h128a8 8 0 0 0 8-8v-40h40a8 8 0 0 0 8-8V40a8 8 0 0 0-8-8Zm-56 176H48V96h112Zm48-48h-32V88a8 8 0 0 0-8-8H96V48h112Z" />
    </svg>
  );
}

export const StopIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 256 256"
    fill="currentColor"
    style={{ height: "1rem", width: "1rem" }}
  >
    <path d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 192a88 88 0 1 1 88-88 88.1 88.1 0 0 1-88 88Zm24-120h-48a8 8 0 0 0-8 8v48a8 8 0 0 0 8 8h48a8 8 0 0 0 8-8v-48a8 8 0 0 0-8-8Zm-8 48h-32v-32h32Z" />
  </svg>
);

export const RegenerateIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 256 256"
    fill="currentColor"
    style={{ height: "1rem", width: "1rem" }}
  >
    <path d="M197.67 186.37a8 8 0 0 1 0 11.29C196.58 198.73 170.82 224 128 224c-37.39 0-64.53-22.4-80-39.85V208a8 8 0 0 1-16 0v-48a8 8 0 0 1 8-8h48a8 8 0 0 1 0 16H55.44C67.76 183.35 93 208 128 208c36 0 58.14-21.46 58.36-21.68a8 8 0 0 1 11.31.05ZM216 40a8 8 0 0 0-8 8v23.85C192.53 54.4 165.39 32 128 32c-42.82 0-68.58 25.27-69.66 26.34a8 8 0 0 0 11.3 11.34C69.86 69.46 92 48 128 48c35 0 60.24 24.65 72.56 40H168a8 8 0 0 0 0 16h48a8 8 0 0 0 8-8V48a8 8 0 0 0-8-8Z" />
  </svg>
);

export const PushToTalkIcon = (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className="w-6 h-6"
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 0 1-3-3V4.5a3 3 0 1 1 6 0v8.25a3 3 0 0 1-3 3Z"
    />
  </svg>
);



---
File: /CopilotKit/packages/react-ui/src/components/chat/index.tsx
---

export * from "./props";
export { CopilotPopup } from "./Popup";
export { CopilotSidebar } from "./Sidebar";
export { CopilotChat } from "./Chat";
export { useChatContext } from "./ChatContext";



---
File: /CopilotKit/packages/react-ui/src/components/chat/Input.tsx
---

import React, { useEffect, useRef, useState } from "react";
import { InputProps } from "./props";
import { useChatContext } from "./ChatContext";
import AutoResizingTextarea from "./Textarea";
import { usePushToTalk } from "../../hooks/use-push-to-talk";
import { useCopilotContext } from "@copilotkit/react-core";

export const Input = ({ inProgress, onSend, isVisible = false }: InputProps) => {
  const context = useChatContext();
  const copilotContext = useCopilotContext();

  const pushToTalkConfigured =
    copilotContext.copilotApiConfig.textToSpeechUrl !== undefined &&
    copilotContext.copilotApiConfig.transcribeAudioUrl !== undefined;

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleDivClick = (event: React.MouseEvent<HTMLDivElement>) => {
    // Check if the clicked element is not the textarea itself
    if (event.target !== event.currentTarget) return;

    textareaRef.current?.focus();
  };

  const [text, setText] = useState("");
  const send = () => {
    if (inProgress) return;
    onSend(text);
    setText("");

    textareaRef.current?.focus();
  };

  useEffect(() => {
    if (isVisible) {
      textareaRef.current?.focus();
    }
  }, [isVisible]);

  const { pushToTalkState, setPushToTalkState } = usePushToTalk({
    sendFunction: onSend,
    inProgress,
  });

  const sendIcon =
    inProgress || pushToTalkState === "transcribing"
      ? context.icons.activityIcon
      : context.icons.sendIcon;
  const showPushToTalk =
    pushToTalkConfigured &&
    (pushToTalkState === "idle" || pushToTalkState === "recording") &&
    !inProgress;
  const sendDisabled = inProgress || text.length === 0 || pushToTalkState !== "idle";

  return (
    <div className="copilotKitInput" onClick={handleDivClick}>
      <AutoResizingTextarea
        ref={textareaRef}
        placeholder={context.labels.placeholder}
        autoFocus={true}
        maxRows={5}
        value={text}
        onChange={(event) => setText(event.target.value)}
        onKeyDown={(event) => {
          if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            send();
          }
        }}
      />
      <div className="copilotKitInputControls">
        {showPushToTalk && (
          <button
            onClick={() =>
              setPushToTalkState(pushToTalkState === "idle" ? "recording" : "transcribing")
            }
            className={pushToTalkState === "recording" ? "copilotKitPushToTalkRecording" : ""}
          >
            {context.icons.pushToTalkIcon}
          </button>
        )}
        <button disabled={sendDisabled} onClick={send}>
          {sendIcon}
        </button>
      </div>
    </div>
  );
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Markdown.tsx
---

import { FC, memo } from "react";
import ReactMarkdown, { Options, Components } from "react-markdown";
import { CodeBlock } from "./CodeBlock";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";

const MemoizedReactMarkdown: FC<Options> = memo(
  ReactMarkdown,
  (prevProps, nextProps) =>
    prevProps.children === nextProps.children && prevProps.className === nextProps.className,
);

type MarkdownProps = {
  content: string;
};

export const Markdown = ({ content }: MarkdownProps) => {
  return (
    <div className="copilotKitMarkdown">
      <MemoizedReactMarkdown components={components} remarkPlugins={[remarkGfm, remarkMath]}>
        {content}
      </MemoizedReactMarkdown>
    </div>
  );
};

const components: Components = {
  p({ children }) {
    return <p>{children}</p>;
  },
  a({ children, ...props }) {
    return (
      <a
        style={{ color: "blue", textDecoration: "underline" }}
        {...props}
        target="_blank"
        rel="noopener noreferrer"
      >
        {children}
      </a>
    );
  },
  code({ children, className, inline, ...props }) {
    if (children.length) {
      if (children[0] == "▍") {
        return (
          <span
            style={{
              animation: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
              marginTop: "0.25rem",
            }}
          >
            ▍
          </span>
        );
      }

      children[0] = (children[0] as string).replace("`▍`", "▍");
    }

    const match = /language-(\w+)/.exec(className || "");

    if (inline) {
      return (
        <code className={className} {...props}>
          {children}
        </code>
      );
    }

    return (
      <CodeBlock
        key={Math.random()}
        language={(match && match[1]) || ""}
        value={String(children).replace(/\n$/, "")}
        {...props}
      />
    );
  },
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Messages.tsx
---

import React, { useEffect, useMemo } from "react";
import { MessagesProps } from "./props";
import { useChatContext } from "./ChatContext";
import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
  Role,
  AgentStateMessage,
} from "@copilotkit/runtime-client-gql";

export const Messages = ({
  messages,
  inProgress,
  children,
  RenderTextMessage,
  RenderActionExecutionMessage,
  RenderAgentStateMessage,
  RenderResultMessage,
}: MessagesProps) => {
  const context = useChatContext();
  const initialMessages = useMemo(
    () => makeInitialMessages(context.labels.initial),
    [context.labels.initial],
  );
  messages = [...initialMessages, ...messages];

  const actionResults: Record<string, string> = {};

  for (let i = 0; i < messages.length; i++) {
    if (messages[i] instanceof ActionExecutionMessage) {
      const id = messages[i].id;
      const resultMessage: ResultMessage | undefined = messages.find(
        (message) => message instanceof ResultMessage && message.actionExecutionId === id,
      ) as ResultMessage | undefined;

      if (resultMessage) {
        actionResults[id] = ResultMessage.decodeResult(resultMessage.result || "");
      }
    }
  }

  const messagesEndRef = React.useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({
        behavior: "auto",
      });
    }
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  return (
    <div className="copilotKitMessages">
      {messages.map((message, index) => {
        const isCurrentMessage = index === messages.length - 1;

        if (message instanceof TextMessage) {
          return (
            <RenderTextMessage
              key={index}
              message={message}
              inProgress={inProgress}
              index={index}
              isCurrentMessage={isCurrentMessage}
            />
          );
        } else if (message instanceof ActionExecutionMessage) {
          return (
            <RenderActionExecutionMessage
              key={index}
              message={message}
              inProgress={inProgress}
              index={index}
              isCurrentMessage={isCurrentMessage}
              actionResult={actionResults[message.id]}
            />
          );
        } else if (message instanceof AgentStateMessage) {
          return (
            <RenderAgentStateMessage
              key={index}
              message={message}
              inProgress={inProgress}
              index={index}
              isCurrentMessage={isCurrentMessage}
            />
          );
        } else if (message instanceof ResultMessage) {
          return (
            <RenderResultMessage
              key={index}
              message={message}
              inProgress={inProgress}
              index={index}
              isCurrentMessage={isCurrentMessage}
            />
          );
        }
      })}
      <footer ref={messagesEndRef}>{children}</footer>
    </div>
  );
};

function makeInitialMessages(initial?: string | string[]): Message[] {
  let initialArray: string[] = [];
  if (initial) {
    if (Array.isArray(initial)) {
      initialArray.push(...initial);
    } else {
      initialArray.push(initial);
    }
  }

  return initialArray.map(
    (message) =>
      new TextMessage({
        role: Role.Assistant,
        content: message,
      }),
  );
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/Modal.tsx
---

import React from "react";
import { ChatContextProvider } from "./ChatContext";
import { ButtonProps, HeaderProps, WindowProps } from "./props";
import { Window as DefaultWindow } from "./Window";
import { Button as DefaultButton } from "./Button";
import { Header as DefaultHeader } from "./Header";
import { Messages as DefaultMessages } from "./Messages";
import { Input as DefaultInput } from "./Input";
import { ResponseButton as DefaultResponseButton } from "./Response";
import { CopilotChat, CopilotChatProps } from "./Chat";

export interface CopilotModalProps extends CopilotChatProps {
  /**
   * Whether the chat window should be open by default.
   * @default false
   */
  defaultOpen?: boolean;

  /**
   * If the chat window should close when the user clicks outside of it.
   * @default true
   */
  clickOutsideToClose?: boolean;

  /**
   * If the chat window should close when the user hits the Escape key.
   * @default true
   */
  hitEscapeToClose?: boolean;

  /**
   * The shortcut key to open the chat window.
   * Uses Command-[shortcut] on a Mac and Ctrl-[shortcut] on Windows.
   * @default '/'
   */
  shortcut?: string;

  /**
   * A callback that gets called when the chat window opens or closes.
   */
  onSetOpen?: (open: boolean) => void;

  /**
   * A custom Window component to use instead of the default.
   */
  Window?: React.ComponentType<WindowProps>;

  /**
   * A custom Button component to use instead of the default.
   */
  Button?: React.ComponentType<ButtonProps>;

  /**
   * A custom Header component to use instead of the default.
   */
  Header?: React.ComponentType<HeaderProps>;
}

export const CopilotModal = ({
  instructions,
  defaultOpen = false,
  clickOutsideToClose = true,
  hitEscapeToClose = true,
  onSetOpen,
  onSubmitMessage,
  shortcut = "/",
  icons,
  labels,
  makeSystemMessage,
  showResponseButton = true,
  onInProgress,
  Window = DefaultWindow,
  Button = DefaultButton,
  Header = DefaultHeader,
  Messages = DefaultMessages,
  Input = DefaultInput,
  ResponseButton = DefaultResponseButton,
  className,
  children,
}: CopilotModalProps) => {
  const [openState, setOpenState] = React.useState(defaultOpen);

  const setOpen = (open: boolean) => {
    onSetOpen?.(open);
    setOpenState(open);
  };

  return (
    <ChatContextProvider icons={icons} labels={labels} open={openState} setOpen={setOpen}>
      {children}
      <div className={className}>
        <Button></Button>
        <Window
          clickOutsideToClose={clickOutsideToClose}
          shortcut={shortcut}
          hitEscapeToClose={hitEscapeToClose}
        >
          <Header />
          <CopilotChat
            instructions={instructions}
            onSubmitMessage={onSubmitMessage}
            makeSystemMessage={makeSystemMessage}
            showResponseButton={showResponseButton}
            onInProgress={onInProgress}
            Messages={Messages}
            Input={Input}
            ResponseButton={ResponseButton}
          />
        </Window>
      </div>
    </ChatContextProvider>
  );
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Popup.tsx
---

/**
 * <br/>
 * <img src="/images/CopilotPopup.gif" width="500" />
 *
 * A chatbot popup component for the CopilotKit framework. The component allows for a high degree
 * of customization through various props and custom CSS.
 *
 * See [CopilotSidebar](/reference/components/CopilotSidebar) for a sidebar version of this component.
 *
 * ## Install Dependencies
 *
 * This component is part of the [@copilotkit/react-ui](https://npmjs.com/package/@copilotkit/react-ui) package.
 *
 * ```shell npm2yarn \"@copilotkit/react-ui"\
 * npm install @copilotkit/react-core @copilotkit/react-ui
 * ```
 * ## Usage
 *
 * ```tsx
 * import { CopilotPopup } from "@copilotkit/react-ui";
 * import "@copilotkit/react-ui/styles.css";
 *
 * <CopilotPopup
 *   labels={{
 *     title: "Your Assistant",
 *     initial: "Hi! 👋 How can I assist you today?",
 *   }}
 * />
 * ```
 *
 * ### Look & Feel
 *
 * By default, CopilotKit components do not have any styles. You can import CopilotKit's stylesheet at the root of your project:
 * ```tsx title="YourRootComponent.tsx"
 * ...
 * import "@copilotkit/react-ui/styles.css"; // [!code highlight]
 *
 * export function YourRootComponent() {
 *   return (
 *     <CopilotKit>
 *       ...
 *     </CopilotKit>
 *   );
 * }
 * ```
 * For more information about how to customize the styles, check out the [Customize Look & Feel](/concepts/customize-look-and-feel) guide.
 */

import { CopilotModal, CopilotModalProps } from "./Modal";

export function CopilotPopup(props: CopilotModalProps) {
  props = {
    ...props,
    className: props.className ? props.className + " copilotKitPopup" : "copilotKitPopup",
  };
  return <CopilotModal {...props}>{props.children}</CopilotModal>;
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/props.ts
---

import { Message } from "@copilotkit/runtime-client-gql";

export interface ButtonProps {}

export interface WindowProps {
  clickOutsideToClose: boolean;
  hitEscapeToClose: boolean;
  shortcut: string;
  children?: React.ReactNode;
}

export interface HeaderProps {}

export interface SuggestionsProps {
  title: string;
  message: string;
  partial?: boolean;
  className?: string;
  onClick: (message: string) => void;
}

export interface MessagesProps {
  messages: Message[];
  inProgress: boolean;
  children?: React.ReactNode;
  RenderTextMessage: React.ComponentType<RenderMessageProps>;
  RenderActionExecutionMessage: React.ComponentType<RenderMessageProps>;
  RenderAgentStateMessage: React.ComponentType<RenderMessageProps>;
  RenderResultMessage: React.ComponentType<RenderMessageProps>;
}

export interface RenderMessageProps {
  message: Message;
  inProgress: boolean;
  index: number;
  isCurrentMessage: boolean;
  actionResult?: string;
}

export interface InputProps {
  inProgress: boolean;
  onSend: (text: string) => Promise<Message>;
  isVisible?: boolean;
}

export interface ResponseButtonProps {
  onClick: () => void;
  inProgress: boolean;
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/Response.tsx
---

import { useChatContext } from "./ChatContext";
import { ResponseButtonProps } from "./props";

export const ResponseButton = ({ onClick, inProgress }: ResponseButtonProps) => {
  const context = useChatContext();
  return (
    <button onClick={onClick} className="copilotKitResponseButton">
      <span>{inProgress ? context.icons.stopIcon : context.icons.regenerateIcon}</span>
      {inProgress ? context.labels.stopGenerating : context.labels.regenerateResponse}
    </button>
  );
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Sidebar.tsx
---

/**
 * <br/>
 * <img src="/images/CopilotSidebar.gif" width="500" />
 *
 * A chatbot sidebar component for the CopilotKit framework. Highly customizable through various props and custom CSS.
 *
 * See [CopilotPopup](/reference/components/CopilotPopup) for a popup version of this component.
 *
 * ## Install Dependencies
 *
 * This component is part of the [@copilotkit/react-ui](https://npmjs.com/package/@copilotkit/react-ui) package.
 *
 * ```shell npm2yarn \"@copilotkit/react-ui"\
 * npm install @copilotkit/react-core @copilotkit/react-ui
 * ```
 *
 * ## Usage
 *
 * ```tsx
 * import { CopilotSidebar } from "@copilotkit/react-ui";
 * import "@copilotkit/react-ui/styles.css";
 *
 * <CopilotSidebar
 *   labels={{
 *     title: "Your Assistant",
 *     initial: "Hi! 👋 How can I assist you today?",
 *   }}
 * >
 *   <YourApp/>
 * </CopilotSidebar>
 * ```
 *
 * ### Look & Feel
 *
 * By default, CopilotKit components do not have any styles. You can import CopilotKit's stylesheet at the root of your project:
 * ```tsx title="YourRootComponent.tsx"
 * ...
 * import "@copilotkit/react-ui/styles.css"; // [!code highlight]
 *
 * export function YourRootComponent() {
 *   return (
 *     <CopilotKit>
 *       ...
 *     </CopilotKit>
 *   );
 * }
 * ```
 * For more information about how to customize the styles, check out the [Customize Look & Feel](/concepts/customize-look-and-feel) guide.
 */
import React, { useState } from "react";
import { CopilotModal, CopilotModalProps } from "./Modal";

export function CopilotSidebar(props: CopilotModalProps) {
  props = {
    ...props,
    className: props.className ? props.className + " copilotKitSidebar" : "copilotKitSidebar",
  };
  const [expandedClassName, setExpandedClassName] = useState(
    props.defaultOpen ? "sidebarExpanded" : "",
  );

  const onSetOpen = (open: boolean) => {
    props.onSetOpen?.(open);
    setExpandedClassName(open ? "sidebarExpanded" : "");
  };

  return (
    <div className={`copilotKitSidebarContentWrapper ${expandedClassName}`}>
      <CopilotModal {...props} {...{ onSetOpen }}>
        {props.children}
      </CopilotModal>
    </div>
  );
}



---
File: /CopilotKit/packages/react-ui/src/components/chat/Suggestion.tsx
---

import {
  CopilotContextParams,
  extract,
  CopilotChatSuggestionConfiguration,
  useCopilotContext,
} from "@copilotkit/react-core";
import { SuggestionsProps } from "./props";
import { SmallSpinnerIcon } from "./Icons";
import { CopilotChatSuggestion } from "../../types/suggestions";
import { actionParametersToJsonSchema } from "@copilotkit/shared";
import { CopilotRequestType } from "@copilotkit/runtime-client-gql";

export function Suggestion({ title, message, onClick, partial, className }: SuggestionsProps) {
  return (
    <button
      disabled={partial}
      onClick={(e) => {
        e.preventDefault();
        onClick(message);
      }}
      className={className || "suggestion"}
    >
      {partial && SmallSpinnerIcon}
      <span>{title}</span>
    </button>
  );
}

export const reloadSuggestions = async (
  context: CopilotContextParams,
  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration },
  setCurrentSuggestions: (suggestions: { title: string; message: string }[]) => void,
  abortControllerRef: React.MutableRefObject<AbortController | null>,
) => {
  const abortController = abortControllerRef.current;

  const tools = JSON.stringify(
    Object.values(context.actions).map((action) => ({
      name: action.name,
      description: action.description,
      jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters)),
    })),
  );

  const allSuggestions: CopilotChatSuggestion[] = [];

  for (const config of Object.values(chatSuggestionConfiguration)) {
    try {
      const numOfSuggestionsInstructions =
        config.minSuggestions === 0
          ? `Produce up to ${config.maxSuggestions} suggestions. ` +
            `If there are no highly relevant suggestions you can think of, provide an empty array.`
          : `Produce between ${config.minSuggestions} and ${config.maxSuggestions} suggestions.`;

      const result = await extract({
        context,
        instructions:
          "Suggest what the user could say next. Provide clear, highly relevant suggestions. Do not literally suggest function calls. " +
          config.instructions +
          "\n\n" +
          numOfSuggestionsInstructions,
        data: "Available tools: " + tools + "\n\n",
        requestType: CopilotRequestType.Task,
        parameters: [
          {
            name: "suggestions",
            type: "object[]",
            attributes: [
              {
                name: "title",
                description:
                  "The title of the suggestion. This is shown as a button and should be short.",
                type: "string",
              },
              {
                name: "message",
                description:
                  "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI.",
                type: "string",
              },
            ],
          },
        ],
        include: {
          messages: true,
          readable: true,
        },
        abortSignal: abortController?.signal,
        stream: ({ status, args }) => {
          const suggestions = args.suggestions || [];
          const newSuggestions: CopilotChatSuggestion[] = [];
          for (let i = 0; i < suggestions.length; i++) {
            // if GPT provides too many suggestions, limit the number of suggestions
            if (config.maxSuggestions !== undefined && i >= config.maxSuggestions) {
              break;
            }
            const { title, message } = suggestions[i];

            // If this is the last suggestion and the status is not complete, mark it as partial
            const partial = i == suggestions.length - 1 && status !== "complete";

            newSuggestions.push({
              title,
              message,
              partial,
              className: config.className,
            });
          }
          setCurrentSuggestions([...allSuggestions, ...newSuggestions]);
        },
      });
      allSuggestions.push(...result.suggestions);
    } catch (error) {
      console.error("Error loading suggestions", error);
    }
  }

  if (abortControllerRef.current === abortController) {
    abortControllerRef.current = null;
  }
};



---
File: /CopilotKit/packages/react-ui/src/components/chat/Textarea.tsx
---

import React, { useState, useRef, useEffect, forwardRef, useImperativeHandle } from "react";

interface AutoResizingTextareaProps {
  maxRows?: number;
  placeholder?: string;
  value: string;
  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onKeyDown?: (event: React.KeyboardEvent<HTMLTextAreaElement>) => void;
  autoFocus?: boolean;
}

const AutoResizingTextarea = forwardRef<HTMLTextAreaElement, AutoResizingTextareaProps>(
  ({ maxRows = 1, placeholder, value, onChange, onKeyDown, autoFocus }, ref) => {
    const internalTextareaRef = useRef<HTMLTextAreaElement>(null);
    const [maxHeight, setMaxHeight] = useState<number>(0);

    useImperativeHandle(ref, () => internalTextareaRef.current as HTMLTextAreaElement);

    useEffect(() => {
      const calculateMaxHeight = () => {
        const textarea = internalTextareaRef.current;
        if (textarea) {
          textarea.style.height = "auto";
          const singleRowHeight = textarea.scrollHeight;
          setMaxHeight(singleRowHeight * maxRows);
          if (autoFocus) {
            textarea.focus();
          }
        }
      };

      calculateMaxHeight();
    }, [maxRows]);

    useEffect(() => {
      const textarea = internalTextareaRef.current;
      if (textarea) {
        textarea.style.height = "auto";
        textarea.style.height = `${Math.min(textarea.scrollHeight, maxHeight)}px`;
      }
    }, [value, maxHeight]);

    return (
      <textarea
        ref={internalTextareaRef}
        value={value}
        onChange={onChange}
        onKeyDown={onKeyDown}
        placeholder={placeholder}
        style={{
          overflow: "auto",
          resize: "none",
          maxHeight: `${maxHeight}px`,
        }}
        rows={1}
      />
    );
  },
);

export default AutoResizingTextarea;



---
File: /CopilotKit/packages/react-ui/src/components/chat/Window.tsx
---

import React, { useCallback, useEffect } from "react";
import { WindowProps } from "./props";
import { useChatContext } from "./ChatContext";

export const Window = ({
  children,
  clickOutsideToClose,
  shortcut,
  hitEscapeToClose,
}: WindowProps) => {
  const windowRef = React.useRef<HTMLDivElement>(null);

  const { open, setOpen } = useChatContext();

  const handleClickOutside = useCallback(
    (event: MouseEvent) => {
      if (!clickOutsideToClose) {
        return;
      }

      const parentElement = windowRef.current?.parentElement;

      let className = "";
      if (event.target instanceof HTMLElement) {
        className = event.target.className;
      }

      if (
        open &&
        parentElement &&
        !parentElement.contains(event.target as any) &&
        // prevent closing the window when clicking on the debug menu
        !className.includes("copilotKitDebugMenu")
      ) {
        setOpen(false);
      }
    },
    [clickOutsideToClose, open, setOpen],
  );

  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      const target = event.target as HTMLElement;
      const isInput =
        target.tagName === "INPUT" ||
        target.tagName === "SELECT" ||
        target.tagName === "TEXTAREA" ||
        target.isContentEditable;

      const isDescendantOfWrapper = windowRef.current?.contains(target);

      if (
        open &&
        event.key === "Escape" &&
        (!isInput || isDescendantOfWrapper) &&
        hitEscapeToClose
      ) {
        setOpen(false);
      } else if (
        event.key === shortcut &&
        ((isMacOS() && event.metaKey) || (!isMacOS() && event.ctrlKey)) &&
        (!isInput || isDescendantOfWrapper)
      ) {
        setOpen(!open);
      }
    },
    [hitEscapeToClose, shortcut, open, setOpen],
  );

  const adjustForMobile = useCallback(() => {
    const copilotKitWindow = windowRef.current;
    const vv = window.visualViewport;
    if (!copilotKitWindow || !vv) {
      return;
    }

    if (window.innerWidth < 640 && open) {
      copilotKitWindow.style.height = `${vv.height}px`;
      copilotKitWindow.style.left = `${vv.offsetLeft}px`;
      copilotKitWindow.style.top = `${vv.offsetTop}px`;

      document.body.style.position = "fixed";
      document.body.style.width = "100%";
      document.body.style.height = `${window.innerHeight}px`;
      document.body.style.overflow = "hidden";
      document.body.style.touchAction = "none";

      // Prevent scrolling on iOS
      document.body.addEventListener("touchmove", preventScroll, {
        passive: false,
      });
    } else {
      copilotKitWindow.style.height = "";
      copilotKitWindow.style.left = "";
      copilotKitWindow.style.top = "";
      document.body.style.position = "";
      document.body.style.height = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      document.body.style.top = "";
      document.body.style.touchAction = "";

      document.body.removeEventListener("touchmove", preventScroll);
    }
  }, [open]);

  useEffect(() => {
    document.addEventListener("mousedown", handleClickOutside);
    document.addEventListener("keydown", handleKeyDown);
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", adjustForMobile);
      adjustForMobile();
    }

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("keydown", handleKeyDown);
      if (window.visualViewport) {
        window.visualViewport.removeEventListener("resize", adjustForMobile);
      }
    };
  }, [adjustForMobile, handleClickOutside, handleKeyDown]);

  return (
    <div className={`copilotKitWindow${open ? " open" : ""}`} ref={windowRef}>
      {children}
    </div>
  );
};

const preventScroll = (event: TouchEvent): void => {
  let targetElement = event.target as Element;

  // Function to check if the target has the parent with a given class
  const hasParentWithClass = (element: Element, className: string): boolean => {
    while (element && element !== document.body) {
      if (element.classList.contains(className)) {
        return true;
      }
      element = element.parentElement!;
    }
    return false;
  };

  // Check if the target of the touch event is inside an element with the 'copilotKitMessages' class
  if (!hasParentWithClass(targetElement, "copilotKitMessages")) {
    event.preventDefault();
  }
};

function isMacOS() {
  return /Mac|iMac|Macintosh/i.test(navigator.userAgent);
}



---
File: /CopilotKit/packages/react-ui/src/components/dev-console/console.tsx
---

"use client";

import { useCopilotContext } from "@copilotkit/react-core";
import {
  getPublishedCopilotKitVersion,
  logActions,
  logMessages,
  logReadables,
  shouldShowDevConsole,
} from "./utils";
import { useEffect, useRef, useState } from "react";
import {
  CheckIcon,
  ChevronDownIcon,
  CopilotKitIcon,
  ExclamationMarkIcon,
  ExclamationMarkTriangleIcon,
} from "./icons";
import { Menu, MenuButton, MenuItem, MenuItems } from "@headlessui/react";
import { COPILOTKIT_VERSION } from "@copilotkit/shared";
import { SmallSpinnerIcon } from "../chat/Icons";

type VersionStatus = "unknown" | "checking" | "latest" | "update-available" | "outdated";

export function CopilotDevConsole() {
  const currentVersion = COPILOTKIT_VERSION;
  const context = useCopilotContext();

  // to prevent hydration errors, ensure that the component renders the same content
  // server-side as it does during the initial client-side render to prevent a hydration
  // mismatch
  // see: https://nextjs.org/docs/messages/react-hydration-error#solution-1-using-useeffect-to-run-on-the-client-only

  const [showDevConsole, setShowDevConsole] = useState(false);

  useEffect(() => {
    setShowDevConsole(shouldShowDevConsole(context.showDevConsole));
  }, [context.showDevConsole]);

  const dontRunTwiceInDevMode = useRef(false);
  const [versionStatus, setVersionStatus] = useState<VersionStatus>("unknown");
  const [latestVersion, setLatestVersion] = useState<string>("");
  const consoleRef = useRef<HTMLDivElement>(null);
  const [debugButtonMode, setDebugButtonMode] = useState<"full" | "compact">("full");

  const checkForUpdates = (force: boolean = false) => {
    setVersionStatus("checking");

    getPublishedCopilotKitVersion(currentVersion, force)
      .then((v) => {
        setLatestVersion(v.latest);
        let versionOk = false;

        // match exact version or a version with a letter (e.g. 1.0.0-alpha.1)
        if (v.current === v.latest) {
          versionOk = true;
        } else if (/[a-zA-Z]/.test(v.current)) {
          versionOk = true;
        }

        if (versionOk) {
          setVersionStatus("latest");
        } else if (v.severity !== "low") {
          setVersionStatus("outdated");
        } else {
          setVersionStatus("update-available");
        }
      })
      .catch((e) => {
        console.error(e);
        setVersionStatus("unknown");
      });
  };

  useEffect(() => {
    if (dontRunTwiceInDevMode.current === true) {
      return;
    }
    dontRunTwiceInDevMode.current = true;

    checkForUpdates();
  }, []);

  useEffect(() => {
    const handleResize = (entries: ResizeObserverEntry[]) => {
      for (let entry of entries) {
        if (entry.target === consoleRef.current) {
          const width = entry.contentRect.width;
          if (width < 400) {
            setDebugButtonMode("compact");
          } else {
            setDebugButtonMode("full");
          }
        }
      }
    };

    const observer = new ResizeObserver(handleResize);
    if (consoleRef.current) {
      observer.observe(consoleRef.current);

      const initialWidth = consoleRef.current.getBoundingClientRect().width;
      if (initialWidth < 400) {
        setDebugButtonMode("compact");
      } else {
        setDebugButtonMode("full");
      }
    }

    return () => {
      if (consoleRef.current) {
        observer.unobserve(consoleRef.current);
      }
    };
  }, [consoleRef.current]);

  if (!showDevConsole) {
    return null;
  }
  return (
    <div
      ref={consoleRef}
      className={
        "copilotKitDevConsole " +
        (versionStatus === "update-available" ? "copilotKitDevConsoleUpgrade" : "") +
        (versionStatus === "outdated" ? "copilotKitDevConsoleWarnOutdated" : "")
      }
    >
      <div className="copilotKitDevConsoleLogo">
        <a href="https://copilotkit.ai" target="_blank">
          {CopilotKitIcon}
        </a>
      </div>
      <VersionInfo
        showDevConsole={context.showDevConsole}
        versionStatus={versionStatus}
        currentVersion={currentVersion}
        latestVersion={latestVersion}
      />

      <DebugMenuButton
        setShowDevConsole={setShowDevConsole}
        checkForUpdates={checkForUpdates}
        mode={debugButtonMode}
      />
    </div>
  );
}

function VersionInfo({
  showDevConsole,
  versionStatus,
  currentVersion,
  latestVersion,
}: {
  showDevConsole: boolean | "auto";
  versionStatus: VersionStatus;
  currentVersion: string;
  latestVersion: string;
}) {
  const [copyStatus, setCopyStatus] = useState<string>("");

  let versionLabel = "";
  let versionIcon: any = "";
  let currentVersionLabel = currentVersion;

  if (versionStatus === "latest") {
    versionLabel = "latest";
    versionIcon = CheckIcon;
  } else if (versionStatus === "checking") {
    versionLabel = "checking";
    versionIcon = SmallSpinnerIcon;
  } else if (versionStatus === "update-available") {
    versionLabel = "update available";
    versionIcon = ExclamationMarkIcon;
    currentVersionLabel = `${currentVersion} → ${latestVersion}`;
  } else if (versionStatus === "outdated") {
    versionLabel = "outdated";
    versionIcon = ExclamationMarkTriangleIcon;
    currentVersionLabel = `${currentVersion} → ${latestVersion}`;
  }

  let asideLabel = "";
  if (showDevConsole === "auto") {
    asideLabel = "(localhost only)";
  } else if (showDevConsole === true) {
    asideLabel = "(always on)";
  }

  const installCommand = [
    `npm install`,
    `@copilotkit/react-core@${latestVersion}`,
    `@copilotkit/react-ui@${latestVersion}`,
    `@copilotkit/react-textarea@${latestVersion}`,
  ].join(" ");

  const handleCopyClick = () => {
    navigator.clipboard.writeText(installCommand.trim()).then(() => {
      setCopyStatus("Command copied to clipboard!");
      setTimeout(() => setCopyStatus(""), 1000);
    });
  };

  return (
    <div className="copilotKitVersionInfo">
      <header>
        COPILOTKIT DEV CONSOLE{showDevConsole === "auto" && <aside>{asideLabel}</aside>}
      </header>
      <section>
        Version: {versionLabel} ({currentVersionLabel}) {versionIcon}
      </section>
      {(versionStatus === "update-available" || versionStatus === "outdated") && (
        <footer>
          <button onClick={handleCopyClick}>{copyStatus || installCommand}</button>
        </footer>
      )}
    </div>
  );
}
export default function DebugMenuButton({
  setShowDevConsole,
  checkForUpdates,
  mode,
}: {
  setShowDevConsole: (show: boolean) => void;
  checkForUpdates: (force: boolean) => void;
  mode: "full" | "compact";
}) {
  const context = useCopilotContext();

  return (
    <div className="bg-black fixed top-24 w-52 text-right">
      <Menu>
        <MenuButton className={`copilotKitDebugMenuButton ${mode === "compact" ? "compact" : ""}`}>
          {mode == "compact" ? "Debug" : <>Debug {ChevronDownIcon}</>}
        </MenuButton>

        <MenuItems
          transition
          anchor="bottom end"
          className="copilotKitDebugMenu"
          style={{ zIndex: 40 }}
        >
          <MenuItem>
            <button className="copilotKitDebugMenuItem" onClick={() => logReadables(context)}>
              Log Readables
            </button>
          </MenuItem>
          <MenuItem>
            <button className="copilotKitDebugMenuItem" onClick={() => logActions(context)}>
              Log Actions
            </button>
          </MenuItem>
          <MenuItem>
            <button className="copilotKitDebugMenuItem" onClick={() => logMessages(context)}>
              Log Messages
            </button>
          </MenuItem>
          <MenuItem>
            <button className="copilotKitDebugMenuItem" onClick={() => checkForUpdates(true)}>
              Check for Updates
            </button>
          </MenuItem>
          <hr />
          <MenuItem>
            <button className="copilotKitDebugMenuItem" onClick={() => setShowDevConsole(false)}>
              Hide Dev Console
            </button>
          </MenuItem>
        </MenuItems>
      </Menu>
    </div>
  );
}



---
File: /CopilotKit/packages/react-ui/src/components/dev-console/icons.tsx
---

export const ExclamationMarkTriangleIcon = (
  <svg
    width="13.3967723px"
    height="12px"
    viewBox="0 0 13.3967723 12"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
      <g id="exclamation-triangle" fill="#CD2121">
        <path
          d="M5.39935802,0.75 C5.97670802,-0.25 7.42007802,-0.25 7.99742802,0.75 L13.193588,9.75 C13.770888,10.75 13.049288,12 11.894588,12 L1.50223802,12 C0.34753802,12 -0.37414898,10.75 0.20319802,9.75 L5.39935802,0.75 Z M6.69838802,2.5 C7.11260802,2.5 7.44838802,2.83579 7.44838802,3.25 L7.44838802,6.25 C7.44838802,6.66421 7.11260802,7 6.69838802,7 C6.28417802,7 5.94838802,6.66421 5.94838802,6.25 L5.94838802,3.25 C5.94838802,2.83579 6.28417802,2.5 6.69838802,2.5 Z M6.69838802,10.5 C7.25067802,10.5 7.69838802,10.0523 7.69838802,9.5 C7.69838802,8.9477 7.25067802,8.5 6.69838802,8.5 C6.14610802,8.5 5.69838802,8.9477 5.69838802,9.5 C5.69838802,10.0523 6.14610802,10.5 6.69838802,10.5 Z"
          id="Shape"
        ></path>
      </g>
    </g>
  </svg>
);

export const ExclamationMarkIcon = (
  <svg
    width="14px"
    height="14px"
    viewBox="0 0 14 14"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
      <g id="exclamation-circle" fill="#EC662C">
        <path
          d="M7,14 C10.866,14 14,10.866 14,7 C14,3.13401 10.866,0 7,0 C3.13401,0 0,3.13401 0,7 C0,10.866 3.13401,14 7,14 Z M7,3 C7.41421,3 7.75,3.33579 7.75,3.75 L7.75,6.75 C7.75,7.16421 7.41421,7.5 7,7.5 C6.58579,7.5 6.25,7.16421 6.25,6.75 L6.25,3.75 C6.25,3.33579 6.58579,3 7,3 Z M7,11 C7.55228,11 8,10.5523 8,10 C8,9.4477 7.55228,9 7,9 C6.44772,9 6,9.4477 6,10 C6,10.5523 6.44772,11 7,11 Z"
          id="Shape"
        ></path>
      </g>
    </g>
  </svg>
);

export const ChevronDownIcon = (
  <svg width="7px" height="4px" viewBox="0 0 7 4" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
      <g id="Group" fill="#000000" fillRule="nonzero">
        <path
          d="M3.71690723,3.90271086 C3.59268176,4.03242971 3.39143629,4.03242971 3.26721082,3.90271086 L0.0853966595,0.57605615 C-0.0314221035,0.444981627 -0.0279751448,0.240725043 0.0931934622,0.114040675 C0.214362069,-0.0126436935 0.409725445,-0.0162475626 0.535093061,0.105888951 L3.49205902,3.19746006 L6.44902499,0.105888951 C6.52834574,0.0168884389 6.64780588,-0.0197473458 6.7605411,0.0103538404 C6.87327633,0.0404550266 6.96130636,0.132492308 6.99009696,0.250359396 C7.01888756,0.368226483 6.98384687,0.493124608 6.89872139,0.57605615 L3.71690723,3.90271086 Z"
          id="Path"
        ></path>
      </g>
    </g>
  </svg>
);

export const CheckIcon = (
  <svg
    width="14px"
    height="14px"
    viewBox="0 0 14 14"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
      <g id="Group-2" transform="translate(-118, 0)" fill="#1BC030" fillRule="nonzero">
        <g id="Group" transform="translate(118, 0)">
          <path
            d="M0,7 C0,3.13384615 3.13384615,0 7,0 C10.8661538,0 14,3.13384615 14,7 C14,10.8661538 10.8661538,14 7,14 C3.13384615,14 0,10.8661538 0,7 Z M9.59179487,5.69764103 C9.70905818,5.54139023 9.73249341,5.33388318 9.65303227,5.15541491 C9.57357113,4.97694665 9.40367989,4.85551619 9.20909814,4.83811118 C9.01451638,4.82070616 8.82577109,4.91005717 8.71589744,5.07158974 L6.39261538,8.32389744 L5.22666667,7.15794872 C5.01450582,6.96025518 4.68389046,6.9660885 4.47883563,7.17114332 C4.27378081,7.37619815 4.26794748,7.70681351 4.46564103,7.91897436 L6.08102564,9.53435897 C6.19289944,9.64614839 6.3482622,9.70310251 6.50588106,9.69010587 C6.66349993,9.67710922 6.80743532,9.59547613 6.89948718,9.46687179 L9.59179487,5.69764103 L9.59179487,5.69764103 Z"
            id="Shape"
          ></path>
        </g>
      </g>
    </g>
  </svg>
);

export const CopilotKitIcon = (
  <svg
    width="33px"
    height="35px"
    viewBox="0 0 33 35"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
  >
    <title>bd5c9079-929b-4d55-bdc9-16d1c8181b71</title>
    <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
      <image
        x="0"
        y="0"
        width="33"
        height="35"
        xlinkHref="data:image/png;base64,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"
      ></image>
    </g>
  </svg>
);



---
File: /CopilotKit/packages/react-ui/src/components/dev-console/index.tsx
---

export { shouldShowDevConsole } from "./utils";
export { CopilotDevConsole } from "./console";



---
File: /CopilotKit/packages/react-ui/src/components/dev-console/types.ts
---

export interface CopilotKitVersion {
  current: string;
  latest: string;
  severity: "low" | "medium" | "high";
  advisory: string | null;
  lastChecked: number;
}



---
File: /CopilotKit/packages/react-ui/src/components/dev-console/utils.ts
---

import { CopilotContextParams, defaultCopilotContextCategories } from "@copilotkit/react-core";
import { CopilotKitVersion } from "./types";
import { ActionExecutionMessage, ResultMessage, TextMessage } from "@copilotkit/runtime-client-gql";
import { AgentStateMessage } from "@copilotkit/runtime-client-gql";

export function shouldShowDevConsole(showDevConsole: boolean | "auto"): boolean {
  if (typeof showDevConsole === "boolean") {
    return showDevConsole;
  }
  return (
    getHostname() === "localhost" ||
    getHostname() === "127.0.0.1" ||
    getHostname() === "0.0.0.0" ||
    getHostname() === "::1"
  );
}

function getHostname(): string {
  if (typeof window !== "undefined" && window.location) {
    return window.location.hostname;
  }
  return "";
}

export async function getPublishedCopilotKitVersion(
  current: string,
  forceCheck: boolean = false,
): Promise<CopilotKitVersion> {
  const LOCAL_STORAGE_KEY = "__copilotkit_version_check__";
  const serializedVersion = localStorage.getItem(LOCAL_STORAGE_KEY);
  if (serializedVersion && !forceCheck) {
    try {
      const parsedVersion: CopilotKitVersion = JSON.parse(serializedVersion);
      const oneHour = 60 * 60 * 1000;
      const now = new Date().getTime();

      if (
        parsedVersion.current === current &&
        now - new Date(parsedVersion.lastChecked).getTime() < oneHour
      ) {
        return parsedVersion;
      }
    } catch (error) {
      console.error("Failed to parse CopilotKitVersion from localStorage", error);
    }
  }

  try {
    const response = await fetch("https://api.cloud.stagingcopilotkit.ai/check-for-updates", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        packages: [
          {
            packageName: "@copilotkit/shared",
            packageVersion: current,
          },
        ],
      }),
    });

    const data = await response.json();

    const version: CopilotKitVersion = {
      current,
      lastChecked: new Date().getTime(),
      latest: data.packages[0].latestVersion,
      severity: data.packages[0].severity,
      advisory: data.packages[0].advisory || null,
    };

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(version));
    return version;
  } catch (error) {
    console.error("Failed to check for updates", error);
    throw error;
  }
}

export function logReadables(context: CopilotContextParams) {
  console.log("%cCurrent Readables:", "font-size: 16px; font-weight: bold;");

  const readables = context.getContextString([], defaultCopilotContextCategories).trim();
  if (readables.length === 0) {
    console.log("No readables found");
    return;
  }
  console.log(readables);
}

export function logActions(context: CopilotContextParams) {
  console.log("%cCurrent Actions:", "font-size: 16px; font-weight: bold;");

  if (Object.values(context.actions).length === 0) {
    console.log("No actions found");
    return;
  }
  for (const action of Object.values(context.actions)) {
    console.group(action.name);
    console.log("name", action.name);
    console.log("description", action.description);
    console.log("parameters", action.parameters);

    console.groupEnd();
  }
}

export function logMessages(context: CopilotContextParams) {
  console.log("%cCurrent Messages:", "font-size: 16px; font-weight: bold;");

  if (context.messages.length === 0) {
    console.log("No messages found");
    return;
  }

  const tableData = context.messages.map((message) => {
    if (message instanceof TextMessage) {
      return {
        id: message.id,
        type: "TextMessage",
        role: message.role,
        name: undefined,
        scope: undefined,
        content: message.content,
      };
    } else if (message instanceof ActionExecutionMessage) {
      return {
        id: message.id,
        type: "ActionExecutionMessage",
        role: undefined,
        name: message.name,
        scope: message.scope,
        content: message.arguments,
      };
    } else if (message instanceof ResultMessage) {
      return {
        id: message.id,
        type: "ResultMessage",
        role: undefined,
        name: message.actionName,
        scope: message.actionExecutionId,
        content: message.result,
      };
    } else if (message instanceof AgentStateMessage) {
      return {
        id: message.id,
        type: `AgentStateMessage (running: ${message.running})`,
        role: message.role,
        name: undefined,
        scope: message.threadId,
        content: message.state,
      };
    }
  });
  console.table(tableData);
}



---
File: /CopilotKit/packages/react-ui/src/components/index.ts
---

export * from "./chat";



---
File: /CopilotKit/packages/react-ui/src/context/index.ts
---

export {};



---
File: /CopilotKit/packages/react-ui/src/css/animations.css
---

.copilotKitActivityDot1 {
  animation: copilotKitActivityDotsAnimation 1.05s infinite;
}
.copilotKitActivityDot2 {
  animation-delay: 0.1s;
}
.copilotKitActivityDot3 {
  animation-delay: 0.2s;
}
@keyframes copilotKitActivityDotsAnimation {
  0%,
  57.14% {
    animation-timing-function: cubic-bezier(0.33, 0.66, 0.66, 1);
    transform: translate(0);
  }
  28.57% {
    animation-timing-function: cubic-bezier(0.33, 0, 0.66, 0.33);
    transform: translateY(-6px);
  }
  100% {
    transform: translate(0);
  }
}

@keyframes copilotKitSpinAnimation {
  to {
    transform: rotate(360deg);
  }
}

@keyframes copilotKitPulseAnimation {
  50% {
    opacity: 0.5;
  }
}



---
File: /CopilotKit/packages/react-ui/src/css/button.css
---

.copilotKitButton {
  width: 3.5rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  outline: none;
  position: relative;
  transform: scale(1);
  transition: transform 200ms;
  background-color: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  cursor: pointer;
}

.copilotKitButton:hover {
  transform: scale(1.1);
}

.copilotKitButton:active {
  transform: scale(0.75);
}

.copilotKitButtonIcon {
  transition:
    opacity 100ms,
    transform 300ms;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* State when the chat is open */
.copilotKitButton.open .copilotKitButtonIconOpen {
  transform: translate(-50%, -50%) scale(0) rotate(90deg);
  opacity: 0;
}

.copilotKitButton.open .copilotKitButtonIconClose {
  transform: translate(-50%, -50%) scale(1) rotate(0deg);
  opacity: 1;
}

/* State when the chat is closed */
.copilotKitButton:not(.open) .copilotKitButtonIconOpen {
  transform: translate(-50%, -50%) scale(1) rotate(0deg);
  opacity: 1;
}

.copilotKitButton:not(.open) .copilotKitButtonIconClose {
  transform: translate(-50%, -50%) scale(0) rotate(-90deg);
  opacity: 0;
}



---
File: /CopilotKit/packages/react-ui/src/css/colors.css
---

html {
  --copilot-kit-primary-color: rgb(59 130 246);
  --copilot-kit-contrast-color: rgb(255 255 255);
  --copilot-kit-secondary-color: rgb(243 244 246);
  --copilot-kit-secondary-contrast-color: rgb(0 0 0);
  --copilot-kit-background-color: rgb(255 255 255);
  --copilot-kit-muted-color: rgb(106 106 106);
  --copilot-kit-separator-color: rgba(0, 0, 0, 0.08);
  --copilot-kit-scrollbar-color: rgba(0, 0, 0, 0.2);
  --copilot-kit-response-button-color: #333;
  --copilot-kit-response-button-background-color: #fff;
}



---
File: /CopilotKit/packages/react-ui/src/css/console.css
---

.copilotKitDevConsole {
  background-color: #f3f4f6;
  padding-left: 10px;
  padding-right: 10px;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #cecece;
  padding-top: 10px;
  padding-bottom: 10px;
}

.copilotKitDevConsole.copilotKitDevConsoleWarnOutdated {
  background-color: #f9caca;
}

.copilotKitDevConsole .copilotKitVersionInfo {
  flex: 1;
  margin-left: 18px;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.copilotKitDevConsole .copilotKitVersionInfo header {
  font-size: 11px;
  font-weight: bold;
}

.copilotKitDevConsole .copilotKitVersionInfo footer {
  margin-top: 10px;
}

.copilotKitDevConsole .copilotKitVersionInfo footer button {
  font-size: 11px;
  font-weight: normal;
  font-family: monospace;
  background-color: white;
  border: 1px solid #979797;
  padding: 1px 12px;
  padding-left: 5px;
  border-radius: 4px;
  display: inline-block;
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  width: 260px;
  text-overflow: ellipsis;
}

.copilotKitDevConsole .copilotKitVersionInfo header aside {
  display: inline;
  font-weight: normal;
  color: #7f7a7a;
  margin-left: 5px;
}

.copilotKitDevConsole .copilotKitVersionInfo section {
  font-size: 11px;
}

.copilotKitDevConsole .copilotKitVersionInfo section svg {
  margin-left: 3px;
  margin-top: -3px;
}

.copilotKitDevConsole .copilotKitDebugMenuButton {
  font-size: 11px;
  font-weight: bold;
  display: flex;
  width: 90px;
  height: 30px;
  background-color: #d8d8d8;
  border: 1px solid #979797;
  border-radius: 6px;
  align-items: center;
  justify-content: center;
  outline: none;
}

.copilotKitDebugMenuButton.compact {
  width: 35px;
  color: black;
  justify-content: center;
  outline: none;
  font-size: 8px;
}

.copilotKitDevConsole .copilotKitDebugMenuButton:hover {
  background-color: #c7c7c7;
}

.copilotKitDevConsole .copilotKitDebugMenuButton > svg {
  margin-left: 10px;
}

.copilotKitDebugMenu {
  background-color: #d8d8d8;
  margin-top: 2px;
  border-radius: 6px;
  border: 1px solid #979797;
  padding: 0.25rem;
  outline: none;
  font-size: 13px;
}

.copilotKitDebugMenuItem {
  padding-top: 3px;
  padding-bottom: 3px;
  padding-left: 10px;
  padding-right: 10px;
  display: block;
  width: 100%;
  text-align: left;
  background: none;
  border: none;
  cursor: pointer;
}

.copilotKitDebugMenuItem:hover {
  background-color: #c7c7c7;
  border-radius: 4px;
}

.copilotKitDebugMenu[data-closed] {
  transform: scale(0.95); /* data-[closed]:scale-95 */
  opacity: 0; /* data-[closed]:opacity-0 */
}

.copilotKitDebugMenu hr {
  height: 1px;
  border: none; /* Remove 3D look */
  background-color: #979797; /* Set color */
  margin: 0.25rem;
}



---
File: /CopilotKit/packages/react-ui/src/css/header.css
---

.copilotKitHeader {
  height: 56px;
  font-weight: 500;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  background-color: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom: 1px solid var(--copilot-kit-separator-color);
}

.copilotKitSidebar .copilotKitHeader {
  border-radius: 0;
}

@media (min-width: 640px) {
  .copilotKitHeader {
    padding-left: 24px;
    padding-right: 24px;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
  }
}

.copilotKitHeader > button {
  border: 0;
  padding: 0px;
  position: absolute;
  top: 50%;
  right: 16px;
  transform: translateY(-50%);
  outline: none;
  color: var(--copilot-kit-contrast-color);
  background-color: transparent;
  cursor: pointer;
}

.copilotKitHeader > button:focus {
  outline: none;
}



---
File: /CopilotKit/packages/react-ui/src/css/input.css
---

.copilotKitInput {
  border-top: 1px solid var(--copilot-kit-separator-color);
  padding-left: 2rem;
  padding-right: 1rem;
  padding-top: 1rem;
  padding-bottom: 1rem;
  display: flex;
  align-items: center;
  cursor: text;
  position: relative;
  border-bottom-left-radius: 0.75rem;
  border-bottom-right-radius: 0.75rem;
  background-color: var(--copilot-kit-background-color);
}

.copilotKitInput > .copilotKitInputControls > button {
  padding: 0.25rem;
  cursor: pointer;
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  transform: scale(1);
  color: rgba(0, 0, 0, 0.25);
  -webkit-appearance: button;
  appearance: button;
  background-color: transparent;
  background-image: none;
  text-transform: none;
  font-family: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  border: 0;
  margin: 0;
  text-indent: 0px;
  text-shadow: none;
  display: inline-block;
  text-align: center;
  margin-left: 0.5rem; /* Add margin to separate button from textarea */
}

.copilotKitInput > .copilotKitInputControls > button:not([disabled]) {
  color: var(--copilot-kit-primary-color);
}

.copilotKitInput > .copilotKitInputControls > button:not([disabled]):hover {
  transform: scale(1.1);
}

.copilotKitInput > .copilotKitInputControls > button[disabled] {
  color: var(--copilot-kit-muted-color);
}

.copilotKitInputControls {
  display: flex;
}

.copilotKitInput > textarea {
  flex: 1; /* Allow textarea to take up remaining space */
  outline: 2px solid transparent;
  outline-offset: 2px;
  resize: none;
  white-space: pre-wrap;
  overflow-wrap: break-word;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  cursor: text;
  font-size: 0.875rem;
  line-height: 1.25rem;
  margin: 0;
  padding: 0;
  font-family: inherit;
  font-weight: inherit;
  color: var(--copilot-kit-secondary-contrast-color);
  border: 0px;
  background-color: var(--copilot-kit-background-color);
}

.copilotKitInput > textarea::placeholder {
  color: var(--copilot-kit-muted-color);
  opacity: 1;
}

.copilotKitInput > .copilotKitInputControls > button.copilotKitPushToTalkRecording {
  background-color: red;
  color: white;
  border-radius: 50%;
  animation: copilotKitPulseAnimation 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}



---
File: /CopilotKit/packages/react-ui/src/css/markdown.css
---

.copilotKitMarkdown h1,
.copilotKitMarkdown h2,
.copilotKitMarkdown h3,
.copilotKitMarkdown h4,
.copilotKitMarkdown h5,
.copilotKitMarkdown h6 {
  font-weight: bold;
  line-height: 1.2;
}

.copilotKitMarkdown h1:not(:last-child),
.copilotKitMarkdown h2:not(:last-child),
.copilotKitMarkdown h3:not(:last-child),
.copilotKitMarkdown h4:not(:last-child),
.copilotKitMarkdown h5:not(:last-child),
.copilotKitMarkdown h6:not(:last-child) {
  margin-bottom: 1rem;
}

.copilotKitMarkdown h1 {
  font-size: 1.5em;
}

.copilotKitMarkdown h2 {
  font-size: 1.25em;
  font-weight: 600;
}

.copilotKitMarkdown h3 {
  font-size: 1.1em;
}

.copilotKitMarkdown h4 {
  font-size: 1em;
}

.copilotKitMarkdown h5 {
  font-size: 0.9em;
}

.copilotKitMarkdown h6 {
  font-size: 0.8em;
}

.copilotKitMarkdown p:not(:last-child),
.copilotKitMarkdown pre:not(:last-child),
.copilotKitMarkdown ol:not(:last-child),
.copilotKitMarkdown ul:not(:last-child),
.copilotKitMarkdown blockquote:not(:last-child) {
  margin-bottom: 1.25em;
}

.copilotKitMarkdown blockquote {
  border-color: rgb(142, 142, 160);
  border-left-width: 2px;
  border-left-style: solid;
  line-height: 1.2;
  padding-left: 10px;
}

.copilotKitMarkdown blockquote p {
  padding: 0.7em 0;
}

.copilotKitMarkdown ul {
  list-style-type: disc;
  padding-left: 20px;
  overflow: visible;
}

.copilotKitMarkdown li {
  list-style-type: inherit;
  list-style-position: outside;
  margin-left: 0;
  padding-left: 0;
  position: relative;
  overflow: visible;
}

.copilotKitCodeBlock {
  position: relative;
  width: 100%;
  background-color: rgb(9 9 11);
  border-radius: 0.375rem;
}

.copilotKitCodeBlockToolbar {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  background-color: rgb(39 39 42);
  padding-left: 1rem;
  padding-top: 0.09rem;
  padding-bottom: 0.09rem;
  color: rgb(228, 228, 228);
  border-top-left-radius: 0.375rem;
  border-top-right-radius: 0.375rem;
  font-family: sans-serif;
}

.copilotKitCodeBlockToolbarLanguage {
  font-size: 0.75rem;
  line-height: 1rem;
  text-transform: lowercase;
}

.copilotKitCodeBlockToolbarButtons {
  display: flex;
  align-items: center;
  margin-right: 0.25rem;
  margin-left: 0.25rem;
}

.copilotKitCodeBlockToolbarButton {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 500;
  height: 2.5rem;
  width: 2.5rem;
  padding: 3px;
  margin: 2px;
}

.copilotKitCodeBlockToolbarButton:hover {
  background-color: rgb(55, 55, 58);
}



---
File: /CopilotKit/packages/react-ui/src/css/messages.css
---

.copilotKitMessages {
  overflow-y: scroll;
  flex: 1;
  padding: 1rem 2rem;
  display: flex;
  flex-direction: column;
  background-color: var(--copilot-kit-background-color);
}

.copilotKitMessages::-webkit-scrollbar {
  width: 9px;
}

.copilotKitMessages::-webkit-scrollbar-thumb {
  background-color: var(--copilot-kit-scrollbar-color);
  border-radius: 10rem;
  border: 2px solid var(--copilot-kit-background-color);
}

.copilotKitMessages::-webkit-scrollbar-track-piece:start {
  background: transparent;
}

.copilotKitMessages::-webkit-scrollbar-track-piece:end {
  background: transparent;
}

.copilotKitMessage {
  border-radius: 0.5rem;
  padding: 1rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  overflow-wrap: break-word;
  max-width: 80%;
  margin-bottom: 0.5rem;
}

.copilotKitMessage.copilotKitUserMessage {
  background: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  margin-left: auto;
  white-space: pre-wrap;
}

.copilotKitMessage.copilotKitAssistantMessage {
  background: var(--copilot-kit-secondary-color);
  color: var(--copilot-kit-secondary-contrast-color);
  margin-right: auto;
}

.copilotKitMessage.copilotKitUserMessage + .copilotKitMessage.copilotKitAssistantMessage {
  margin-top: 1.5rem;
}

.copilotKitMessage.copilotKitAssistantMessage + .copilotKitMessage.copilotKitUserMessage {
  margin-top: 1.5rem;
}

.copilotKitCustomAssistantMessage {
  margin-top: 1.5rem;
  margin-bottom: 1.5rem;
}

.copilotKitMessage .inProgressLabel {
  margin-left: 10px;
}

.copilotKitMessages footer {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}



---
File: /CopilotKit/packages/react-ui/src/css/panel.css
---

.copilotKitChat {
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family:
    ui-sans-serif,
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    "Helvetica Neue",
    Arial,
    "Noto Sans",
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol",
    "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
  display: flex;
  flex-direction: column;
  /* height: 100%; */
}

.copilotKitChat svg {
  display: inline-block;
  vertical-align: middle;
}

.copilotKitChat .copilotKitMessages {
  flex-grow: 1;
}



---
File: /CopilotKit/packages/react-ui/src/css/popup.css
---

.copilotKitPopup {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
}

.copilotKitPopup svg {
  display: inline-block;
  vertical-align: middle;
}



---
File: /CopilotKit/packages/react-ui/src/css/response.css
---

.copilotKitResponseButton {
  background-color: var(--copilot-kit-response-button-background-color);
  border: 1px solid var(--copilot-kit-separator-color);
  border-radius: 4px;
  color: var(--copilot-kit-response-button-color);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  height: 32px;
  line-height: 30px;
  margin: 0;
  padding: 0 16px;
  text-align: center;
  text-decoration: none;
  text-transform: none;
  white-space: nowrap;
  margin-top: 15px;
}

.copilotKitResponseButton:hover {
  filter: brightness(95%);
}

.copilotKitResponseButton > span {
  margin-right: 0.5rem;
}



---
File: /CopilotKit/packages/react-ui/src/css/sidebar.css
---

.copilotKitSidebar {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
}

.copilotKitSidebar svg {
  display: inline-block;
  vertical-align: middle;
}

.copilotKitSidebarContentWrapper {
  overflow: visible;
  margin-right: 0px;
  transition: margin-right 0.3s ease;
}

@media (min-width: 640px) {
  .copilotKitSidebarContentWrapper.sidebarExpanded {
    margin-right: 28rem;
  }
}



---
File: /CopilotKit/packages/react-ui/src/css/suggestions.css
---

.copilotKitMessages footer .suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.copilotKitMessages footer h6 {
  font-weight: 500;
  font-size: 0.7rem;
  margin-bottom: 8px;
}

.copilotKitMessages footer .suggestions .suggestion {
  padding: 8px 12px;
  font-size: 0.7rem;
  border-radius: 0.5rem;
  background: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
}

.copilotKitMessages footer .suggestions button {
  transition: transform 0.3s ease;
}

.copilotKitMessages footer .suggestions button:not(:disabled):hover {
  transform: scale(1.05);
}

.copilotKitMessages footer .suggestions button:disabled {
  cursor: wait;
}

.copilotKitMessages footer .suggestions button svg {
  margin-right: 6px;
}



---
File: /CopilotKit/packages/react-ui/src/css/window.css
---

.copilotKitWindow {
  position: fixed;
  inset: 0px;
  transform-origin: bottom;
  border-color: rgb(229 231 235);
  background-color: rgb(255 255 255);
  border-radius: 0.75rem;
  box-shadow: rgba(0, 0, 0, 0.16) 0px 5px 40px;
  flex-direction: column;
  transition:
    opacity 100ms ease-out,
    transform 200ms ease-out;
  opacity: 0;
  transform: scale(0.95) translateY(20px);
  display: flex;
  pointer-events: none;
}

.copilotKitSidebar .copilotKitWindow {
  border-radius: 0;
  opacity: 1;
  transform: translateX(100%);
}

.copilotKitWindow.open {
  opacity: 1;
  transform: scale(1) translateY(0);
  pointer-events: auto;
}

.copilotKitSidebar .copilotKitWindow.open {
  transform: translateX(0);
}

@media (min-width: 640px) {
  .copilotKitWindow {
    transform-origin: bottom right;
    bottom: 5rem;
    right: 1rem;
    top: auto;
    left: auto;
    border-width: 0px;
    margin-bottom: 1rem;
    width: 24rem;
    height: 600px;
    min-height: 200px;
    max-height: calc(100% - 6rem);
  }

  .copilotKitSidebar .copilotKitWindow {
    bottom: 0;
    right: 0;
    top: auto;
    left: auto;
    width: 28rem;
    min-height: 100%;
    margin-bottom: 0;
    max-height: none;
  }
}



---
File: /CopilotKit/packages/react-ui/src/hooks/index.ts
---

export * from "./use-copilot-chat-suggestions";



---
File: /CopilotKit/packages/react-ui/src/hooks/use-copilot-chat-suggestions.tsx
---

/**
 * <Callout type="warning">
 *   useCopilotChatSuggestions is experimental. The interface is not final and
 *   can change without notice.
 * </Callout>
 *
 * `useCopilotReadable` is a React hook that provides app-state and other information
 * to the Copilot. Optionally, the hook can also handle hierarchical state within your
 * application, passing these parent-child relationships to the Copilot.
 *
 * <br/>
 * <img src="/images/use-copilot-chat-suggestions/use-copilot-chat-suggestions.gif" width="500" />
 *
 * ## Usage
 *
 * ### Install Dependencies
 *
 * This component is part of the [@copilotkit/react-ui](https://npmjs.com/package/@copilotkit/react-ui) package.
 *
 * ```shell npm2yarn \"@copilotkit/react-ui"\
 * npm install @copilotkit/react-core @copilotkit/react-ui
 * ```
 *
 * ### Simple Usage
 *
 * ```tsx
 * import { useCopilotChatSuggestions } from "@copilotkit/react-ui";
 *
 * export function MyComponent() {
 *   const [employees, setEmployees] = useState([]);
 *
 *   useCopilotChatSuggestions({
 *     instructions: `The following employees are on duty: ${JSON.stringify(employees)}`,
 *   });
 * }
 * ```
 *
 * ### Dependency Management
 *
 * ```tsx
 * import { useCopilotChatSuggestions } from "@copilotkit/react-ui";
 *
 * export function MyComponent() {
 *   useCopilotChatSuggestions(
 *     {
 *       instructions: "Suggest the most relevant next actions.",
 *     },
 *     [appState],
 *   );
 * }
 * ```
 *
 * In the example above, the suggestions are generated based on the given instructions.
 * The hook monitors `appState`, and updates suggestions accordingly whenever it changes.
 *
 * ### Behavior and Lifecycle
 *
 * The hook registers the configuration with the chat context upon component mount and
 * removes it on unmount, ensuring a clean and efficient lifecycle management.
 */

import { useEffect } from "react";
import { useCopilotContext } from "@copilotkit/react-core";
import { randomId } from "@copilotkit/shared";

interface UseCopilotChatSuggestionsConfiguration {
  /**
   * A prompt or instructions for the GPT to generate suggestions.
   */
  instructions: string;
  /**
   * The minimum number of suggestions to generate. Defaults to `1`.
   * @default 1
   */
  minSuggestions?: number;
  /**
   * The maximum number of suggestions to generate. Defaults to `3`.
   * @default 1
   */
  maxSuggestions?: number;
  /**
   * An optional class name to apply to the suggestions.
   */
  className?: string;
}

export function useCopilotChatSuggestions(
  {
    instructions,
    className,
    minSuggestions = 1,
    maxSuggestions = 3,
  }: UseCopilotChatSuggestionsConfiguration,
  dependencies: any[] = [],
) {
  const context = useCopilotContext();

  useEffect(() => {
    const id = randomId();

    context.addChatSuggestionConfiguration(id, {
      instructions,
      minSuggestions,
      maxSuggestions,
      className,
    });

    return () => {
      context.removeChatSuggestionConfiguration(id);
    };
  }, dependencies);
}



---
File: /CopilotKit/packages/react-ui/src/hooks/use-copy-to-clipboard.tsx
---

import * as React from "react";

export interface useCopyToClipboardProps {
  timeout?: number;
}

export function useCopyToClipboard({ timeout = 2000 }: useCopyToClipboardProps) {
  const [isCopied, setIsCopied] = React.useState<Boolean>(false);

  const copyToClipboard = (value: string) => {
    if (typeof window === "undefined" || !navigator.clipboard?.writeText) {
      return;
    }

    if (!value) {
      return;
    }

    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);

      setTimeout(() => {
        setIsCopied(false);
      }, timeout);
    });
  };

  return { isCopied, copyToClipboard };
}



---
File: /CopilotKit/packages/react-ui/src/hooks/use-push-to-talk.tsx
---

import { useCopilotContext } from "@copilotkit/react-core";
import { Message, TextMessage } from "@copilotkit/runtime-client-gql";
import { MutableRefObject, useEffect, useRef, useState } from "react";

export const checkMicrophonePermission = async () => {
  try {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone" as PermissionName,
    });
    if (permissionStatus.state === "granted") {
      return true;
    } else {
      return false;
    }
  } catch (err) {
    console.error("Error checking microphone permission", err);
  }
};

export const requestMicAndPlaybackPermission = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioContext = new window.AudioContext();
    await audioContext.resume();
    return { stream, audioContext };
  } catch (err) {
    console.error("Error requesting microphone and playback permissions", err);
    return null;
  }
};

const startRecording = async (
  mediaStreamRef: MutableRefObject<MediaStream | null>,
  mediaRecorderRef: MutableRefObject<MediaRecorder | null>,
  audioContextRef: MutableRefObject<AudioContext | null>,
  recordedChunks: Blob[],
  onStop: () => void,
) => {
  if (!mediaStreamRef.current || !audioContextRef.current) {
    mediaStreamRef.current = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContextRef.current = new window.AudioContext();
    await audioContextRef.current.resume();
  }

  mediaRecorderRef.current = new MediaRecorder(mediaStreamRef.current!);
  mediaRecorderRef.current.start(1000);
  mediaRecorderRef.current.ondataavailable = (event) => {
    recordedChunks.push(event.data);
  };
  mediaRecorderRef.current.onstop = onStop;
};

const stopRecording = (mediaRecorderRef: MutableRefObject<MediaRecorder | null>) => {
  if (mediaRecorderRef.current && mediaRecorderRef.current.state !== "inactive") {
    mediaRecorderRef.current.stop();
  }
};

const transcribeAudio = async (recordedChunks: Blob[], transcribeAudioUrl: string) => {
  const completeBlob = new Blob(recordedChunks, { type: "audio/mp4" });
  const formData = new FormData();
  formData.append("file", completeBlob, "recording.mp4");

  const response = await fetch(transcribeAudioUrl, {
    method: "POST",
    body: formData,
  });

  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }

  const transcription = await response.json();
  return transcription.text;
};

const playAudioResponse = (text: string, textToSpeechUrl: string, audioContext: AudioContext) => {
  const encodedText = encodeURIComponent(text);
  const url = `${textToSpeechUrl}?text=${encodedText}`;

  fetch(url)
    .then((response) => response.arrayBuffer())
    .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))
    .then((audioBuffer) => {
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);
      source.start(0);
    })
    .catch((error) => {
      console.error("Error with decoding audio data", error);
    });
};

export type PushToTalkState = "idle" | "recording" | "transcribing";

export type SendFunction = (text: string) => Promise<Message>;

export const usePushToTalk = ({
  sendFunction,
  inProgress,
}: {
  sendFunction: SendFunction;
  inProgress: boolean;
}) => {
  const [pushToTalkState, setPushToTalkState] = useState<PushToTalkState>("idle");
  const mediaStreamRef = useRef<MediaStream | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const recordedChunks = useRef<Blob[]>([]);
  const context = useCopilotContext();
  const [startReadingFromMessageId, setStartReadingFromMessageId] = useState<string | null>(null);

  useEffect(() => {
    if (pushToTalkState === "recording") {
      startRecording(
        mediaStreamRef,
        mediaRecorderRef,
        audioContextRef,
        recordedChunks.current,
        () => {
          setPushToTalkState("transcribing");
        },
      );
    } else {
      stopRecording(mediaRecorderRef);
      if (pushToTalkState === "transcribing") {
        transcribeAudio(recordedChunks.current, context.copilotApiConfig.transcribeAudioUrl!).then(
          async (transcription) => {
            recordedChunks.current = [];
            setPushToTalkState("idle");
            const message = await sendFunction(transcription);
            setStartReadingFromMessageId(message.id);
          },
        );
      }
    }

    return () => {
      stopRecording(mediaRecorderRef);
    };
  }, [pushToTalkState]);

  useEffect(() => {
    if (inProgress === false && startReadingFromMessageId) {
      const lastMessageIndex = context.messages.findIndex(
        (message) => message.id === startReadingFromMessageId,
      );

      const messagesAfterLast = context.messages
        .slice(lastMessageIndex + 1)
        .filter(
          (message) => message instanceof TextMessage && message.role === "assistant",
        ) as TextMessage[];

      const text = messagesAfterLast.map((message) => message.content).join("\n");
      playAudioResponse(text, context.copilotApiConfig.textToSpeechUrl!, audioContextRef.current!);

      setStartReadingFromMessageId(null);
    }
  }, [startReadingFromMessageId, inProgress]);

  return { pushToTalkState, setPushToTalkState };
};



---
File: /CopilotKit/packages/react-ui/src/lib/utils.test.ts
---

import * as utils from "./utils";

describe("emptyTest", () => {
  it("should be truthy", () => {
    expect(true).toBeTruthy();
  });
});



---
File: /CopilotKit/packages/react-ui/src/lib/utils.ts
---

export async function fetcher<JSON = any>(input: RequestInfo, init?: RequestInit): Promise<JSON> {
  const res = await fetch(input, init);

  if (!res.ok) {
    const json = await res.json();
    if (json.error) {
      const error = new Error(json.error) as Error & {
        status: number;
      };
      error.status = res.status;
      throw error;
    } else {
      throw new Error("An unexpected error occurred");
    }
  }

  return res.json();
}

export function formatDate(input: string | number | Date): string {
  const date = new Date(input);
  return date.toLocaleDateString("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
  });
}



---
File: /CopilotKit/packages/react-ui/src/types/css.ts
---

// autogenerated (see postcss.config.js) - do not edit
import { CSSProperties } from "react";

export interface CopilotKitCSSProperties extends CSSProperties {
  "--copilot-kit-primary-color"?: string;
  "--copilot-kit-contrast-color"?: string;
  "--copilot-kit-secondary-color"?: string;
  "--copilot-kit-secondary-contrast-color"?: string;
  "--copilot-kit-background-color"?: string;
  "--copilot-kit-muted-color"?: string;
  "--copilot-kit-separator-color"?: string;
  "--copilot-kit-scrollbar-color"?: string;
  "--copilot-kit-response-button-color"?: string;
  "--copilot-kit-response-button-background-color"?: string;
}



---
File: /CopilotKit/packages/react-ui/src/types/index.ts
---

export type { CopilotKitCSSProperties } from "./css";



---
File: /CopilotKit/packages/react-ui/src/types/suggestions.ts
---

export interface CopilotChatSuggestion {
  title: string;
  message: string;
  partial?: boolean;
  className?: string;
}



---
File: /CopilotKit/packages/react-ui/src/index.tsx
---

"use client";
import "./styles.css";

export * from "./components";
export * from "./context";
export * from "./hooks";
export * from "./types";



---
File: /CopilotKit/packages/react-ui/src/styles.css
---

@import "./css/colors.css";
@import "./css/popup.css";
@import "./css/sidebar.css";
@import "./css/button.css";
@import "./css/header.css";
@import "./css/input.css";
@import "./css/messages.css";
@import "./css/window.css";
@import "./css/animations.css";
@import "./css/response.css";
@import "./css/markdown.css";
@import "./css/suggestions.css";
@import "./css/panel.css";
@import "./css/console.css";



---
File: /CopilotKit/packages/react-ui/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/react-ui/postcss.config.js
---

const path = require("path");
const fs = require("fs");

let didCreateInterface = false;

module.exports = {
  plugins: [
    {
      postcssPlugin: "postcss-collect-all-variables",
      Once(root) {
        if (didCreateInterface) return;

        const filename = path.basename(root.source.input.file);
        if (filename === "colors.css") {
          const variables = {};

          root.walkDecls((decl) => {
            if (decl.prop.startsWith("--")) {
              variables[decl.prop] = decl.value;
            }
          });

          // Create TypeScript interface
          const interfaceContent = generateInterface(variables);

          // Ensure the directory exists
          const dir = path.resolve(__dirname, "src/types");
          if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
          }

          // Write the interface to the file
          const filePath = path.resolve(dir, "css.ts");
          fs.writeFileSync(filePath, interfaceContent);

          didCreateInterface = true;
        }
      },
    },
    // require("tailwindcss"),
    // require("autoprefixer"),
  ],
};

function generateInterface(variables) {
  const interfaceLines = [
    "// autogenerated (see postcss.config.js) - do not edit",
    'import { CSSProperties } from "react";',
    "",
    "export interface CopilotKitCSSProperties extends CSSProperties {",
  ];

  for (const [prop, value] of Object.entries(variables)) {
    interfaceLines.push(`  "${prop}"?: string;`);
  }

  interfaceLines.push("}");

  return interfaceLines.join("\n") + "\n";
}



---
File: /CopilotKit/packages/react-ui/tailwind.config.js
---

const sharedConfig = require("tailwind-config/tailwind.config.js");

module.exports = {
  // prefix ui lib classes to avoid conflicting with the app
  // prefix: "ui-",
  presets: [sharedConfig],
};



---
File: /CopilotKit/packages/react-ui/tsup.config.ts
---

import { defineConfig, Options } from "tsup";

export default defineConfig((options: Options) => ({
  entry: ["src/**/*.{ts,tsx}"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: ["react"],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
  ...options,
}));



---
File: /CopilotKit/packages/runtime/scripts/generate-gql-schema.ts
---

import "reflect-metadata";
import { buildSchema } from "../src/lib/integrations/shared";
import path from "node:path";

console.log("Generating schema...");

const outputPath = path.resolve(__dirname, "../__snapshots__/schema/schema.graphql");

buildSchema({
  emitSchemaFile: path.resolve(__dirname, outputPath),
});

console.log(`Schema generated to ${outputPath}`);



---
File: /CopilotKit/packages/runtime/src/agents/langgraph/event-source.ts
---

import { ReplaySubject, scan, mergeMap, catchError } from "rxjs";
import { LangGraphEvent, LangGraphEventTypes } from "./events";
import { RuntimeEvent, RuntimeEventTypes } from "../../service-adapters/events";
import { randomId } from "@copilotkit/shared";

interface LangGraphEventWithState {
  event: LangGraphEvent | null;
  toolCallName: string | null;
  toolCallId: string | null;
  toolCallMessageId: string | null;
  prevToolCallMessageId: string | null;
  messageId: string | null;
  prevMessageId: string | null;
}

export class RemoteLangGraphEventSource {
  private eventStream$ = new ReplaySubject<LangGraphEvent>();

  async streamResponse(response: Response) {
    const reader = response.body!.getReader();
    const decoder = new TextDecoder();
    let buffer = [];
    const eventStream$ = this.eventStream$;

    function flushBuffer() {
      const currentBuffer = buffer.join("");
      if (currentBuffer.trim().length === 0) {
        return;
      }
      const parts = currentBuffer.split("\n");
      if (parts.length === 0) {
        return;
      }

      const lastPartIsComplete = currentBuffer.endsWith("\n");

      // truncate buffer
      buffer = [];

      if (!lastPartIsComplete) {
        // put back the last part
        buffer.push(parts.pop());
      }

      parts
        .map((part) => part.trim())
        .filter((part) => part != "")
        .forEach((part) => {
          eventStream$.next(JSON.parse(part));
        });
    }

    try {
      while (true) {
        const { done, value } = await reader.read();

        if (!done) {
          buffer.push(decoder.decode(value, { stream: true }));
        }

        flushBuffer();

        if (done) {
          break;
        }
      }
    } catch (error) {
      console.error("Error in stream", error);
      eventStream$.error(error);
      return;
    }
    eventStream$.complete();
  }

  private shouldEmitToolCall(
    shouldEmitToolCalls: string | string[] | boolean,
    toolCallName: string,
  ) {
    if (typeof shouldEmitToolCalls === "boolean") {
      return shouldEmitToolCalls;
    }
    if (Array.isArray(shouldEmitToolCalls)) {
      return shouldEmitToolCalls.includes(toolCallName);
    }
    return shouldEmitToolCalls === toolCallName;
  }

  processLangGraphEvents() {
    let lastEventWithState: LangGraphEventWithState | null = null;

    return this.eventStream$.pipe(
      scan(
        (acc, event) => {
          if (event.event === LangGraphEventTypes.OnChatModelStream) {
            if (event.data?.chunk?.kwargs?.tool_call_chunks) {
              acc.prevToolCallMessageId = acc.toolCallMessageId;
              acc.toolCallMessageId = event.data.chunk.kwargs?.id;
              if (event.data.chunk.kwargs.tool_call_chunks[0]?.name) {
                acc.toolCallName = event.data.chunk.kwargs.tool_call_chunks[0].name;
              }
              if (event.data.chunk.kwargs.tool_call_chunks[0]?.id) {
                acc.toolCallId = event.data.chunk.kwargs.tool_call_chunks[0].id;
              }
            }
            acc.prevMessageId = acc.messageId;
            acc.messageId = event.data?.chunk?.kwargs?.id;
          } else {
            acc.prevToolCallMessageId = acc.toolCallMessageId;
            acc.toolCallMessageId = null;
            acc.prevMessageId = acc.messageId;
            acc.messageId = null;
            acc.toolCallName = null;
          }

          acc.event = event;
          lastEventWithState = acc; // Capture the state
          return acc;
        },
        {
          event: null,
          toolCallId: null,
          toolCallMessageId: null,
          prevToolCallMessageId: null,
          messageId: null,
          toolCallName: null,
          prevMessageId: null,
        } as LangGraphEventWithState,
      ),
      mergeMap((eventWithState): RuntimeEvent[] => {
        const events: RuntimeEvent[] = [];

        let shouldEmitMessages = true;
        let shouldEmitToolCalls: string | string[] | boolean = false;

        if (eventWithState.event.event == LangGraphEventTypes.OnChatModelStream) {
          if ("copilotkit:emit-tool-calls" in (eventWithState.event.metadata || {})) {
            shouldEmitToolCalls = eventWithState.event.metadata["copilotkit:emit-tool-calls"];
          }
          if ("copilotkit:emit-messages" in (eventWithState.event.metadata || {})) {
            shouldEmitMessages = eventWithState.event.metadata["copilotkit:emit-messages"];
          }
        }

        // Tool call ended: emit ActionExecutionEnd
        if (
          eventWithState.prevToolCallMessageId !== null &&
          eventWithState.prevToolCallMessageId !== eventWithState.toolCallMessageId &&
          this.shouldEmitToolCall(shouldEmitToolCalls, eventWithState.toolCallName)
        ) {
          events.push({
            type: RuntimeEventTypes.ActionExecutionEnd,
          });
        }

        // Message ended: emit TextMessageEnd
        if (
          eventWithState.prevMessageId !== null &&
          eventWithState.prevMessageId !== eventWithState.messageId &&
          shouldEmitMessages
        ) {
          events.push({
            type: RuntimeEventTypes.TextMessageEnd,
          });
        }

        switch (eventWithState.event!.event) {
          case LangGraphEventTypes.OnCopilotKitEmitMessage:
            events.push({
              type: RuntimeEventTypes.TextMessageStart,
              messageId: eventWithState.event.message_id,
            });
            events.push({
              type: RuntimeEventTypes.TextMessageContent,
              content: eventWithState.event.message,
            });
            events.push({
              type: RuntimeEventTypes.TextMessageEnd,
            });
            break;
          case LangGraphEventTypes.OnCopilotKitEmitToolCall:
            events.push({
              type: RuntimeEventTypes.ActionExecutionStart,
              actionExecutionId: eventWithState.event.id,
              actionName: eventWithState.event.name,
            });
            events.push({
              type: RuntimeEventTypes.ActionExecutionArgs,
              args: JSON.stringify(eventWithState.event.args),
            });
            events.push({
              type: RuntimeEventTypes.ActionExecutionEnd,
            });
            break;
          case LangGraphEventTypes.OnCopilotKitStateSync:
            events.push({
              type: RuntimeEventTypes.AgentStateMessage,
              threadId: eventWithState.event.thread_id,
              role: eventWithState.event.role,
              agentName: eventWithState.event.agent_name,
              nodeName: eventWithState.event.node_name,
              runId: eventWithState.event.run_id,
              active: eventWithState.event.active,
              state: JSON.stringify(eventWithState.event.state),
              running: eventWithState.event.running,
            });
            break;
          case LangGraphEventTypes.OnToolEnd:
            // TODO-AGENTS: emit ActionExecutionResult when needed
            // Need a special tool node for that?

            // const result = eventWithState.event.data?.output?.kwargs?.content?.[0];
            // const toolCallId = eventWithState.event.data?.output?.kwargs?.tool_call_id;
            // const toolCallName = eventWithState.event.data?.output?.kwargs?.name;
            // if (result && toolCallId && toolCallName) {
            //   events.push({
            //     type: RuntimeEventTypes.ActionExecutionResult,
            //     actionExecutionId: toolCallId,
            //     actionName: toolCallName,
            //     result,
            //   });
            // }
            break;
          case LangGraphEventTypes.OnChatModelStream:
            if (
              eventWithState.toolCallMessageId !== null &&
              eventWithState.prevToolCallMessageId !== eventWithState.toolCallMessageId
            ) {
              if (this.shouldEmitToolCall(shouldEmitToolCalls, eventWithState.toolCallName)) {
                events.push({
                  type: RuntimeEventTypes.ActionExecutionStart,
                  actionExecutionId: eventWithState.toolCallMessageId,
                  actionName: eventWithState.toolCallName,
                  scope: "client",
                });
              }
            }
            // Message started: emit TextMessageStart
            else if (
              eventWithState.messageId !== null &&
              eventWithState.prevMessageId !== eventWithState.messageId
            ) {
              if (shouldEmitMessages) {
                events.push({
                  type: RuntimeEventTypes.TextMessageStart,
                  messageId: eventWithState.messageId,
                });
              }
            }

            const args = eventWithState.event.data?.chunk?.kwargs?.tool_call_chunks?.[0]?.args;
            const content = eventWithState.event.data?.chunk?.kwargs?.content;

            // Tool call args: emit ActionExecutionArgs
            if (args) {
              if (this.shouldEmitToolCall(shouldEmitToolCalls, eventWithState.toolCallName)) {
                events.push({
                  type: RuntimeEventTypes.ActionExecutionArgs,
                  args,
                });
              }
            }
            // Message content: emit TextMessageContent
            else if (eventWithState.messageId !== null && content) {
              if (shouldEmitMessages) {
                events.push({
                  type: RuntimeEventTypes.TextMessageContent,
                  content,
                });
              }
            }
            break;
        }
        return events;
      }),
      catchError((error) => {
        console.error(error);
        const events: RuntimeEvent[] = [];

        if (lastEventWithState?.messageId) {
          events.push({
            type: RuntimeEventTypes.TextMessageEnd,
          });
        }
        if (lastEventWithState?.toolCallMessageId) {
          events.push({
            type: RuntimeEventTypes.ActionExecutionEnd,
          });
        }

        const messageId = randomId();

        events.push({
          type: RuntimeEventTypes.TextMessageStart,
          messageId: messageId,
        });
        events.push({
          type: RuntimeEventTypes.TextMessageContent,
          content: "❌ An error occurred. Please try again.",
        });
        events.push({
          type: RuntimeEventTypes.TextMessageEnd,
        });

        return events;
      }),
    );
  }
}



---
File: /CopilotKit/packages/runtime/src/agents/langgraph/events.ts
---

export enum LangGraphEventTypes {
  OnChainStart = "on_chain_start",
  OnChainStream = "on_chain_stream",
  OnChainEnd = "on_chain_end",
  OnChatModelStart = "on_chat_model_start",
  OnChatModelStream = "on_chat_model_stream",
  OnChatModelEnd = "on_chat_model_end",
  OnToolStart = "on_tool_start",
  OnToolEnd = "on_tool_end",
  OnCopilotKitStateSync = "on_copilotkit_state_sync",
  OnCopilotKitEmitMessage = "on_copilotkit_emit_message",
  OnCopilotKitEmitToolCall = "on_copilotkit_emit_tool_call",
}

type LangGraphOnCopilotKitStateSyncEvent = {
  event: LangGraphEventTypes.OnCopilotKitStateSync;
  thread_id: string;
  agent_name: string;
  node_name: string;
  run_id: string;
  active: boolean;
  role: string;
  state: any;
  running: boolean;
};

type LangGraphOnCopilotKitManualMessageEvent = {
  event: LangGraphEventTypes.OnCopilotKitEmitMessage;
  message: string;
  message_id: string;
};

type LangGraphOnCopilotKitEmitToolCallEvent = {
  event: LangGraphEventTypes.OnCopilotKitEmitToolCall;
  name: string;
  args: any;
  id: string;
};

type LangGraphOnChainStartEvent = {
  event: LangGraphEventTypes.OnChainStart;
  run_id: string;
  name: string;
  tags: string[];
  metadata: { thread_id: string };
  data: {
    input: any;
  };
  parent_ids: string[];
};

type LangGraphOnChainEndEvent = {
  event: LangGraphEventTypes.OnChainEnd;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
  };
  data: {
    input: any;
    output: any;
  };
  parent_ids: string[];
};

type LangGraphOnChatModelStartEvent = {
  event: LangGraphEventTypes.OnChatModelStart;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
    ls_provider: string;
    ls_model_name: string;
    ls_model_type: string;
    ls_temperature: number;
  };
  data: {
    input: {
      messages: {
        lc: number;
        type: string;
        id: string[];
        kwargs: {
          content: string;
          type: string;
          id: string;
        };
      }[][];
    };
  };
  parent_ids: string[];
};

type LangGraphOnChatModelStreamEvent = {
  event: LangGraphEventTypes.OnChatModelStream;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
    ls_provider: string;
    ls_model_name: string;
    ls_model_type: string;
    ls_temperature: number;
  };
  data: {
    chunk: {
      lc: number;
      type: string;
      id: string[];
      kwargs: {
        content: string;
        additional_kwargs: {
          tool_calls: {
            index: number;
            id: string;
            function: { arguments: string; name: string };
            type: string;
          }[];
        };
        type: string;
        id: string;
        tool_calls: { name: string; args: {}; id: string; type: string }[];
        tool_call_chunks: {
          name: string;
          args: string;
          id: string;
          index: number;
          type: string;
        }[];
        invalid_tool_calls: any[];
      };
    };
  };
  parent_ids: string[];
};

type LangGraphOnChatModelEndEvent = {
  event: LangGraphEventTypes.OnChatModelEnd;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
    ls_provider: string;
    ls_model_name: string;
    ls_model_type: string;
    ls_temperature: number;
  };
  data: {
    input: any;
    output: {
      generations: {
        text: string;
        generation_info: {
          finish_reason: string;
          model_name: string;
          system_fingerprint: string;
        };
        type: string;
        message: {
          lc: number;
          type: string;
          id: string[];
          kwargs: {
            content: string;
            additional_kwargs: {
              tool_calls: {
                index: number;
                id: string;
                function: { arguments: string; name: string };
                type: string;
              }[];
            };
            response_metadata: {
              finish_reason: string;
              model_name: string;
              system_fingerprint: string;
            };
            type: string;
            id: string;
            tool_calls: { name: string; args: { query: string }; id: string; type: string }[];
            invalid_tool_calls: any[];
          };
        };
      }[][];
      llm_output: any;
      run: any;
    };
  };
  parent_ids: string[];
};

type LangGraphOnChainStreamEvent = {
  event: LangGraphEventTypes.OnChainStream;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step?: number;
    langgraph_node?: string;
    langgraph_triggers?: string[];
    langgraph_task_idx?: number;
    thread_ts?: string;
  };
  data: {
    chunk: {
      messages: {
        lc: number;
        type: string;
        id: string[];
        kwargs: {
          content: string;
          additional_kwargs?: {
            tool_calls?: {
              index: number;
              id: string;
              function: { arguments: string; name: string };
              type: string;
            }[];
          };
          response_metadata?: {
            finish_reason: string;
            model_name: string;
            system_fingerprint: string;
          };
          type: string;
          id: string;
          tool_calls?: { name: string; args: { query: string }; id: string; type: string }[];
          invalid_tool_calls?: any[];
        };
      }[];
    };
  };
  parent_ids: string[];
};

type LangGraphOnToolStartEvent = {
  event: LangGraphEventTypes.OnToolStart;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
  };
  data: {
    input: {
      query: string;
    };
  };
  parent_ids: string[];
};

type LangGraphOnToolEndEvent = {
  event: LangGraphEventTypes.OnToolEnd;
  name: string;
  run_id: string;
  tags: string[];
  metadata: {
    thread_id: string;
    langgraph_step: number;
    langgraph_node: string;
    langgraph_triggers: string[];
    langgraph_task_idx: number;
    thread_ts: string;
  };
  data: {
    input: {
      query: string;
    };
    output: {
      lc: number;
      type: string;
      id: string[];
      kwargs: {
        content: string[];
        type: string;
        name: string;
        tool_call_id: string;
        status: string;
      };
    };
  };
  parent_ids: string[];
};

export type LangGraphEvent =
  | LangGraphOnChainStartEvent
  | LangGraphOnChainStreamEvent
  | LangGraphOnChainEndEvent
  | LangGraphOnChatModelStartEvent
  | LangGraphOnChatModelStreamEvent
  | LangGraphOnChatModelEndEvent
  | LangGraphOnToolStartEvent
  | LangGraphOnToolEndEvent
  | LangGraphOnCopilotKitStateSyncEvent
  | LangGraphOnCopilotKitManualMessageEvent
  | LangGraphOnCopilotKitEmitToolCallEvent;



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/action.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class ActionInput {
  @Field(() => String)
  name: string;

  @Field(() => String)
  description: string;

  @Field(() => String)
  jsonSchema: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/agent-session.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class AgentSessionInput {
  @Field(() => String)
  agentName: string;

  @Field(() => String, { nullable: true })
  threadId?: string;

  @Field(() => String, { nullable: true })
  nodeName?: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/agent-state.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class AgentStateInput {
  @Field(() => String)
  agentName: string;

  @Field(() => String)
  state: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/cloud-guardrails.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class GuardrailsRuleInput {
  @Field(() => [String], { nullable: true })
  allowList?: string[] = [];

  @Field(() => [String], { nullable: true })
  denyList?: string[] = [];
}

@InputType()
export class GuardrailsInput {
  @Field(() => GuardrailsRuleInput, { nullable: false })
  inputValidationRules: GuardrailsRuleInput;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/cloud.input.ts
---

import { Field, InputType } from "type-graphql";
import { GuardrailsInput } from "./cloud-guardrails.input";

@InputType()
export class CloudInput {
  @Field(() => GuardrailsInput, { nullable: true })
  guardrails?: GuardrailsInput;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/context-property.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class ContextPropertyInput {
  @Field(() => String)
  value: string;

  @Field(() => String)
  description: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/custom-property.input.ts
---

import { Field, InputType, Int, createUnionType } from "type-graphql";

const PrimitiveUnion = createUnionType({
  name: "Primitive",
  types: () => [String, Number, Boolean] as const,
});

@InputType()
export class CustomPropertyInput {
  @Field(() => String)
  key: string;

  @Field(() => PrimitiveUnion)
  value: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/forwarded-parameters.input.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class ForwardedParametersInput {
  @Field(() => String, { nullable: true })
  model?: string;

  @Field(() => Number, { nullable: true })
  maxTokens?: number;

  @Field(() => [String], { nullable: true })
  stop?: string[];

  @Field(() => String, { nullable: true })
  toolChoice?: String;

  @Field(() => String, { nullable: true })
  toolChoiceFunctionName?: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/frontend.input.ts
---

import { Field, InputType } from "type-graphql";
import { ActionInput } from "./action.input";

@InputType()
export class FrontendInput {
  @Field(() => String, { nullable: true })
  toDeprecate_fullContext?: string;

  @Field(() => [ActionInput])
  actions: ActionInput[];

  @Field(() => String, { nullable: true })
  url?: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/generate-copilot-response.input.ts
---

import { Field, InputType } from "type-graphql";
import { MessageInput } from "./message.input";
import { FrontendInput } from "./frontend.input";
import { CloudInput } from "./cloud.input";
import { CopilotRequestType } from "../types/enums";
import { ForwardedParametersInput } from "./forwarded-parameters.input";
import { AgentSessionInput } from "./agent-session.input";
import { AgentStateInput } from "./agent-state.input";

@InputType()
export class GenerateCopilotResponseMetadataInput {
  @Field(() => CopilotRequestType, { nullable: true })
  requestType: CopilotRequestType;
}

@InputType()
export class GenerateCopilotResponseInput {
  @Field(() => GenerateCopilotResponseMetadataInput, { nullable: false })
  metadata: GenerateCopilotResponseMetadataInput;

  @Field(() => String, { nullable: true })
  threadId?: string;

  @Field(() => String, { nullable: true })
  runId?: string;

  @Field(() => [MessageInput])
  messages: MessageInput[];

  @Field(() => FrontendInput)
  frontend: FrontendInput;

  @Field(() => CloudInput, { nullable: true })
  cloud?: CloudInput;

  @Field(() => ForwardedParametersInput, { nullable: true })
  forwardedParameters?: ForwardedParametersInput;

  @Field(() => AgentSessionInput, { nullable: true })
  agentSession?: AgentSessionInput;

  @Field(() => AgentStateInput, { nullable: true })
  agentState?: AgentStateInput;

  @Field(() => [AgentStateInput], { nullable: true })
  agentStates?: AgentStateInput[];
}



---
File: /CopilotKit/packages/runtime/src/graphql/inputs/message.input.ts
---

import { Field, InputType } from "type-graphql";
import { MessageRole, ActionExecutionScope } from "../types/enums";
import { BaseMessage } from "../types/base";

// GraphQL does not support union types in inputs, so we need to use
// optional fields for the different subtypes.
@InputType()
export class MessageInput extends BaseMessage {
  @Field(() => TextMessageInput, { nullable: true })
  textMessage?: TextMessageInput;

  @Field(() => ActionExecutionMessageInput, { nullable: true })
  actionExecutionMessage?: ActionExecutionMessageInput;

  @Field(() => ResultMessageInput, { nullable: true })
  resultMessage?: ResultMessageInput;

  @Field(() => AgentStateMessageInput, { nullable: true })
  agentStateMessage?: AgentStateMessageInput;
}

@InputType()
export class TextMessageInput {
  @Field(() => String)
  content: string;

  @Field(() => MessageRole)
  role: MessageRole;
}

@InputType()
export class ActionExecutionMessageInput {
  @Field(() => String)
  name: string;

  @Field(() => String)
  arguments: string;

  @Field(() => ActionExecutionScope)
  scope: ActionExecutionScope;
}

@InputType()
export class ResultMessageInput {
  @Field(() => String)
  actionExecutionId: string;

  @Field(() => String)
  actionName: string;

  @Field(() => String)
  result: string;
}

@InputType()
export class AgentStateMessageInput {
  @Field(() => String)
  threadId: string;

  @Field(() => String)
  agentName: string;

  @Field(() => MessageRole)
  role: MessageRole;

  @Field(() => String)
  state: string;

  @Field(() => Boolean)
  running: boolean;

  @Field(() => String)
  nodeName: string;

  @Field(() => String)
  runId: string;

  @Field(() => Boolean)
  active: boolean;
}



---
File: /CopilotKit/packages/runtime/src/graphql/resolvers/copilot.resolver.ts
---

import { Arg, Ctx, Mutation, Query, Resolver } from "type-graphql";
import {
  ReplaySubject,
  Subject,
  Subscription,
  finalize,
  firstValueFrom,
  shareReplay,
  skipWhile,
  take,
  takeWhile,
  tap,
} from "rxjs";
import { GenerateCopilotResponseInput } from "../inputs/generate-copilot-response.input";
import { CopilotResponse } from "../types/copilot-response.type";
import { MessageRole } from "../types/enums";
import { Repeater } from "graphql-yoga";
import type { CopilotRequestContextProperties, GraphQLContext } from "../../lib/integrations";
import { RuntimeEvent, RuntimeEventTypes } from "../../service-adapters/events";
import {
  FailedMessageStatus,
  MessageStatusUnion,
  SuccessMessageStatus,
} from "../types/message-status.type";
import { ResponseStatusUnion, SuccessResponseStatus } from "../types/response-status.type";
import { GraphQLJSONObject } from "graphql-scalars";
import { plainToInstance } from "class-transformer";
import { GuardrailsResult } from "../types/guardrails-result.type";
import { GraphQLError } from "graphql";
import {
  GuardrailsValidationFailureResponse,
  MessageStreamInterruptedResponse,
  UnknownErrorResponse,
} from "../../utils";
import {
  ActionExecutionMessage,
  AgentStateMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "../types/converted";
import telemetry from "../../lib/telemetry-client";
import { randomId } from "@copilotkit/shared";

const invokeGuardrails = async ({
  baseUrl,
  copilotCloudPublicApiKey,
  data,
  onResult,
  onError,
}: {
  baseUrl: string;
  copilotCloudPublicApiKey: string;
  data: GenerateCopilotResponseInput;
  onResult: (result: GuardrailsResult) => void;
  onError: (err: Error) => void;
}) => {
  if (
    data.messages.length &&
    data.messages[data.messages.length - 1].textMessage?.role === MessageRole.user
  ) {
    const messages = data.messages
      .filter(
        (m) =>
          m.textMessage !== undefined &&
          (m.textMessage.role === MessageRole.user || m.textMessage.role === MessageRole.assistant),
      )
      .map((m) => ({
        role: m.textMessage!.role,
        content: m.textMessage.content,
      }));

    const lastMessage = messages[messages.length - 1];
    const restOfMessages = messages.slice(0, -1);

    const body = {
      input: lastMessage.content,
      validTopics: data.cloud.guardrails.inputValidationRules.allowList,
      invalidTopics: data.cloud.guardrails.inputValidationRules.denyList,
      messages: restOfMessages,
    };

    const guardrailsResult = await fetch(`${baseUrl}/guardrails/validate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CopilotCloud-Public-API-Key": copilotCloudPublicApiKey,
      },
      body: JSON.stringify(body),
    });

    if (guardrailsResult.ok) {
      const resultJson: GuardrailsResult = await guardrailsResult.json();
      onResult(resultJson);
    } else {
      onError(await guardrailsResult.json());
    }
  }
};

@Resolver(() => CopilotResponse)
export class CopilotResolver {
  @Query(() => String)
  async hello() {
    return "Hello World";
  }

  @Mutation(() => CopilotResponse)
  async generateCopilotResponse(
    @Ctx() ctx: GraphQLContext,
    @Arg("data") data: GenerateCopilotResponseInput,
    @Arg("properties", () => GraphQLJSONObject, { nullable: true })
    properties?: CopilotRequestContextProperties,
  ) {
    telemetry.capture("oss.runtime.copilot_request_created", {
      "cloud.guardrails.enabled": data.cloud?.guardrails !== undefined,
      requestType: data.metadata.requestType,
    });

    let logger = ctx.logger.child({ component: "CopilotResolver.generateCopilotResponse" });
    logger.debug({ data }, "Generating Copilot response");

    if (properties) {
      logger.debug("Properties provided, merging with context properties");
      ctx.properties = { ...ctx.properties, ...properties };
    }

    const copilotRuntime = ctx._copilotkit.runtime;
    const serviceAdapter = ctx._copilotkit.serviceAdapter;

    let copilotCloudPublicApiKey: string | null = null;
    let copilotCloudBaseUrl: string;

    if (data.cloud) {
      logger = logger.child({ cloud: true });
      logger.debug("Cloud configuration provided, checking for public API key in headers");
      const key = ctx.request.headers.get("x-copilotcloud-public-api-key");
      if (key) {
        logger.debug("Public API key found in headers");
        copilotCloudPublicApiKey = key;
      } else {
        logger.error("Public API key not found in headers");
        throw new GraphQLError("X-CopilotCloud-Public-API-Key header is required");
      }

      if (process.env.COPILOT_CLOUD_BASE_URL) {
        copilotCloudBaseUrl = process.env.COPILOT_CLOUD_BASE_URL;
      } else if (ctx._copilotkit.cloud?.baseUrl) {
        copilotCloudBaseUrl = ctx._copilotkit.cloud?.baseUrl;
      } else {
        copilotCloudBaseUrl = "https://api.cloud.copilotkit.ai";
      }

      logger = logger.child({ copilotCloudBaseUrl });
    }

    logger.debug("Setting up subjects");
    const responseStatus$ = new ReplaySubject<typeof ResponseStatusUnion>();
    const interruptStreaming$ = new ReplaySubject<{ reason: string; messageId?: string }>();
    const guardrailsResult$ = new ReplaySubject<GuardrailsResult>();

    let outputMessages: Message[] = [];
    let resolveOutputMessagesPromise: (messages: Message[]) => void;
    let rejectOutputMessagesPromise: (err: Error) => void;

    const outputMessagesPromise = new Promise<Message[]>((resolve, reject) => {
      resolveOutputMessagesPromise = resolve;
      rejectOutputMessagesPromise = reject;
    });

    logger.debug("Processing");
    const {
      eventSource,
      threadId = randomId(),
      runId,
      serverSideActions,
      actionInputsWithoutAgents,
    } = await copilotRuntime.processRuntimeRequest({
      serviceAdapter,
      messages: data.messages,
      actions: data.frontend.actions,
      threadId: data.threadId,
      runId: data.runId,
      publicApiKey: undefined,
      outputMessagesPromise,
      graphqlContext: ctx,
      forwardedParameters: data.forwardedParameters,
      agentSession: data.agentSession,
      agentStates: data.agentStates,
      url: data.frontend.url,
    });

    logger.debug("Event source created, creating response");

    const response = {
      threadId,
      runId,
      status: firstValueFrom(responseStatus$),
      messages: new Repeater(async (pushMessage, stopStreamingMessages) => {
        logger.debug("Messages repeater created");

        if (data.cloud?.guardrails) {
          logger = logger.child({ guardrails: true });
          logger.debug("Guardrails is enabled, validating input");

          invokeGuardrails({
            baseUrl: copilotCloudBaseUrl,
            copilotCloudPublicApiKey,
            data,
            onResult: (result) => {
              logger.debug({ status: result.status }, "Guardrails validation done");
              guardrailsResult$.next(result);

              // Guardrails validation failed
              if (result.status === "denied") {
                // send the reason to the client and interrupt streaming
                responseStatus$.next(
                  new GuardrailsValidationFailureResponse({ guardrailsReason: result.reason }),
                );
                interruptStreaming$.next({
                  reason: `Interrupted due to Guardrails validation failure. Reason: ${result.reason}`,
                });

                // resolve messages promise to the middleware
                outputMessages = [
                  plainToInstance(TextMessage, {
                    id: randomId(),
                    createdAt: new Date(),
                    content: result.reason,
                    role: MessageRole.assistant,
                  }),
                ];
                resolveOutputMessagesPromise(outputMessages);
              }
            },
            onError: (err) => {
              logger.error({ err }, "Error in guardrails validation");
              responseStatus$.next(
                new UnknownErrorResponse({
                  description: `An unknown error has occurred in the guardrails validation`,
                }),
              );
              interruptStreaming$.next({
                reason: `Interrupted due to unknown error in guardrails validation`,
              });

              // reject the middleware promise
              rejectOutputMessagesPromise(err);
            },
          });
        }

        let eventStreamSubscription: Subscription;

        // run and process the event stream
        const eventStream = eventSource
          .processRuntimeEvents({
            serverSideActions,
            guardrailsResult$: data.cloud?.guardrails ? guardrailsResult$ : null,
            actionInputsWithoutAgents: actionInputsWithoutAgents.filter(
              // TODO-AGENTS: do not exclude ALL server side actions
              (action) =>
                !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name),
            ),
          })
          .pipe(
            // shareReplay() ensures that later subscribers will see the whole stream instead of
            // just the events that were emitted after the subscriber was added.
            shareReplay(),
            finalize(() => {
              logger.debug("Event stream finalized");
            }),
          );

        logger.debug("Event stream created, subscribing to event stream");

        eventStreamSubscription = eventStream.subscribe({
          next: async (event) => {
            switch (event.type) {
              ////////////////////////////////
              // TextMessageStart
              ////////////////////////////////
              case RuntimeEventTypes.TextMessageStart:
                // create a sub stream that contains the message content
                const textMessageContentStream = eventStream.pipe(
                  // skip until this message start event
                  skipWhile((e) => e !== event),
                  // take until the message end event
                  takeWhile((e) => e.type != RuntimeEventTypes.TextMessageEnd),
                );

                // signal when we are done streaming
                const streamingTextStatus = new Subject<typeof MessageStatusUnion>();

                const messageId = randomId();
                // push the new message
                pushMessage({
                  id: messageId,
                  status: firstValueFrom(streamingTextStatus),
                  createdAt: new Date(),
                  role: MessageRole.assistant,
                  content: new Repeater(async (pushTextChunk, stopStreamingText) => {
                    logger.debug("Text message content repeater created");

                    const textChunks: string[] = [];
                    let textSubscription: Subscription;

                    interruptStreaming$
                      .pipe(
                        shareReplay(),
                        take(1),
                        tap(({ reason, messageId }) => {
                          logger.debug({ reason, messageId }, "Text streaming interrupted");

                          streamingTextStatus.next(
                            plainToInstance(FailedMessageStatus, { reason }),
                          );

                          responseStatus$.next(new MessageStreamInterruptedResponse({ messageId }));
                          stopStreamingText();
                          textSubscription?.unsubscribe();
                        }),
                      )
                      .subscribe();

                    logger.debug("Subscribing to text message content stream");

                    textSubscription = textMessageContentStream.subscribe({
                      next: async (e: RuntimeEvent) => {
                        if (e.type == RuntimeEventTypes.TextMessageContent) {
                          await pushTextChunk(e.content);
                          textChunks.push(e.content);
                        }
                      },
                      error: (err) => {
                        logger.error({ err }, "Error in text message content stream");
                        interruptStreaming$.next({
                          reason: "Error streaming message content",
                          messageId,
                        });
                        stopStreamingText();
                        textSubscription?.unsubscribe();
                      },
                      complete: () => {
                        logger.debug("Text message content stream completed");
                        streamingTextStatus.next(new SuccessMessageStatus());
                        stopStreamingText();
                        textSubscription?.unsubscribe();

                        outputMessages.push(
                          plainToInstance(TextMessage, {
                            id: messageId,
                            createdAt: new Date(),
                            content: textChunks.join(""),
                            role: MessageRole.assistant,
                          }),
                        );
                      },
                    });
                  }),
                });
                break;
              ////////////////////////////////
              // ActionExecutionStart
              ////////////////////////////////
              case RuntimeEventTypes.ActionExecutionStart:
                logger.debug("Action execution start event received");
                const actionExecutionArgumentStream = eventStream.pipe(
                  skipWhile((e) => e !== event),
                  takeWhile((e) => e.type != RuntimeEventTypes.ActionExecutionEnd),
                );
                const streamingArgumentsStatus = new Subject<typeof MessageStatusUnion>();
                pushMessage({
                  id: event.actionExecutionId,
                  status: firstValueFrom(streamingArgumentsStatus),
                  createdAt: new Date(),
                  name: event.actionName,
                  scope: event.scope!,
                  arguments: new Repeater(async (pushArgumentsChunk, stopStreamingArguments) => {
                    logger.debug("Action execution argument stream created");

                    const argumentChunks: string[] = [];
                    let actionExecutionArgumentSubscription: Subscription;

                    actionExecutionArgumentSubscription = actionExecutionArgumentStream.subscribe({
                      next: async (e: RuntimeEvent) => {
                        if (e.type == RuntimeEventTypes.ActionExecutionArgs) {
                          await pushArgumentsChunk(e.args);
                          argumentChunks.push(e.args);
                        }
                      },
                      error: (err) => {
                        logger.error({ err }, "Error in action execution argument stream");
                        streamingArgumentsStatus.next(
                          plainToInstance(FailedMessageStatus, {
                            reason:
                              "An unknown error has occurred in the action execution argument stream",
                          }),
                        );
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription?.unsubscribe();
                      },
                      complete: () => {
                        logger.debug("Action execution argument stream completed");
                        streamingArgumentsStatus.next(new SuccessMessageStatus());
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription?.unsubscribe();

                        outputMessages.push(
                          plainToInstance(ActionExecutionMessage, {
                            id: event.actionExecutionId,
                            createdAt: new Date(),
                            name: event.actionName,
                            scope: event.scope!,
                            arguments: argumentChunks.join(""),
                          }),
                        );
                      },
                    });
                  }),
                });
                break;
              ////////////////////////////////
              // ActionExecutionResult
              ////////////////////////////////
              case RuntimeEventTypes.ActionExecutionResult:
                logger.debug({ result: event.result }, "Action execution result event received");
                pushMessage({
                  id: randomId(),
                  status: new SuccessMessageStatus(),
                  createdAt: new Date(),
                  actionExecutionId: event.actionExecutionId,
                  actionName: event.actionName,
                  result: event.result,
                });

                outputMessages.push(
                  plainToInstance(ResultMessage, {
                    id: randomId(),
                    createdAt: new Date(),
                    actionExecutionId: event.actionExecutionId,
                    actionName: event.actionName,
                    result: event.result,
                  }),
                );
                break;
              ////////////////////////////////
              // AgentStateMessage
              ////////////////////////////////
              case RuntimeEventTypes.AgentStateMessage:
                logger.debug({ event }, "Agent message event received");
                pushMessage({
                  id: randomId(),
                  status: new SuccessMessageStatus(),
                  threadId: event.threadId,
                  agentName: event.agentName,
                  nodeName: event.nodeName,
                  runId: event.runId,
                  active: event.active,
                  state: event.state,
                  running: event.running,
                  role: MessageRole.assistant,
                  createdAt: new Date(),
                });
                outputMessages.push(
                  plainToInstance(AgentStateMessage, {
                    id: randomId(),
                    threadId: event.threadId,
                    agentName: event.agentName,
                    nodeName: event.nodeName,
                    runId: event.runId,
                    active: event.active,
                    state: event.state,
                    running: event.running,
                    role: MessageRole.assistant,
                    createdAt: new Date(),
                  }),
                );
                break;
            }
          },
          error: (err) => {
            logger.error({ err }, "Error in event stream");
            responseStatus$.next(
              new UnknownErrorResponse({
                description: `An unknown error has occurred in the event stream`,
              }),
            );
            eventStreamSubscription?.unsubscribe();
            stopStreamingMessages();

            rejectOutputMessagesPromise(err);
          },
          complete: async () => {
            logger.debug("Event stream completed");
            if (data.cloud?.guardrails) {
              logger.debug("Guardrails is enabled, waiting for guardrails result");
              await firstValueFrom(guardrailsResult$);
            }
            responseStatus$.next(new SuccessResponseStatus());
            eventStreamSubscription?.unsubscribe();
            stopStreamingMessages();

            resolveOutputMessagesPromise(outputMessages);
          },
        });
      }),
    };

    return response;
  }
}



---
File: /CopilotKit/packages/runtime/src/graphql/types/base/index.ts
---

import { Field, InputType } from "type-graphql";

@InputType()
export class BaseMessage {
  @Field(() => String)
  id: string;

  @Field(() => Date)
  createdAt: Date;
}



---
File: /CopilotKit/packages/runtime/src/graphql/types/converted/index.ts
---

import {
  ActionExecutionMessageInput,
  ResultMessageInput,
  TextMessageInput,
  AgentStateMessageInput,
} from "../../inputs/message.input";
import { BaseMessage } from "../base";
import { ActionExecutionScope, MessageRole } from "../enums";

export class TextMessage extends BaseMessage implements TextMessageInput {
  content: string;
  role: MessageRole;
}

export type Message = BaseMessage;

export class ActionExecutionMessage
  extends BaseMessage
  implements Omit<ActionExecutionMessageInput, "arguments">
{
  name: string;
  arguments: Record<string, any>;
  scope: ActionExecutionScope;
}

export class ResultMessage extends BaseMessage implements ResultMessageInput {
  actionExecutionId: string;
  actionName: string;
  result: string;
}

export class AgentStateMessage
  extends BaseMessage
  implements Omit<AgentStateMessageInput, "state">
{
  threadId: string;
  agentName: string;
  nodeName: string;
  runId: string;
  active: boolean;
  role: MessageRole;
  state: any;
  running: boolean;
}



---
File: /CopilotKit/packages/runtime/src/graphql/types/copilot-response.type.ts
---

import { Field, InterfaceType, ObjectType } from "type-graphql";
import { MessageRole, ActionExecutionScope } from "./enums";
import { MessageStatusUnion } from "./message-status.type";
import { ResponseStatusUnion } from "./response-status.type";

@InterfaceType({
  resolveType(value) {
    if (value.hasOwnProperty("content")) {
      return TextMessageOutput;
    } else if (value.hasOwnProperty("name")) {
      return ActionExecutionMessageOutput;
    } else if (value.hasOwnProperty("result")) {
      return ResultMessageOutput;
    } else if (value.hasOwnProperty("state")) {
      return AgentStateMessageOutput;
    }
    return undefined;
  },
})
abstract class BaseMessageOutput {
  @Field(() => String)
  id: string;

  @Field(() => Date)
  createdAt: Date;

  @Field(() => MessageStatusUnion)
  status: typeof MessageStatusUnion;
}

@ObjectType({ implements: BaseMessageOutput })
export class TextMessageOutput {
  @Field(() => MessageRole)
  role: MessageRole;

  @Field(() => [String])
  content: string[];
}

@ObjectType({ implements: BaseMessageOutput })
export class ActionExecutionMessageOutput {
  @Field(() => String)
  name: string;

  @Field(() => ActionExecutionScope)
  scope: ActionExecutionScope;

  @Field(() => [String])
  arguments: string[];
}

@ObjectType({ implements: BaseMessageOutput })
export class ResultMessageOutput {
  @Field(() => String)
  actionExecutionId: string;

  @Field(() => String)
  actionName: string;

  @Field(() => String)
  result: string;
}

@ObjectType({ implements: BaseMessageOutput })
export class AgentStateMessageOutput {
  @Field(() => String)
  threadId: string;

  @Field(() => String)
  agentName: string;

  @Field(() => String)
  nodeName: string;

  @Field(() => String)
  runId: string;

  @Field(() => Boolean)
  active: boolean;

  @Field(() => MessageRole)
  role: MessageRole;

  @Field(() => String)
  state: string;

  @Field(() => Boolean)
  running: boolean;
}

@ObjectType()
export class CopilotResponse {
  @Field(() => String)
  threadId!: string;

  @Field(() => ResponseStatusUnion)
  status: typeof ResponseStatusUnion;

  @Field({ nullable: true })
  runId?: string;

  @Field(() => [BaseMessageOutput])
  messages: (typeof BaseMessageOutput)[];
}



---
File: /CopilotKit/packages/runtime/src/graphql/types/enums.ts
---

import { registerEnumType } from "type-graphql";

export enum MessageRole {
  user = "user",
  assistant = "assistant",
  system = "system",
}

export enum ActionExecutionScope {
  server = "server",
  client = "client",
  passThrough = "passThrough",
}

export enum CopilotRequestType {
  Chat = "Chat",
  Task = "Task",
  TextareaCompletion = "TextareaCompletion",
  TextareaPopover = "TextareaPopover",
  Suggestion = "Suggestion",
}

registerEnumType(MessageRole, {
  name: "MessageRole",
  description: "The role of the message",
});

registerEnumType(ActionExecutionScope, {
  name: "ActionExecutionScope",
  description: "The scope of the action",
});

registerEnumType(CopilotRequestType, {
  name: "CopilotRequestType",
  description: "The type of Copilot request",
});



---
File: /CopilotKit/packages/runtime/src/graphql/types/guardrails-result.type.ts
---

import { Field, ObjectType, registerEnumType } from "type-graphql";

export enum GuardrailsResultStatus {
  ALLOWED = "allowed",
  DENIED = "denied",
}

registerEnumType(GuardrailsResultStatus, {
  name: "GuardrailsResultStatus",
  description: "The status of the guardrails check",
});

@ObjectType()
export class GuardrailsResult {
  @Field(() => GuardrailsResultStatus)
  status: GuardrailsResultStatus;

  @Field(() => String, { nullable: true })
  reason?: string;
}



---
File: /CopilotKit/packages/runtime/src/graphql/types/message-status.type.ts
---

import { Field, ObjectType, createUnionType, registerEnumType } from "type-graphql";

export enum MessageStatusCode {
  Pending = "pending",
  Success = "success",
  Failed = "failed",
}

registerEnumType(MessageStatusCode, {
  name: "MessageStatusCode",
});

@ObjectType()
class BaseMessageStatus {
  @Field(() => MessageStatusCode)
  code: MessageStatusCode;
}

@ObjectType()
export class PendingMessageStatus extends BaseMessageStatus {
  code: MessageStatusCode = MessageStatusCode.Pending;
}

@ObjectType()
export class SuccessMessageStatus extends BaseMessageStatus {
  code: MessageStatusCode = MessageStatusCode.Success;
}

@ObjectType()
export class FailedMessageStatus extends BaseMessageStatus {
  code: MessageStatusCode = MessageStatusCode.Failed;

  @Field(() => String)
  reason: string;
}

export const MessageStatusUnion = createUnionType({
  name: "MessageStatus",
  types: () => [PendingMessageStatus, SuccessMessageStatus, FailedMessageStatus] as const,
});



---
File: /CopilotKit/packages/runtime/src/graphql/types/response-status.type.ts
---

import { GraphQLJSON } from "graphql-scalars";
import { Field, InterfaceType, ObjectType, createUnionType, registerEnumType } from "type-graphql";

export enum ResponseStatusCode {
  Pending = "pending",
  Success = "success",
  Failed = "failed",
}

registerEnumType(ResponseStatusCode, {
  name: "ResponseStatusCode",
});

@InterfaceType({
  resolveType(value) {
    if (value.code === ResponseStatusCode.Success) {
      return SuccessResponseStatus;
    } else if (value.code === ResponseStatusCode.Failed) {
      return FailedResponseStatus;
    } else if (value.code === ResponseStatusCode.Pending) {
      return PendingResponseStatus;
    }
    return undefined;
  },
})
@ObjectType()
abstract class BaseResponseStatus {
  @Field(() => ResponseStatusCode)
  code: ResponseStatusCode;
}

@ObjectType({ implements: BaseResponseStatus })
export class PendingResponseStatus extends BaseResponseStatus {
  code: ResponseStatusCode = ResponseStatusCode.Pending;
}

@ObjectType({ implements: BaseResponseStatus })
export class SuccessResponseStatus extends BaseResponseStatus {
  code: ResponseStatusCode = ResponseStatusCode.Success;
}

export enum FailedResponseStatusReason {
  GUARDRAILS_VALIDATION_FAILED = "GUARDRAILS_VALIDATION_FAILED",
  MESSAGE_STREAM_INTERRUPTED = "MESSAGE_STREAM_INTERRUPTED",
  UNKNOWN_ERROR = "UNKNOWN_ERROR",
}

registerEnumType(FailedResponseStatusReason, {
  name: "FailedResponseStatusReason",
});

@ObjectType({ implements: BaseResponseStatus })
export class FailedResponseStatus extends BaseResponseStatus {
  code: ResponseStatusCode = ResponseStatusCode.Failed;

  @Field(() => FailedResponseStatusReason)
  reason: FailedResponseStatusReason;

  @Field(() => GraphQLJSON, { nullable: true })
  details?: Record<string, any> = null;
}

export const ResponseStatusUnion = createUnionType({
  name: "ResponseStatus",
  types: () => [PendingResponseStatus, SuccessResponseStatus, FailedResponseStatus] as const,
});



---
File: /CopilotKit/packages/runtime/src/lib/cloud/index.ts
---

export interface CopilotCloudOptions {
  baseUrl?: string;
  publicApiKey?: string;
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/nest/index.ts
---

import { CreateCopilotRuntimeServerOptions } from "../shared";
import { copilotRuntimeNodeHttpEndpoint } from "../node-http";
import telemetry from "../../telemetry-client";

export function copilotRuntimeNestEndpoint(options: CreateCopilotRuntimeServerOptions) {
  telemetry.setGlobalProperties({
    runtime: {
      framework: "nest",
    },
  });

  telemetry.capture("oss.runtime.instance_created", {});
  return copilotRuntimeNodeHttpEndpoint(options);
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/nextjs/app-router.ts
---

import { createYoga } from "graphql-yoga";
import { CreateCopilotRuntimeServerOptions, getCommonConfig } from "../shared";
import telemetry from "../../telemetry-client";

export function copilotRuntimeNextJSAppRouterEndpoint(options: CreateCopilotRuntimeServerOptions) {
  const commonConfig = getCommonConfig(options);

  telemetry.setGlobalProperties({
    runtime: {
      framework: "nextjs-app-router",
    },
  });

  if (options.properties?._copilotkit) {
    telemetry.setGlobalProperties({
      _copilotkit: options.properties._copilotkit,
    });
  }

  telemetry.capture("oss.runtime.instance_created", {});

  const logger = commonConfig.logging;
  logger.debug("Creating NextJS App Router endpoint");

  const yoga = createYoga({
    ...commonConfig,
    graphqlEndpoint: options.endpoint,
    fetchAPI: { Response: globalThis.Response },
  });

  return {
    handleRequest: yoga,
    GET: yoga as any,
    POST: yoga as any,
    OPTIONS: yoga as any,
  };
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/nextjs/pages-router.ts
---

import { YogaServerInstance, createYoga } from "graphql-yoga";
import { CreateCopilotRuntimeServerOptions, GraphQLContext, getCommonConfig } from "../shared";
import telemetry from "../../telemetry-client";

export const config = {
  api: {
    bodyParser: false,
  },
};

export type CopilotRuntimeServerInstance<T> = YogaServerInstance<T, Partial<GraphQLContext>>;

// This import is needed to fix the type error
// Fix is currently in TypeScript 5.5 beta, waiting for stable version
// https://github.com/microsoft/TypeScript/issues/42873#issuecomment-2066874644
export type {} from "@whatwg-node/server";

export function copilotRuntimeNextJSPagesRouterEndpoint(
  options: CreateCopilotRuntimeServerOptions,
): CopilotRuntimeServerInstance<GraphQLContext> {
  const commonConfig = getCommonConfig(options);

  telemetry.setGlobalProperties({
    runtime: {
      framework: "nextjs-pages-router",
    },
  });

  if (options.properties?._copilotkit) {
    telemetry.setGlobalProperties({
      _copilotkit: options.properties._copilotkit,
    });
  }

  telemetry.capture("oss.runtime.instance_created", {});

  const logger = commonConfig.logging;
  logger.debug("Creating NextJS Pages Router endpoint");

  const yoga = createYoga({
    ...commonConfig,
    graphqlEndpoint: options.endpoint,
  });

  return yoga;
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/node-express/index.ts
---

import { CreateCopilotRuntimeServerOptions } from "../shared";
import { copilotRuntimeNodeHttpEndpoint } from "../node-http";
import telemetry from "../../telemetry-client";

export function copilotRuntimeNodeExpressEndpoint(options: CreateCopilotRuntimeServerOptions) {
  telemetry.setGlobalProperties({
    runtime: {
      framework: "node-express",
    },
  });

  telemetry.capture("oss.runtime.instance_created", {});
  return copilotRuntimeNodeHttpEndpoint(options);
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/node-http/index.ts
---

import { createYoga } from "graphql-yoga";
import { CreateCopilotRuntimeServerOptions, getCommonConfig } from "../shared";
import telemetry from "../../telemetry-client";

export function copilotRuntimeNodeHttpEndpoint(options: CreateCopilotRuntimeServerOptions) {
  const commonConfig = getCommonConfig(options);

  telemetry.setGlobalProperties({
    runtime: {
      framework: "node-http",
    },
  });

  if (options.properties?._copilotkit) {
    telemetry.setGlobalProperties({
      _copilotkit: options.properties._copilotkit,
    });
  }

  telemetry.capture("oss.runtime.instance_created", {});

  const logger = commonConfig.logging;
  logger.debug("Creating Node HTTP endpoint");

  const yoga = createYoga({
    ...commonConfig,
    graphqlEndpoint: options.endpoint,
  });

  return yoga;
}



---
File: /CopilotKit/packages/runtime/src/lib/integrations/index.ts
---

export * from "./shared";
export * from "./nextjs/app-router";
export * from "./nextjs/pages-router";
export * from "./node-http";
export * from "./node-express";
export * from "./nest";



---
File: /CopilotKit/packages/runtime/src/lib/integrations/shared.ts
---

import { YogaInitialContext } from "graphql-yoga";
import { buildSchemaSync } from "type-graphql";
import { CopilotResolver } from "../../graphql/resolvers/copilot.resolver";
import { useDeferStream } from "@graphql-yoga/plugin-defer-stream";
import { CopilotRuntime } from "../runtime/copilot-runtime";
import { CopilotServiceAdapter } from "../../service-adapters";
import { CopilotCloudOptions } from "../cloud";
import { LogLevel, createLogger } from "../../lib/logger";
import { createYoga } from "graphql-yoga";
import telemetry from "../telemetry-client";

const logger = createLogger();

type AnyPrimitive = string | boolean | number | null;
export type CopilotRequestContextProperties = Record<
  string,
  AnyPrimitive | Record<string, AnyPrimitive>
>;

export type GraphQLContext = YogaInitialContext & {
  _copilotkit: CreateCopilotRuntimeServerOptions;
  properties: CopilotRequestContextProperties;
  logger: typeof logger;
};

export interface CreateCopilotRuntimeServerOptions {
  runtime: CopilotRuntime<any>;
  serviceAdapter: CopilotServiceAdapter;
  endpoint: string;
  baseUrl?: string;
  cloud?: CopilotCloudOptions;
  properties?: CopilotRequestContextProperties;
  logLevel?: LogLevel;
}

export async function createContext(
  initialContext: YogaInitialContext,
  copilotKitContext: CreateCopilotRuntimeServerOptions,
  contextLogger: typeof logger,
  properties: CopilotRequestContextProperties = {},
): Promise<Partial<GraphQLContext>> {
  logger.debug({ copilotKitContext }, "Creating GraphQL context");
  const ctx: GraphQLContext = {
    ...initialContext,
    _copilotkit: {
      ...copilotKitContext,
    },
    properties: { ...properties },
    logger: contextLogger,
  };
  return ctx;
}

export function buildSchema(
  options: {
    emitSchemaFile?: string;
  } = {},
) {
  logger.debug("Building GraphQL schema...");
  const schema = buildSchemaSync({
    resolvers: [CopilotResolver],
    emitSchemaFile: options.emitSchemaFile,
  });
  logger.debug("GraphQL schema built successfully");
  return schema;
}

export type CommonConfig = {
  logging: typeof logger;
  schema: ReturnType<typeof buildSchema>;
  plugins: Parameters<typeof createYoga>[0]["plugins"];
  context: (ctx: YogaInitialContext) => Promise<Partial<GraphQLContext>>;
};

export function getCommonConfig(options: CreateCopilotRuntimeServerOptions): CommonConfig {
  const logLevel = (process.env.LOG_LEVEL as LogLevel) || (options.logLevel as LogLevel) || "error";
  const logger = createLogger({ level: logLevel, component: "getCommonConfig" });

  const contextLogger = createLogger({ level: logLevel });

  if (options.cloud) {
    telemetry.setCloudConfiguration({
      publicApiKey: options.cloud.publicApiKey,
      baseUrl: options.cloud.baseUrl,
    });
  }

  if (options.properties?._copilotkit) {
    telemetry.setGlobalProperties({
      _copilotkit: {
        ...(options.properties._copilotkit as Record<string, any>),
      },
    });
  }

  telemetry.setGlobalProperties({
    runtime: {
      serviceAdapter: options.serviceAdapter.constructor.name,
    },
  });

  return {
    logging: createLogger({ component: "Yoga GraphQL", level: logLevel }),
    schema: buildSchema(),
    plugins: [useDeferStream()],
    context: (ctx: YogaInitialContext): Promise<Partial<GraphQLContext>> =>
      createContext(ctx, options, contextLogger, options.properties),
  };
}



---
File: /CopilotKit/packages/runtime/src/lib/runtime/copilot-runtime.ts
---

/**
 * <Callout type="info">
 *   This is the reference for the `CopilotRuntime` class. For more information and example code snippets, please see [Concept: Copilot Runtime](/concepts/copilot-runtime).
 * </Callout>
 *
 * ## Usage
 *
 * ```tsx
 * import { CopilotRuntime } from "@copilotkit/runtime";
 *
 * const copilotKit = new CopilotRuntime();
 * ```
 */

import { Action, actionParametersToJsonSchema, Parameter, randomId } from "@copilotkit/shared";
import { RemoteChain, RemoteChainParameters, CopilotServiceAdapter } from "../../service-adapters";
import { MessageInput } from "../../graphql/inputs/message.input";
import { ActionInput } from "../../graphql/inputs/action.input";
import { RuntimeEventSource } from "../../service-adapters/events";
import { convertGqlInputToMessages } from "../../service-adapters/conversion";
import { AgentStateMessage, Message } from "../../graphql/types/converted";
import { ForwardedParametersInput } from "../../graphql/inputs/forwarded-parameters.input";
import {
  setupRemoteActions,
  RemoteActionDefinition,
  LangGraphAgentAction,
  isLangGraphAgentAction,
} from "./remote-actions";
import { GraphQLContext } from "../integrations/shared";
import { AgentSessionInput } from "../../graphql/inputs/agent-session.input";
import { from } from "rxjs";
import { AgentStateInput } from "../../graphql/inputs/agent-state.input";

interface CopilotRuntimeRequest {
  serviceAdapter: CopilotServiceAdapter;
  messages: MessageInput[];
  actions: ActionInput[];
  agentSession?: AgentSessionInput;
  agentStates?: AgentStateInput[];
  outputMessagesPromise: Promise<Message[]>;
  threadId?: string;
  runId?: string;
  publicApiKey?: string;
  graphqlContext: GraphQLContext;
  forwardedParameters?: ForwardedParametersInput;
  url?: string;
}

interface CopilotRuntimeResponse {
  threadId: string;
  runId?: string;
  eventSource: RuntimeEventSource;
  serverSideActions: Action<any>[];
  actionInputsWithoutAgents: ActionInput[];
}

type ActionsConfiguration<T extends Parameter[] | [] = []> =
  | Action<T>[]
  | ((ctx: { properties: any; url?: string }) => Action<T>[]);

interface OnBeforeRequestOptions {
  threadId?: string;
  runId?: string;
  inputMessages: Message[];
  properties: any;
  url?: string;
}

type OnBeforeRequestHandler = (options: OnBeforeRequestOptions) => void | Promise<void>;

interface OnAfterRequestOptions {
  threadId: string;
  runId?: string;
  inputMessages: Message[];
  outputMessages: Message[];
  properties: any;
  url?: string;
}

type OnAfterRequestHandler = (options: OnAfterRequestOptions) => void | Promise<void>;

interface Middleware {
  /**
   * A function that is called before the request is processed.
   */
  onBeforeRequest?: OnBeforeRequestHandler;

  /**
   * A function that is called after the request is processed.
   */
  onAfterRequest?: OnAfterRequestHandler;
}

export interface CopilotRuntimeConstructorParams<T extends Parameter[] | [] = []> {
  /**
   * Middleware to be used by the runtime.
   *
   * ```ts
   * onBeforeRequest: (options: {
   *   threadId?: string;
   *   runId?: string;
   *   inputMessages: Message[];
   *   properties: any;
   * }) => void | Promise<void>;
   * ```
   *
   * ```ts
   * onAfterRequest: (options: {
   *   threadId?: string;
   *   runId?: string;
   *   inputMessages: Message[];
   *   outputMessages: Message[];
   *   properties: any;
   * }) => void | Promise<void>;
   * ```
   */
  middleware?: Middleware;

  /*
   * A list of server side actions that can be executed.
   */
  actions?: ActionsConfiguration<T>;

  /*
   * A list of remote actions that can be executed.
   */
  remoteActions?: RemoteActionDefinition[];

  /*
   * An array of LangServer URLs.
   */
  langserve?: RemoteChainParameters[];
}

export class CopilotRuntime<const T extends Parameter[] | [] = []> {
  public actions: ActionsConfiguration<T>;
  private remoteActionDefinitions: RemoteActionDefinition[];
  private langserve: Promise<Action<any>>[] = [];
  private onBeforeRequest?: OnBeforeRequestHandler;
  private onAfterRequest?: OnAfterRequestHandler;

  constructor(params?: CopilotRuntimeConstructorParams<T>) {
    this.actions = params?.actions || [];

    for (const chain of params?.langserve || []) {
      const remoteChain = new RemoteChain(chain);
      this.langserve.push(remoteChain.toAction());
    }

    this.remoteActionDefinitions = params?.remoteActions || [];

    this.onBeforeRequest = params?.middleware?.onBeforeRequest;
    this.onAfterRequest = params?.middleware?.onAfterRequest;
  }

  async processRuntimeRequest(request: CopilotRuntimeRequest): Promise<CopilotRuntimeResponse> {
    const {
      serviceAdapter,
      messages: rawMessages,
      actions: clientSideActionsInput,
      threadId,
      runId,
      outputMessagesPromise,
      graphqlContext,
      forwardedParameters,
      agentSession,
      url,
    } = request;

    if (agentSession) {
      return this.processAgentRequest(request);
    }

    const messages = rawMessages.filter((message) => !message.agentStateMessage);

    const inputMessages = convertGqlInputToMessages(messages);
    const serverSideActions = await this.getServerSideActions(request);

    const serverSideActionsInput: ActionInput[] = serverSideActions.map((action) => ({
      name: action.name,
      description: action.description,
      jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters)),
    }));

    const actionInputs = flattenToolCallsNoDuplicates([
      ...serverSideActionsInput,
      ...clientSideActionsInput,
    ]);

    await this.onBeforeRequest?.({
      threadId,
      runId,
      inputMessages,
      properties: graphqlContext.properties,
      url,
    });

    try {
      const eventSource = new RuntimeEventSource();

      const result = await serviceAdapter.process({
        messages: inputMessages,
        actions: actionInputs,
        threadId,
        runId,
        eventSource,
        forwardedParameters,
      });

      outputMessagesPromise
        .then((outputMessages) => {
          this.onAfterRequest?.({
            threadId: result.threadId,
            runId: result.runId,
            inputMessages,
            outputMessages,
            properties: graphqlContext.properties,
            url,
          });
        })
        .catch((_error) => {});

      return {
        threadId: result.threadId,
        runId: result.runId,
        eventSource,
        serverSideActions,
        actionInputsWithoutAgents: actionInputs.filter(
          (action) =>
            // TODO-AGENTS: do not exclude ALL server side actions
            !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name),
          // !isLangGraphAgentAction(
          //   serverSideActions.find((serverSideAction) => serverSideAction.name == action.name),
          // ),
        ),
      };
    } catch (error) {
      console.error("Error getting response:", error);
      throw error;
    }
  }

  private async processAgentRequest(
    request: CopilotRuntimeRequest,
  ): Promise<CopilotRuntimeResponse> {
    const { messages: rawMessages, outputMessagesPromise, graphqlContext, agentSession } = request;
    const { threadId = randomId(), agentName, nodeName } = agentSession;
    const serverSideActions = await this.getServerSideActions(request);

    const messages = convertGqlInputToMessages(rawMessages);

    const agent = serverSideActions.find(
      (action) => action.name === agentName && isLangGraphAgentAction(action),
    ) as LangGraphAgentAction;

    if (!agent) {
      throw new Error(`Agent ${agentName} not found`);
    }

    const serverSideActionsInput: ActionInput[] = serverSideActions
      .filter((action) => !isLangGraphAgentAction(action))
      .map((action) => ({
        name: action.name,
        description: action.description,
        jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters)),
      }));

    const actionInputsWithoutAgents = flattenToolCallsNoDuplicates([
      ...serverSideActionsInput,
      ...request.actions,
    ]);

    await this.onBeforeRequest?.({
      threadId,
      runId: undefined,
      inputMessages: messages,
      properties: graphqlContext.properties,
    });
    try {
      const eventSource = new RuntimeEventSource();
      const stream = await agent.langGraphAgentHandler({
        name: agentName,
        threadId,
        nodeName,
        actionInputsWithoutAgents,
      });

      eventSource.stream(async (eventStream$) => {
        from(stream).subscribe({
          next: (event) => eventStream$.next(event),
          error: (err) => console.error("Error in stream", err),
          complete: () => eventStream$.complete(),
        });
      });

      outputMessagesPromise
        .then((outputMessages) => {
          this.onAfterRequest?.({
            threadId,
            runId: undefined,
            inputMessages: messages,
            outputMessages,
            properties: graphqlContext.properties,
          });
        })
        .catch((_error) => {});

      return {
        threadId,
        runId: undefined,
        eventSource,
        serverSideActions: [],
        actionInputsWithoutAgents,
      };
    } catch (error) {
      console.error("Error getting response:", error);
      throw error;
    }
  }

  private async getServerSideActions(request: CopilotRuntimeRequest): Promise<Action<any>[]> {
    const { messages: rawMessages, graphqlContext, agentStates, url } = request;
    const inputMessages = convertGqlInputToMessages(rawMessages);
    const langserveFunctions: Action<any>[] = [];

    for (const chainPromise of this.langserve) {
      try {
        const chain = await chainPromise;
        langserveFunctions.push(chain);
      } catch (error) {
        console.error("Error loading langserve chain:", error);
      }
    }
    const remoteActions = await setupRemoteActions({
      remoteActionDefinitions: this.remoteActionDefinitions,
      graphqlContext,
      messages: inputMessages,
      agentStates,
      frontendUrl: url,
    });

    const configuredActions =
      typeof this.actions === "function"
        ? this.actions({ properties: graphqlContext.properties, url })
        : this.actions;

    return [...configuredActions, ...langserveFunctions, ...remoteActions];
  }
}

export function flattenToolCallsNoDuplicates(toolsByPriority: ActionInput[]): ActionInput[] {
  let allTools: ActionInput[] = [];
  const allToolNames: string[] = [];
  for (const tool of toolsByPriority) {
    if (!allToolNames.includes(tool.name)) {
      allTools.push(tool);
      allToolNames.push(tool.name);
    }
  }
  return allTools;
}



---
File: /CopilotKit/packages/runtime/src/lib/runtime/remote-actions.ts
---

import { Action } from "@copilotkit/shared";
import { GraphQLContext } from "../integrations/shared";
import { Logger } from "pino";
import telemetry from "../../lib/telemetry-client";
import { Message } from "../../graphql/types/converted";
import { RuntimeEvent, RuntimeEventSubject } from "../../service-adapters/events";
import { RemoteLangGraphEventSource } from "../../agents/langgraph/event-source";
import { Observable } from "rxjs";
import { ActionInput } from "../../graphql/inputs/action.input";
import { AgentStateInput } from "../../graphql/inputs/agent-state.input";

export type RemoteActionDefinition = {
  url: string;
  onBeforeRequest?: ({ ctx }: { ctx: GraphQLContext }) => {
    headers?: Record<string, string> | undefined;
  };
};

export type RemoteActionInfoResponse = {
  actions: any[];
  agents: any[];
};

export type LangGraphAgentHandlerParams = {
  name: string;
  actionInputsWithoutAgents: ActionInput[];
  threadId?: string;
  nodeName?: string;
};

export type LangGraphAgentAction = Action<any> & {
  langGraphAgentHandler: (params: LangGraphAgentHandlerParams) => Promise<Observable<RuntimeEvent>>;
};

export function isLangGraphAgentAction(action: Action<any>): action is LangGraphAgentAction {
  if (!action) {
    return false;
  }
  return typeof (action as LangGraphAgentAction).langGraphAgentHandler === "function";
}

function createHeaders(
  onBeforeRequest: RemoteActionDefinition["onBeforeRequest"],
  graphqlContext: GraphQLContext,
) {
  const headers = {
    "Content-Type": "application/json",
  };

  if (onBeforeRequest) {
    const { headers: additionalHeaders } = onBeforeRequest({ ctx: graphqlContext });
    if (additionalHeaders) {
      Object.assign(headers, additionalHeaders);
    }
  }

  return headers;
}

async function fetchRemoteInfo({
  url,
  onBeforeRequest,
  graphqlContext,
  logger,
  frontendUrl,
}: {
  url: string;
  onBeforeRequest?: RemoteActionDefinition["onBeforeRequest"];
  graphqlContext: GraphQLContext;
  logger: Logger;
  frontendUrl?: string;
}): Promise<RemoteActionInfoResponse> {
  logger.debug({ url }, "Fetching actions from url");
  const headers = createHeaders(onBeforeRequest, graphqlContext);

  try {
    const response = await fetch(`${url}/info`, {
      method: "POST",
      headers,
      body: JSON.stringify({ properties: graphqlContext.properties, frontendUrl }),
    });

    if (!response.ok) {
      logger.error(
        { url, status: response.status, body: await response.text() },
        "Failed to fetch actions from url",
      );
      return { actions: [], agents: [] };
    }

    const json = await response.json();
    logger.debug({ json }, "Fetched actions from url");
    return json;
  } catch (error) {
    logger.error(
      { error: error.message ? error.message : error + "" },
      "Failed to fetch actions from url",
    );
    return { actions: [], agents: [] };
  }
}

function constructRemoteActions({
  json,
  url,
  onBeforeRequest,
  graphqlContext,
  logger,
  messages,
  agentStates,
}: {
  json: RemoteActionInfoResponse;
  url: string;
  onBeforeRequest?: RemoteActionDefinition["onBeforeRequest"];
  graphqlContext: GraphQLContext;
  logger: Logger;
  messages: Message[];
  agentStates?: AgentStateInput[];
}): Action<any>[] {
  const actions = json["actions"].map((action) => ({
    name: action.name,
    description: action.description,
    parameters: action.parameters,
    handler: async (args: any) => {
      logger.debug({ actionName: action.name, args }, "Executing remote action");

      const headers = createHeaders(onBeforeRequest, graphqlContext);
      telemetry.capture("oss.runtime.remote_action_executed", {});

      try {
        const response = await fetch(`${url}/actions/execute`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            name: action.name,
            arguments: args,
            properties: graphqlContext.properties,
          }),
        });

        if (!response.ok) {
          logger.error(
            { url, status: response.status, body: await response.text() },
            "Failed to execute remote action",
          );
          return "Failed to execute remote action";
        }

        const requestResult = await response.json();

        const result = requestResult["result"];
        logger.debug({ actionName: action.name, result }, "Executed remote action");
        return result;
      } catch (error) {
        logger.error(
          { error: error.message ? error.message : error + "" },
          "Failed to execute remote action",
        );
        return "Failed to execute remote action";
      }
    },
  }));

  const agents = json["agents"].map((agent) => ({
    name: agent.name,
    description: agent.description,
    parameters: [],
    handler: async (_args: any) => {},

    langGraphAgentHandler: async ({
      name,
      actionInputsWithoutAgents,
      threadId,
      nodeName,
    }: LangGraphAgentHandlerParams): Promise<Observable<RuntimeEvent>> => {
      logger.debug({ actionName: agent.name }, "Executing remote agent");

      const headers = createHeaders(onBeforeRequest, graphqlContext);
      telemetry.capture("oss.runtime.remote_action_executed", {});

      let state = {};
      if (agentStates) {
        const jsonState = agentStates.find((state) => state.agentName === name)?.state;
        if (jsonState) {
          state = JSON.parse(jsonState);
        }
      }

      const response = await fetch(`${url}/agents/execute`, {
        method: "POST",
        headers,
        body: JSON.stringify({
          name,
          threadId,
          nodeName,
          messages,
          state,
          properties: graphqlContext.properties,
          actions: actionInputsWithoutAgents.map((action) => ({
            name: action.name,
            description: action.description,
            parameters: JSON.parse(action.jsonSchema),
          })),
        }),
      });

      if (!response.ok) {
        logger.error(
          { url, status: response.status, body: await response.text() },
          "Failed to execute remote agent",
        );
        throw new Error("Failed to execute remote agent");
      }

      const eventSource = new RemoteLangGraphEventSource();
      eventSource.streamResponse(response);
      return eventSource.processLangGraphEvents();
    },
  }));

  return [...actions, ...agents];
}

export async function setupRemoteActions({
  remoteActionDefinitions,
  graphqlContext,
  messages,
  agentStates,
  frontendUrl,
}: {
  remoteActionDefinitions: RemoteActionDefinition[];
  graphqlContext: GraphQLContext;
  messages: Message[];
  agentStates?: AgentStateInput[];
  frontendUrl?: string;
}): Promise<Action[]> {
  const logger = graphqlContext.logger.child({ component: "remote-actions.fetchRemoteActions" });
  logger.debug({ remoteActionDefinitions }, "Fetching remote actions");

  // Remove duplicates of remoteActionDefinitions.url
  const filtered = remoteActionDefinitions.filter(
    (value, index, self) => index === self.findIndex((t) => t.url === value.url),
  );

  const result = await Promise.all(
    filtered.map(async (actionDefinition) => {
      const json = await fetchRemoteInfo({
        url: actionDefinition.url,
        onBeforeRequest: actionDefinition.onBeforeRequest,
        graphqlContext,
        logger: logger.child({ component: "remote-actions.fetchActionsFromUrl", actionDefinition }),
        frontendUrl,
      });
      return constructRemoteActions({
        json,
        messages,
        url: actionDefinition.url,
        onBeforeRequest: actionDefinition.onBeforeRequest,
        graphqlContext,
        logger: logger.child({ component: "remote-actions.constructActions", actionDefinition }),
        agentStates,
      });
    }),
  );

  return result.flat();
}



---
File: /CopilotKit/packages/runtime/src/lib/index.ts
---

export * from "./runtime/copilot-runtime";
export * from "../service-adapters/openai/openai-adapter";
export * from "../service-adapters/langchain/langchain-adapter";
export * from "../service-adapters/google/google-genai-adapter";
export * from "../service-adapters/openai/openai-assistant-adapter";
export * from "../service-adapters/unify/unify-adapter";
export * from "../service-adapters/groq/groq-adapter";
export * from "./integrations";



---
File: /CopilotKit/packages/runtime/src/lib/logger.ts
---

import createPinoLogger from "pino";
import pretty from "pino-pretty";

export type LogLevel = "debug" | "info" | "warn" | "error";

export type CopilotRuntimeLogger = ReturnType<typeof createLogger>;

export function createLogger(options?: { level?: LogLevel; component?: string }) {
  const { level, component } = options || {};
  const stream = pretty({ colorize: true });

  const logger = createPinoLogger(
    {
      level: process.env.LOG_LEVEL || level || "error",
      redact: {
        paths: ["pid", "hostname"],
        remove: true,
      },
    },
    stream,
  );

  if (component) {
    return logger.child({ component });
  } else {
    return logger;
  }
}



---
File: /CopilotKit/packages/runtime/src/lib/telemetry-client.ts
---

import { TelemetryClient } from "@copilotkit/shared";
const packageJson = require("../../package.json");

const telemetryClient = new TelemetryClient({
  packageName: packageJson.name,
  packageVersion: packageJson.version,
});

export default telemetryClient;



---
File: /CopilotKit/packages/runtime/src/service-adapters/anthropic/anthropic-adapter.ts
---

/**
 * Copilot Runtime adapter for Anthropic.
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, AnthropicAdapter } from "@copilotkit/runtime";
 * import Anthropic from "@anthropic-ai/sdk";
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const anthropic = new Anthropic({
 *   apiKey: "<your-api-key>",
 * });
 *
 * const serviceAdapter = new AnthropicAdapter({ anthropic });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 */
import Anthropic from "@anthropic-ai/sdk";
import {
  CopilotServiceAdapter,
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import {
  convertActionInputToAnthropicTool,
  convertMessageToAnthropicMessage,
  groupAnthropicMessagesByRole,
  limitMessagesToTokenCount,
} from "./utils";

import { randomId } from "@copilotkit/shared";
import { TextMessage } from "../../graphql/types/converted";

const DEFAULT_MODEL = "claude-3-opus-20240229";

export interface AnthropicAdapterParams {
  /**
   * An optional Anthropic instance to use.  If not provided, a new instance will be
   * created.
   */
  anthropic?: Anthropic;

  /**
   * The model to use.
   */
  model?: string;
}

export class AnthropicAdapter implements CopilotServiceAdapter {
  private model: string = DEFAULT_MODEL;

  private _anthropic: Anthropic;
  public get anthropic(): Anthropic {
    return this._anthropic;
  }

  constructor(params?: AnthropicAdapterParams) {
    this._anthropic = params?.anthropic || new Anthropic({});
    if (params?.model) {
      this.model = params.model;
    }
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const {
      threadId,
      model = this.model,
      messages: rawMessages,
      actions,
      eventSource,
      forwardedParameters,
    } = request;
    const tools = actions.map(convertActionInputToAnthropicTool);

    const messages = [...rawMessages];

    // get the instruction message
    const instructionsMessage = messages.shift();
    const instructions =
      instructionsMessage instanceof TextMessage ? instructionsMessage.content : "";

    let anthropicMessages = messages.map(convertMessageToAnthropicMessage);
    anthropicMessages = limitMessagesToTokenCount(anthropicMessages, tools, model);
    anthropicMessages = groupAnthropicMessagesByRole(anthropicMessages);

    let toolChoice: any = forwardedParameters?.toolChoice;
    if (forwardedParameters?.toolChoice === "function") {
      toolChoice = {
        type: "tool",
        name: forwardedParameters.toolChoiceFunctionName,
      };
    }

    const stream = this.anthropic.messages.create({
      system: instructions,
      model: this.model,
      messages: anthropicMessages,
      max_tokens: forwardedParameters?.maxTokens || 1024,
      ...(tools.length > 0 && { tools }),
      ...(toolChoice && { tool_choice: toolChoice }),
      stream: true,
    });

    eventSource.stream(async (eventStream$) => {
      let mode: "function" | "message" | null = null;
      let didOutputText = false;
      let currentMessageId = randomId();
      let currentToolCallId = randomId();
      let filterThinkingTextBuffer = new FilterThinkingTextBuffer();

      for await (const chunk of await stream) {
        if (chunk.type === "message_start") {
          currentMessageId = chunk.message.id;
        } else if (chunk.type === "content_block_start") {
          if (chunk.content_block.type === "text") {
            didOutputText = false;
            filterThinkingTextBuffer.reset();
            mode = "message";
          } else if (chunk.content_block.type === "tool_use") {
            currentToolCallId = chunk.content_block.id;
            eventStream$.sendActionExecutionStart(currentToolCallId, chunk.content_block.name);
            mode = "function";
          }
        } else if (chunk.type === "content_block_delta") {
          if (chunk.delta.type === "text_delta") {
            const text = filterThinkingTextBuffer.onTextChunk(chunk.delta.text);
            if (text.length > 0) {
              if (!didOutputText) {
                eventStream$.sendTextMessageStart(currentMessageId);
                didOutputText = true;
              }
              eventStream$.sendTextMessageContent(text);
            }
          } else if (chunk.delta.type === "input_json_delta") {
            eventStream$.sendActionExecutionArgs(chunk.delta.partial_json);
          }
        } else if (chunk.type === "content_block_stop") {
          if (mode === "message") {
            if (didOutputText) {
              eventStream$.sendTextMessageEnd();
            }
          } else if (mode === "function") {
            eventStream$.sendActionExecutionEnd();
          }
        }
      }

      eventStream$.complete();
    });

    return {
      threadId: threadId || randomId(),
    };
  }
}

const THINKING_TAG = "<thinking>";
const THINKING_TAG_END = "</thinking>";

class FilterThinkingTextBuffer {
  private buffer: string;
  private didFilterThinkingTag: boolean = false;

  constructor() {
    this.buffer = "";
  }

  onTextChunk(text: string): string {
    this.buffer += text;
    if (this.didFilterThinkingTag) {
      return text;
    }
    const potentialTag = this.buffer.slice(0, THINKING_TAG.length);
    if (THINKING_TAG.startsWith(potentialTag)) {
      if (this.buffer.includes(THINKING_TAG_END)) {
        const end = this.buffer.indexOf(THINKING_TAG_END);
        const filteredText = this.buffer.slice(end + THINKING_TAG_END.length);
        this.buffer = filteredText;
        this.didFilterThinkingTag = true;
        return filteredText;
      } else {
        return "";
      }
    }
    return text;
  }

  reset() {
    this.buffer = "";
    this.didFilterThinkingTag = false;
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/anthropic/utils.ts
---

import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "../../graphql/types/converted";
import { ActionInput } from "../../graphql/inputs/action.input";
import { Anthropic } from "@anthropic-ai/sdk";

export function limitMessagesToTokenCount(
  messages: any[],
  tools: any[],
  model: string,
  maxTokens?: number,
): any[] {
  maxTokens ||= MAX_TOKENS;

  const result: any[] = [];
  const toolsNumTokens = countToolsTokens(model, tools);
  if (toolsNumTokens > maxTokens) {
    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);
  }
  maxTokens -= toolsNumTokens;

  for (const message of messages) {
    if (message.role === "system") {
      const numTokens = countMessageTokens(model, message);
      maxTokens -= numTokens;

      if (maxTokens < 0) {
        throw new Error("Not enough tokens for system message.");
      }
    }
  }

  let cutoff: boolean = false;

  const reversedMessages = [...messages].reverse();
  for (const message of reversedMessages) {
    if (message.role === "system") {
      result.unshift(message);
      continue;
    } else if (cutoff) {
      continue;
    }
    let numTokens = countMessageTokens(model, message);
    if (maxTokens < numTokens) {
      cutoff = true;
      continue;
    }
    result.unshift(message);
    maxTokens -= numTokens;
  }

  return result;
}

const MAX_TOKENS = 128000;

function countToolsTokens(model: string, tools: any[]): number {
  if (tools.length === 0) {
    return 0;
  }
  const json = JSON.stringify(tools);
  return countTokens(model, json);
}

function countMessageTokens(model: string, message: any): number {
  return countTokens(model, JSON.stringify(message.content) || "");
}

function countTokens(model: string, text: string): number {
  return text.length / 3;
}

export function convertActionInputToAnthropicTool(action: ActionInput): Anthropic.Messages.Tool {
  return {
    name: action.name,
    description: action.description,
    input_schema: JSON.parse(action.jsonSchema),
  };
}

export function convertMessageToAnthropicMessage(
  message: Message,
): Anthropic.Messages.MessageParam {
  if (message instanceof TextMessage) {
    if (message.role === "system") {
      return {
        role: "assistant",
        content: [
          { type: "text", text: "THE FOLLOWING MESSAGE IS A SYSTEM MESSAGE: " + message.content },
        ],
      };
    } else {
      return {
        role: message.role === "user" ? "user" : "assistant",
        content: [{ type: "text", text: message.content }],
      };
    }
  } else if (message instanceof ActionExecutionMessage) {
    return {
      role: "assistant",
      content: [
        {
          id: message.id,
          type: "tool_use",
          input: message.arguments,
          name: message.name,
        },
      ],
    };
  } else if (message instanceof ResultMessage) {
    return {
      role: "user",
      content: [
        {
          type: "tool_result",
          content: message.result,
          tool_use_id: message.actionExecutionId,
        },
      ],
    };
  }
}

export function groupAnthropicMessagesByRole(
  messageParams: Anthropic.Messages.MessageParam[],
): Anthropic.Messages.MessageParam[] {
  return messageParams.reduce((acc, message) => {
    const lastGroup = acc[acc.length - 1];

    if (lastGroup && lastGroup.role === message.role) {
      lastGroup.content = lastGroup.content.concat(message.content as any);
    } else {
      acc.push({
        role: message.role,
        content: [...(message.content as any)],
      });
    }

    return acc;
  }, [] as Anthropic.Messages.MessageParam[]);
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/experimental/ollama/ollama-adapter.ts
---

/**
 * CopilotKit Adapter for Ollama
 *
 * <RequestExample>
 * ```jsx CopilotRuntime Example
 * const copilotKit = new CopilotRuntime();
 * return copilotKit.response(req, new OllamaAdapter());
 * ```
 * </RequestExample>
 *
 * You can easily set the model to use by passing it to the constructor.
 * ```jsx
 * const copilotKit = new CopilotRuntime();
 * return copilotKit.response(
 *   req,
 *   new OllamaAdapter({ model: "llama3-70b-8192" }),
 * );
 * ```
 */
import { TextMessage } from "../../../graphql/types/converted";
import {
  CopilotServiceAdapter,
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../../service-adapter";
import { Ollama } from "@langchain/community/llms/ollama";
import { randomId } from "@copilotkit/shared";

const DEFAULT_MODEL = "llama3:latest";

interface OllamaAdapterOptions {
  model?: string;
}

export class ExperimentalOllamaAdapter implements CopilotServiceAdapter {
  private model: string;

  constructor(options?: OllamaAdapterOptions) {
    if (options?.model) {
      this.model = options.model;
    } else {
      this.model = DEFAULT_MODEL;
    }
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const { messages, actions, eventSource } = request;
    // const messages = this.transformMessages(forwardedProps.messages);

    const ollama = new Ollama({
      model: this.model,
    });
    const contents = (messages.filter((m) => m instanceof TextMessage) as TextMessage[]).map(
      (m) => m.content,
    );
    const _stream = await ollama.stream(contents); // [TODO] role info is dropped...

    eventSource.stream(async (eventStream$) => {
      eventStream$.sendTextMessageStart(randomId());
      for await (const chunkText of _stream) {
        eventStream$.sendTextMessageContent(chunkText);
      }
      eventStream$.sendTextMessageEnd();
      // we may need to add this later.. [nc]
      // let calls = (await result.response).functionCalls();

      eventStream$.complete();
    });
    return {
      threadId: request.threadId || randomId(),
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/google/google-genai-adapter.ts
---

/**
 * Copilot Runtime adapter for Google Generative AI (e.g. Gemini).
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, GoogleGenerativeAIAdapter } from "@copilotkit/runtime";
 * const { GoogleGenerativeAI } = require("@google/generative-ai");
 *
 * const genAI = new GoogleGenerativeAI(process.env["GOOGLE_API_KEY"]);
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const model = genAI.getGenerativeModel({
 *   model: "gemini-pro"
 * });
 *
 * const serviceAdapter = new GoogleGenerativeAIAdapter({ model });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 */
import { CopilotServiceAdapter } from "../service-adapter";
import {
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import { GenerativeModel, GoogleGenerativeAI } from "@google/generative-ai";
import { TextMessage } from "../../graphql/types/converted";
import { convertMessageToGoogleGenAIMessage, transformActionToGoogleGenAITool } from "./utils";
import { randomId } from "@copilotkit/shared";

interface GoogleGenerativeAIAdapterOptions {
  /**
   * A custom Google Generative AI model to use.
   */
  model?: GenerativeModel;
}

export class GoogleGenerativeAIAdapter implements CopilotServiceAdapter {
  private model: GenerativeModel;

  constructor(options?: GoogleGenerativeAIAdapterOptions) {
    if (options?.model) {
      this.model = options.model;
    } else {
      const genAI = new GoogleGenerativeAI(process.env["GOOGLE_API_KEY"]!);
      this.model = genAI.getGenerativeModel({ model: "gemini-pro" });
    }
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const { messages, actions, eventSource } = request;

    // get the history (everything except the first and last message)
    const history = messages.slice(1, -1).map(convertMessageToGoogleGenAIMessage);

    // get the current message (the last message)
    const currentMessage = convertMessageToGoogleGenAIMessage(messages.at(-1));
    if (!currentMessage) {
      throw new Error("No current message");
    }

    let systemMessage: string;
    const firstMessage = messages.at(0);
    if (firstMessage instanceof TextMessage && firstMessage.role === "system") {
      systemMessage = firstMessage.content.trim();
    } else {
      throw new Error("First message is not a system message");
    }

    const tools = actions.map(transformActionToGoogleGenAITool);

    const isFirstGenGeminiPro =
      this.model.model === "gemini-pro" || this.model.model === "models/gemini-pro";

    const chat = this.model.startChat({
      history: [
        ...history,
        // gemini-pro does not support system instructions, so we need to add them to the history
        ...(isFirstGenGeminiPro ? [{ role: "user", parts: [{ text: systemMessage }] }] : []),
      ],
      // only gemini-1.5-pro-latest and later supports setting system instructions
      ...(isFirstGenGeminiPro
        ? {}
        : { systemInstruction: { role: "user", parts: [{ text: systemMessage }] } }),
      tools,
    });

    const result = await chat.sendMessageStream(currentMessage.parts);

    eventSource.stream(async (eventStream$) => {
      let isTextMessage = false;
      for await (const chunk of result.stream) {
        const chunkText = chunk.text();
        if (chunkText === "") {
          continue;
        }
        if (!isTextMessage) {
          isTextMessage = true;
          eventStream$.sendTextMessageStart(randomId());
        }
        eventStream$.sendTextMessageContent(chunkText);
      }
      if (isTextMessage) {
        eventStream$.sendTextMessageEnd();
      }

      let calls = (await result.response).functionCalls();
      if (calls) {
        for (let call of calls) {
          eventStream$.sendActionExecution(
            randomId(),
            call.name,
            JSON.stringify(replaceNewlinesInObject(call.args)),
          );
        }
      }
      eventStream$.complete();
    });

    return {
      threadId: request.threadId || randomId(),
    };
  }
}

function replaceNewlinesInObject(obj: any): any {
  if (typeof obj === "string") {
    return obj.replace(/\\\\n/g, "\n");
  } else if (Array.isArray(obj)) {
    return obj.map(replaceNewlinesInObject);
  } else if (typeof obj === "object" && obj !== null) {
    const newObj: any = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = replaceNewlinesInObject(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/google/utils.ts
---

import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "../../graphql/types/converted";
import { Tool } from "@google/generative-ai";
import { ActionInput } from "../../graphql/inputs/action.input";

export function convertMessageToGoogleGenAIMessage(message: Message) {
  if (message instanceof TextMessage) {
    const role = {
      user: "user",
      assistant: "model",
      system: "user",
    }[message.role];

    const text =
      message.role === "system"
        ? "THE FOLLOWING MESSAGE IS A SYSTEM MESSAGE: " + message.content
        : message.content;

    return {
      role,
      parts: [{ text }],
    };
  } else if (message instanceof ActionExecutionMessage) {
    return {
      role: "model",
      parts: [
        {
          functionCall: {
            name: message.name,
            args: message.arguments,
          },
        },
      ],
    };
  } else if (message instanceof ResultMessage) {
    return {
      role: "function",
      parts: [
        {
          functionResponse: {
            name: message.actionName,
            response: {
              name: message.actionName,
              content: tryParseJson(message.result),
            },
          },
        },
      ],
    };
  }
}

export function transformActionToGoogleGenAITool(action: ActionInput): Tool {
  const name = action.name;
  const description = action.description;
  const parameters = JSON.parse(action.jsonSchema);

  const transformProperties = (props: any) => {
    for (const key in props) {
      if (props[key].type) {
        props[key].type = props[key].type.toUpperCase();
      }
      if (props[key].properties) {
        transformProperties(props[key].properties);
      }
    }
  };
  transformProperties(parameters);

  return {
    functionDeclarations: [
      {
        name,
        description,
        parameters,
      },
    ],
  };
}

function tryParseJson(str?: string) {
  if (!str) {
    return "";
  }
  try {
    return JSON.parse(str);
  } catch (e) {
    return str;
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/groq/groq-adapter.ts
---

/**
 * Copilot Runtime adapter for Groq.
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, GroqAdapter } from "@copilotkit/runtime";
 * import { Groq } from "groq-sdk";
 *
 * const groq = new Groq({ apiKey: process.env["GROQ_API_KEY"] });
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const serviceAdapter = new GroqAdapter({ groq, model: "<model-name>" });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 */
import { Groq } from "groq-sdk";
import {
  CopilotServiceAdapter,
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import {
  convertActionInputToOpenAITool,
  convertMessageToOpenAIMessage,
  limitMessagesToTokenCount,
} from "../openai/utils";
import { randomId } from "@copilotkit/shared";

const DEFAULT_MODEL = "llama3-groq-70b-8192-tool-use-preview";

export interface GroqAdapterParams {
  /**
   * An optional Groq instance to use.
   */
  groq?: Groq;

  /**
   * The model to use.
   */
  model?: string;

  /**
   * Whether to disable parallel tool calls.
   * You can disable parallel tool calls to force the model to execute tool calls sequentially.
   * This is useful if you want to execute tool calls in a specific order so that the state changes
   * introduced by one tool call are visible to the next tool call. (i.e. new actions or readables)
   *
   * @default false
   */
  disableParallelToolCalls?: boolean;
}

export class GroqAdapter implements CopilotServiceAdapter {
  private model: string = DEFAULT_MODEL;

  private disableParallelToolCalls: boolean = false;
  private _groq: Groq;
  public get groq(): Groq {
    return this._groq;
  }

  constructor(params?: GroqAdapterParams) {
    this._groq = params?.groq || new Groq({});
    if (params?.model) {
      this.model = params.model;
    }
    this.disableParallelToolCalls = params?.disableParallelToolCalls || false;
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const {
      threadId,
      model = this.model,
      messages,
      actions,
      eventSource,
      forwardedParameters,
    } = request;
    const tools = actions.map(convertActionInputToOpenAITool);

    let openaiMessages = messages.map(convertMessageToOpenAIMessage);
    openaiMessages = limitMessagesToTokenCount(openaiMessages, tools, model);

    let toolChoice: any = forwardedParameters?.toolChoice;
    if (forwardedParameters?.toolChoice === "function") {
      toolChoice = {
        type: "function",
        function: { name: forwardedParameters.toolChoiceFunctionName },
      };
    }
    const stream = await this.groq.chat.completions.create({
      model: model,
      stream: true,
      messages: openaiMessages,
      ...(tools.length > 0 && { tools }),
      ...(forwardedParameters?.maxTokens && {
        max_tokens: forwardedParameters.maxTokens,
      }),
      ...(forwardedParameters?.stop && { stop: forwardedParameters.stop }),
      ...(toolChoice && { tool_choice: toolChoice }),
      ...(this.disableParallelToolCalls && { parallel_tool_calls: false }),
    });

    eventSource.stream(async (eventStream$) => {
      let mode: "function" | "message" | null = null;
      for await (const chunk of stream) {
        const toolCall = chunk.choices[0].delta.tool_calls?.[0];
        const content = chunk.choices[0].delta.content;

        // When switching from message to function or vice versa,
        // send the respective end event.
        // If toolCall?.id is defined, it means a new tool call starts.
        if (mode === "message" && toolCall?.id) {
          mode = null;
          eventStream$.sendTextMessageEnd();
        } else if (mode === "function" && (toolCall === undefined || toolCall?.id)) {
          mode = null;
          eventStream$.sendActionExecutionEnd();
        }

        // If we send a new message type, send the appropriate start event.
        if (mode === null) {
          if (toolCall?.id) {
            mode = "function";
            eventStream$.sendActionExecutionStart(toolCall!.id, toolCall!.function!.name);
          } else if (content) {
            mode = "message";
            eventStream$.sendTextMessageStart(chunk.id);
          }
        }

        // send the content events
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent(content);
        } else if (mode === "function" && toolCall?.function?.arguments) {
          eventStream$.sendActionExecutionArgs(toolCall.function.arguments);
        }
      }

      // send the end events
      if (mode === "message") {
        eventStream$.sendTextMessageEnd();
      } else if (mode === "function") {
        eventStream$.sendActionExecutionEnd();
      }

      eventStream$.complete();
    });

    return {
      threadId: threadId || randomId(),
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/langchain/langchain-adapter.ts
---

/**
 * Copilot Runtime adapter for LangChain.
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, LangChainAdapter } from "@copilotkit/runtime";
 * import { ChatOpenAI } from "@langchain/openai";
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const model = new ChatOpenAI({
 *   model: "gpt-4o",
 *   apiKey: "<your-api-key>",
 * });
 *
 * const serviceAdapter = new LangChainAdapter({
 *   chainFn: async ({ messages, tools }) => {
 *     return model.stream(messages, { tools });
 *   }
 * });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 *
 * The asynchronous handler function (`chainFn`) can return any of the following:
 *
 * - A simple `string` response
 * - A LangChain stream (`IterableReadableStream`)
 * - A LangChain `BaseMessageChunk` object
 * - A LangChain `AIMessage` object
 */

import { BaseMessage } from "@langchain/core/messages";
import { CopilotServiceAdapter } from "../service-adapter";
import {
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import {
  convertActionInputToLangChainTool,
  convertMessageToLangChainMessage,
  streamLangChainResponse,
} from "./utils";
import { DynamicStructuredTool } from "@langchain/core/tools";
import { LangChainReturnType } from "./types";
import { randomId } from "@copilotkit/shared";

interface ChainFnParameters {
  model: string;
  messages: BaseMessage[];
  tools: DynamicStructuredTool[];
  threadId?: string;
  runId?: string;
}

interface LangChainAdapterOptions {
  /**
   * A function that uses the LangChain API to generate a response.
   */
  chainFn: (parameters: ChainFnParameters) => Promise<LangChainReturnType>;
}

export class LangChainAdapter implements CopilotServiceAdapter {
  /**
   * To use LangChain as a backend, provide a handler function to the adapter with your custom LangChain logic.
   */
  constructor(private options: LangChainAdapterOptions) {}

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const { eventSource, model, actions, messages, threadId, runId } = request;
    const result = await this.options.chainFn({
      messages: messages.map(convertMessageToLangChainMessage),
      tools: actions.map(convertActionInputToLangChainTool),
      model,
      threadId,
      runId,
    });

    eventSource.stream(async (eventStream$) => {
      await streamLangChainResponse({
        result,
        eventStream$,
      });
    });

    return {
      threadId: threadId || randomId(),
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/langchain/langserve.ts
---

import { Parameter, Action } from "@copilotkit/shared";
import { RemoteRunnable } from "langchain/runnables/remote";

export interface RemoteChainParameters {
  name: string;
  description: string;
  chainUrl: string;
  parameters?: Parameter[];
  parameterType?: "single" | "multi";
}

export class RemoteChain {
  name: string;
  description: string;
  chainUrl: string;
  parameters?: Parameter[];
  parameterType: "single" | "multi";

  constructor(options: RemoteChainParameters) {
    this.name = options.name;
    this.description = options.description;
    this.chainUrl = options.chainUrl;
    this.parameters = options.parameters;
    this.parameterType = options.parameterType || "multi";
  }

  async toAction(): Promise<Action<any>> {
    if (!this.parameters) {
      await this.inferLangServeParameters();
    }

    return {
      name: this.name,
      description: this.description,
      parameters: this.parameters!,
      handler: async (args: any) => {
        const runnable = new RemoteRunnable({ url: this.chainUrl });
        let input: any;
        if (this.parameterType === "single") {
          input = args[Object.keys(args)[0]];
        } else {
          input = args;
        }
        return await runnable.invoke(input);
      },
    };
  }

  async inferLangServeParameters() {
    const supportedTypes = ["string", "number", "boolean"];

    let schemaUrl = this.chainUrl.replace(/\/+$/, "") + "/input_schema";
    let schema = await fetch(schemaUrl)
      .then((res) => res.json())
      .catch(() => {
        throw new Error("Failed to fetch langserve schema at " + schemaUrl);
      });
    // for now, don't use json schema, just do a simple conversion

    if (supportedTypes.includes(schema.type)) {
      this.parameterType = "single";
      this.parameters = [
        {
          name: "input",
          type: schema.type,
          description: "The input to the chain",
        },
      ];
    } else if (schema.type === "object") {
      this.parameterType = "multi";
      this.parameters = Object.keys(schema.properties).map((key) => {
        let property = schema.properties[key];
        if (!supportedTypes.includes(property.type)) {
          throw new Error("Unsupported schema type");
        }
        return {
          name: key,
          type: property.type,
          description: property.description || "",
          required: schema.required?.includes(key) || false,
        };
      });
    } else {
      throw new Error("Unsupported schema type");
    }
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/langchain/types.ts
---

import { AIMessage, AIMessageChunk, BaseMessageChunk } from "@langchain/core/messages";
import {
  IterableReadableStream,
  IterableReadableStreamInterface,
} from "@langchain/core/utils/stream";

export type LangChainBaseMessageChunkStream = IterableReadableStream<BaseMessageChunk>;
export type LangChainAIMessageChunkStream = IterableReadableStreamInterface<AIMessageChunk>;
export type LangChainReturnType =
  | LangChainBaseMessageChunkStream
  | LangChainAIMessageChunkStream
  | BaseMessageChunk
  | string
  | AIMessage;



---
File: /CopilotKit/packages/runtime/src/service-adapters/langchain/utils.ts
---

import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "../../graphql/types/converted";
import {
  AIMessage,
  AIMessageChunk,
  BaseMessage,
  BaseMessageChunk,
  HumanMessage,
  SystemMessage,
  ToolMessage,
} from "@langchain/core/messages";
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import { ActionInput } from "../../graphql/inputs/action.input";
import { LangChainReturnType } from "./types";
import { RuntimeEventSubject } from "../events";
import { randomId } from "@copilotkit/shared";

export function convertMessageToLangChainMessage(message: Message): BaseMessage {
  if (message instanceof TextMessage) {
    if (message.role == "user") {
      return new HumanMessage(message.content);
    } else if (message.role == "assistant") {
      return new AIMessage(message.content);
    } else if (message.role === "system") {
      return new SystemMessage(message.content);
    }
  } else if (message instanceof ActionExecutionMessage) {
    return new AIMessage({
      content: "",
      tool_calls: [
        {
          id: message.id,
          args: message.arguments,
          name: message.name,
        },
      ],
    });
  } else if (message instanceof ResultMessage) {
    return new ToolMessage({
      content: message.result,
      tool_call_id: message.actionExecutionId,
    });
  }
}

export function convertJsonSchemaToZodSchema(jsonSchema: any, required: boolean): z.ZodSchema {
  if (jsonSchema.type === "object") {
    const spec: { [key: string]: z.ZodSchema } = {};
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      spec[key] = convertJsonSchemaToZodSchema(
        value,
        jsonSchema.required ? jsonSchema.required.includes(key) : false,
      );
    }
    let schema = z.object(spec);
    return !required ? schema.optional() : schema;
  } else if (jsonSchema.type === "string") {
    let schema = z.string().describe(jsonSchema.description);
    return !required ? schema.optional() : schema;
  } else if (jsonSchema.type === "number") {
    let schema = z.number().describe(jsonSchema.description);
    return !required ? schema.optional() : schema;
  } else if (jsonSchema.type === "boolean") {
    let schema = z.boolean().describe(jsonSchema.description);
    return !required ? schema.optional() : schema;
  } else if (jsonSchema.type === "array") {
    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, false);
    let schema = z.array(itemSchema);
    return !required ? schema.optional() : schema;
  }
}

export function convertActionInputToLangChainTool(actionInput: ActionInput): any {
  return new DynamicStructuredTool({
    name: actionInput.name,
    description: actionInput.description,
    schema: convertJsonSchemaToZodSchema(
      JSON.parse(actionInput.jsonSchema),
      true,
    ) as z.ZodObject<any>,
    func: async () => {
      return "";
    },
  });
}

interface StreamLangChainResponseParams {
  result: LangChainReturnType;
  eventStream$: RuntimeEventSubject;
  actionExecution?: {
    id: string;
    name: string;
  };
}

function getConstructorName(object: any): string {
  if (object && typeof object === "object" && object.constructor && object.constructor.name) {
    return object.constructor.name;
  }
  return "";
}

function isAIMessage(message: any): message is AIMessage {
  return getConstructorName(message) === "AIMessage";
}

function isAIMessageChunk(message: any): message is AIMessageChunk {
  return getConstructorName(message) === "AIMessageChunk";
}

function isBaseMessageChunk(message: any): message is BaseMessageChunk {
  return getConstructorName(message) === "BaseMessageChunk";
}

function maybeSendActionExecutionResultIsMessage(
  eventStream$: RuntimeEventSubject,
  actionExecution?: { id: string; name: string },
) {
  // language models need a result after the function call
  // we simply let them know that we are sending a message
  if (actionExecution) {
    eventStream$.sendActionExecutionResult(
      actionExecution.id,
      actionExecution.name,
      "Sending a message",
    );
  }
}

export async function streamLangChainResponse({
  result,
  eventStream$,
  actionExecution,
}: StreamLangChainResponseParams) {
  // We support several types of return values from LangChain functions:

  // 1. string

  if (typeof result === "string") {
    if (!actionExecution) {
      // Just send one chunk with the string as the content.
      eventStream$.sendTextMessage(randomId(), result);
    } else {
      // Send as a result
      eventStream$.sendActionExecutionResult(actionExecution.id, actionExecution.name, result);
    }
  }

  // 2. AIMessage
  // Send the content and function call of the AIMessage as the content of the chunk.
  else if (isAIMessage(result)) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);

    if (result.content) {
      eventStream$.sendTextMessage(randomId(), result.content as string);
    }
    for (const toolCall of result.tool_calls) {
      eventStream$.sendActionExecution(
        toolCall.id || randomId(),
        toolCall.name,
        JSON.stringify(toolCall.args),
      );
    }
  }

  // 3. BaseMessageChunk
  // Send the content and function call of the AIMessage as the content of the chunk.
  else if (isBaseMessageChunk(result)) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);

    if (result.lc_kwargs?.content) {
      eventStream$.sendTextMessage(randomId(), result.content as string);
    }
    if (result.lc_kwargs?.tool_calls) {
      for (const toolCall of result.lc_kwargs?.tool_calls) {
        eventStream$.sendActionExecution(
          toolCall.id || randomId(),
          toolCall.name,
          JSON.stringify(toolCall.args),
        );
      }
    }
  }

  // 4. IterableReadableStream
  // Stream the result of the LangChain function.
  else if (result && "getReader" in result) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);

    let reader = result.getReader();

    let mode: "function" | "message" | null = null;

    while (true) {
      try {
        const { done, value } = await reader.read();

        let toolCallName: string | undefined = undefined;
        let toolCallId: string | undefined = undefined;
        let toolCallArgs: string | undefined = undefined;
        let hasToolCall: boolean = false;
        let content = value?.content as string;

        if (isAIMessageChunk(value)) {
          let chunk = value.tool_call_chunks?.[0];
          toolCallName = chunk?.name;
          toolCallId = chunk?.id;
          toolCallArgs = chunk?.args;
          hasToolCall = chunk != undefined;
        } else if (isBaseMessageChunk(value)) {
          let chunk = value.additional_kwargs?.tool_calls?.[0];
          toolCallName = chunk?.function?.name;
          toolCallId = chunk?.id;
          toolCallArgs = chunk?.function?.arguments;
          hasToolCall = chunk?.function != undefined;
        }

        // When switching from message to function or vice versa,
        // send the respective end event.
        // If toolCallName is defined, it means a new tool call starts.
        if (mode === "message" && (toolCallId || done)) {
          mode = null;
          eventStream$.sendTextMessageEnd();
        } else if (mode === "function" && (!hasToolCall || done)) {
          mode = null;
          eventStream$.sendActionExecutionEnd();
        }

        if (done) {
          break;
        }

        // If we send a new message type, send the appropriate start event.
        if (mode === null) {
          if (hasToolCall) {
            mode = "function";
            eventStream$.sendActionExecutionStart(toolCallId, toolCallName);
          } else if (content) {
            mode = "message";
            eventStream$.sendTextMessageStart(randomId());
          }
        }

        // send the content events
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent(content);
        } else if (mode === "function" && toolCallArgs) {
          eventStream$.sendActionExecutionArgs(toolCallArgs);
        }
      } catch (error) {
        console.error("Error reading from stream", error);
        break;
      }
    }
  } else if (actionExecution) {
    eventStream$.sendActionExecutionResult(
      actionExecution.id,
      actionExecution.name,
      encodeResult(result),
    );
  }

  // unsupported type
  else {
    throw new Error("Invalid return type from LangChain function.");
  }

  eventStream$.complete();
}

function encodeResult(result: any): string {
  if (result === undefined) {
    return "";
  } else if (typeof result === "string") {
    return result;
  } else {
    return JSON.stringify(result);
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/openai/openai-adapter.ts
---

/**
 * Copilot Runtime adapter for OpenAI.
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/runtime";
 * import OpenAI from "openai";
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const openai = new OpenAI({
 *   organization: "<your-organization-id>", // optional
 *   apiKey: "<your-api-key>",
 * });
 *
 * const serviceAdapter = new OpenAIAdapter({ openai });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 */
import OpenAI from "openai";
import {
  CopilotServiceAdapter,
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import {
  convertActionInputToOpenAITool,
  convertMessageToOpenAIMessage,
  limitMessagesToTokenCount,
} from "./utils";
import { randomId } from "@copilotkit/shared";

const DEFAULT_MODEL = "gpt-4o";

export interface OpenAIAdapterParams {
  /**
   * An optional OpenAI instance to use.  If not provided, a new instance will be
   * created.
   */
  openai?: OpenAI;

  /**
   * The model to use.
   */
  model?: string;

  /**
   * Whether to disable parallel tool calls.
   * You can disable parallel tool calls to force the model to execute tool calls sequentially.
   * This is useful if you want to execute tool calls in a specific order so that the state changes
   * introduced by one tool call are visible to the next tool call. (i.e. new actions or readables)
   *
   * @default false
   */
  disableParallelToolCalls?: boolean;
}

export class OpenAIAdapter implements CopilotServiceAdapter {
  private model: string = DEFAULT_MODEL;

  private disableParallelToolCalls: boolean = false;
  private _openai: OpenAI;
  public get openai(): OpenAI {
    return this._openai;
  }

  constructor(params?: OpenAIAdapterParams) {
    this._openai = params?.openai || new OpenAI({});
    if (params?.model) {
      this.model = params.model;
    }
    this.disableParallelToolCalls = params?.disableParallelToolCalls || false;
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const {
      threadId,
      model = this.model,
      messages,
      actions,
      eventSource,
      forwardedParameters,
    } = request;
    const tools = actions.map(convertActionInputToOpenAITool);

    let openaiMessages = messages.map(convertMessageToOpenAIMessage);
    openaiMessages = limitMessagesToTokenCount(openaiMessages, tools, model);

    let toolChoice: any = forwardedParameters?.toolChoice;
    if (forwardedParameters?.toolChoice === "function") {
      toolChoice = {
        type: "function",
        function: { name: forwardedParameters.toolChoiceFunctionName },
      };
    }

    const stream = this.openai.beta.chat.completions.stream({
      model: model,
      stream: true,
      messages: openaiMessages,
      ...(tools.length > 0 && { tools }),
      ...(forwardedParameters?.maxTokens && { max_tokens: forwardedParameters.maxTokens }),
      ...(forwardedParameters?.stop && { stop: forwardedParameters.stop }),
      ...(toolChoice && { tool_choice: toolChoice }),
      ...(this.disableParallelToolCalls && { parallel_tool_calls: false }),
    });

    eventSource.stream(async (eventStream$) => {
      let mode: "function" | "message" | null = null;
      for await (const chunk of stream) {
        const toolCall = chunk.choices[0].delta.tool_calls?.[0];
        const content = chunk.choices[0].delta.content;

        // When switching from message to function or vice versa,
        // send the respective end event.
        // If toolCall?.id is defined, it means a new tool call starts.
        if (mode === "message" && toolCall?.id) {
          mode = null;
          eventStream$.sendTextMessageEnd();
        } else if (mode === "function" && (toolCall === undefined || toolCall?.id)) {
          mode = null;
          eventStream$.sendActionExecutionEnd();
        }

        // If we send a new message type, send the appropriate start event.
        if (mode === null) {
          if (toolCall?.id) {
            mode = "function";
            eventStream$.sendActionExecutionStart(toolCall!.id, toolCall!.function!.name);
          } else if (content) {
            mode = "message";
            eventStream$.sendTextMessageStart(chunk.id);
          }
        }

        // send the content events
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent(content);
        } else if (mode === "function" && toolCall?.function?.arguments) {
          eventStream$.sendActionExecutionArgs(toolCall.function.arguments);
        }
      }

      // send the end events
      if (mode === "message") {
        eventStream$.sendTextMessageEnd();
      } else if (mode === "function") {
        eventStream$.sendActionExecutionEnd();
      }

      eventStream$.complete();
    });

    return {
      threadId: threadId || randomId(),
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/openai/openai-assistant-adapter.ts
---

/**
 * Copilot Runtime adapter for the OpenAI Assistant API.
 *
 * ## Example
 *
 * ```ts
 * import { CopilotRuntime, OpenAIAssistantAdapter } from "@copilotkit/runtime";
 * import OpenAI from "openai";
 *
 * const copilotKit = new CopilotRuntime();
 *
 * const openai = new OpenAI({
 *   organization: "<your-organization-id>",
 *   apiKey: "<your-api-key>",
 * });
 *
 * const serviceAdapter = new OpenAIAssistantAdapter({
 *   openai,
 *   assistantId: "<your-assistant-id>",
 *   codeInterpreterEnabled: true,
 *   fileSearchEnabled: true,
 * });
 *
 * return copilotKit.streamHttpServerResponse(req, res, serviceAdapter);
 * ```
 */
import OpenAI from "openai";
import {
  CopilotServiceAdapter,
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
} from "../service-adapter";
import { Message, ResultMessage, TextMessage } from "../../graphql/types/converted";
import {
  convertActionInputToOpenAITool,
  convertMessageToOpenAIMessage,
  convertSystemMessageToAssistantAPI,
} from "./utils";
import { RunSubmitToolOutputsStreamParams } from "openai/resources/beta/threads/runs/runs";
import { AssistantStream } from "openai/lib/AssistantStream";
import { RuntimeEventSource } from "../events";
import { ActionInput } from "../../graphql/inputs/action.input";
import { AssistantStreamEvent, AssistantTool } from "openai/resources/beta/assistants";
import { ForwardedParametersInput } from "../../graphql/inputs/forwarded-parameters.input";

export interface OpenAIAssistantAdapterParams {
  /**
   * The ID of the assistant to use.
   */
  assistantId: string;

  /**
   * An optional OpenAI instance to use. If not provided, a new instance will be created.
   */
  openai?: OpenAI;

  /**
   * Whether to enable code interpretation.
   * @default true
   */
  codeInterpreterEnabled?: boolean;

  /**
   * Whether to enable file search.
   * @default true
   */
  fileSearchEnabled?: boolean;

  /**
   * Whether to disable parallel tool calls.
   * You can disable parallel tool calls to force the model to execute tool calls sequentially.
   * This is useful if you want to execute tool calls in a specific order so that the state changes
   * introduced by one tool call are visible to the next tool call. (i.e. new actions or readables)
   *
   * @default false
   */
  disableParallelToolCalls?: boolean;
}

export class OpenAIAssistantAdapter implements CopilotServiceAdapter {
  private openai: OpenAI;
  private codeInterpreterEnabled: boolean;
  private assistantId: string;
  private fileSearchEnabled: boolean;
  private disableParallelToolCalls: boolean;

  constructor(params: OpenAIAssistantAdapterParams) {
    this.openai = params.openai || new OpenAI({});
    this.codeInterpreterEnabled = params.codeInterpreterEnabled === false || true;
    this.fileSearchEnabled = params.fileSearchEnabled === false || true;
    this.assistantId = params.assistantId;
    this.disableParallelToolCalls = params?.disableParallelToolCalls || false;
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const { messages, actions, eventSource, runId, forwardedParameters } = request;
    // if we don't have a threadId, create a new thread
    let threadId = request.threadId || (await this.openai.beta.threads.create()).id;

    const lastMessage = messages.at(-1);

    let nextRunId: string | undefined = undefined;

    // submit function outputs
    if (lastMessage instanceof ResultMessage && runId) {
      nextRunId = await this.submitToolOutputs(threadId, runId, messages, eventSource);
    }
    // submit user message
    else if (lastMessage instanceof TextMessage) {
      nextRunId = await this.submitUserMessage(
        threadId,
        messages,
        actions,
        eventSource,
        forwardedParameters,
      );
    }
    // unsupported message
    else {
      throw new Error("No actionable message found in the messages");
    }

    return {
      threadId,
      runId: nextRunId,
    };
  }

  private async submitToolOutputs(
    threadId: string,
    runId: string,
    messages: Message[],
    eventSource: RuntimeEventSource,
  ) {
    let run = await this.openai.beta.threads.runs.retrieve(threadId, runId);
    if (!run.required_action) {
      throw new Error("No tool outputs required");
    }

    // get the required tool call ids
    const toolCallsIds = run.required_action.submit_tool_outputs.tool_calls.map(
      (toolCall) => toolCall.id,
    );

    // search for these tool calls
    const resultMessages = messages.filter(
      (message) =>
        message instanceof ResultMessage && toolCallsIds.includes(message.actionExecutionId),
    ) as ResultMessage[];

    if (toolCallsIds.length != resultMessages.length) {
      throw new Error("Number of function results does not match the number of tool calls");
    }

    // submit the tool outputs
    const toolOutputs: RunSubmitToolOutputsStreamParams.ToolOutput[] = resultMessages.map(
      (message) => {
        return {
          tool_call_id: message.actionExecutionId,
          output: message.result,
        };
      },
    );

    const stream = this.openai.beta.threads.runs.submitToolOutputsStream(threadId, runId, {
      tool_outputs: toolOutputs,
      ...(this.disableParallelToolCalls && { parallel_tool_calls: false }),
    });

    await this.streamResponse(stream, eventSource);
    return runId;
  }

  private async submitUserMessage(
    threadId: string,
    messages: Message[],
    actions: ActionInput[],
    eventSource: RuntimeEventSource,
    forwardedParameters: ForwardedParametersInput,
  ) {
    messages = [...messages];

    // get the instruction message
    const instructionsMessage = messages.shift();
    const instructions =
      instructionsMessage instanceof TextMessage ? instructionsMessage.content : "";

    // get the latest user message
    const userMessage = messages
      .map(convertMessageToOpenAIMessage)
      .map(convertSystemMessageToAssistantAPI)
      .at(-1);

    if (userMessage.role !== "user") {
      throw new Error("No user message found");
    }

    // create a new message on the thread
    await this.openai.beta.threads.messages.create(threadId, {
      role: "user",
      content: userMessage.content,
    });

    const openaiTools = actions.map(convertActionInputToOpenAITool);

    const tools = [
      ...openaiTools,
      ...(this.codeInterpreterEnabled ? [{ type: "code_interpreter" } as AssistantTool] : []),
      ...(this.fileSearchEnabled ? [{ type: "file_search" } as AssistantTool] : []),
    ];

    // run the thread
    let stream = this.openai.beta.threads.runs.stream(threadId, {
      assistant_id: this.assistantId,
      instructions,
      tools: tools,
      ...(forwardedParameters?.maxTokens && {
        max_completion_tokens: forwardedParameters.maxTokens,
      }),
      ...(this.disableParallelToolCalls && { parallel_tool_calls: false }),
    });

    await this.streamResponse(stream, eventSource);

    return getRunIdFromStream(stream);
  }

  private async streamResponse(stream: AssistantStream, eventSource: RuntimeEventSource) {
    eventSource.stream(async (eventStream$) => {
      let inFunctionCall = false;

      for await (const chunk of stream) {
        switch (chunk.event) {
          case "thread.message.created":
            if (inFunctionCall) {
              eventStream$.sendActionExecutionEnd();
            }
            eventStream$.sendTextMessageStart(chunk.data.id);
            break;
          case "thread.message.delta":
            if (chunk.data.delta.content?.[0].type === "text") {
              eventStream$.sendTextMessageContent(chunk.data.delta.content?.[0].text.value);
            }
            break;
          case "thread.message.completed":
            eventStream$.sendTextMessageEnd();
            break;
          case "thread.run.step.delta":
            let toolCallId: string | undefined;
            let toolCallName: string | undefined;
            let toolCallArgs: string | undefined;
            if (
              chunk.data.delta.step_details.type === "tool_calls" &&
              chunk.data.delta.step_details.tool_calls?.[0].type === "function"
            ) {
              toolCallId = chunk.data.delta.step_details.tool_calls?.[0].id;
              toolCallName = chunk.data.delta.step_details.tool_calls?.[0].function.name;
              toolCallArgs = chunk.data.delta.step_details.tool_calls?.[0].function.arguments;
            }

            if (toolCallName && toolCallId) {
              if (inFunctionCall) {
                eventStream$.sendActionExecutionEnd();
              }
              inFunctionCall = true;
              eventStream$.sendActionExecutionStart(toolCallId, toolCallName);
            } else if (toolCallArgs) {
              eventStream$.sendActionExecutionArgs(toolCallArgs);
            }
            break;
        }
      }
      if (inFunctionCall) {
        eventStream$.sendActionExecutionEnd();
      }
      eventStream$.complete();
    });
  }
}

function getRunIdFromStream(stream: AssistantStream): Promise<string> {
  return new Promise<string>((resolve, reject) => {
    let runIdGetter = (event: AssistantStreamEvent) => {
      if (event.event === "thread.run.created") {
        const runId = event.data.id;
        stream.off("event", runIdGetter);
        resolve(runId);
      }
    };
    stream.on("event", runIdGetter);
  });
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/openai/utils.ts
---

import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "../../graphql/types/converted";
import { ActionInput } from "../../graphql/inputs/action.input";
import { ChatCompletionMessageParam, ChatCompletionTool } from "openai/resources";

export function limitMessagesToTokenCount(
  messages: any[],
  tools: any[],
  model: string,
  maxTokens?: number,
): any[] {
  maxTokens ||= maxTokensForOpenAIModel(model);

  const result: any[] = [];
  const toolsNumTokens = countToolsTokens(model, tools);
  if (toolsNumTokens > maxTokens) {
    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);
  }
  maxTokens -= toolsNumTokens;

  for (const message of messages) {
    if (message.role === "system") {
      const numTokens = countMessageTokens(model, message);
      maxTokens -= numTokens;

      if (maxTokens < 0) {
        throw new Error("Not enough tokens for system message.");
      }
    }
  }

  let cutoff: boolean = false;

  const reversedMessages = [...messages].reverse();
  for (const message of reversedMessages) {
    if (message.role === "system") {
      result.unshift(message);
      continue;
    } else if (cutoff) {
      continue;
    }
    let numTokens = countMessageTokens(model, message);
    if (maxTokens < numTokens) {
      cutoff = true;
      continue;
    }
    result.unshift(message);
    maxTokens -= numTokens;
  }

  return result;
}

export function maxTokensForOpenAIModel(model: string): number {
  return maxTokensByModel[model] || DEFAULT_MAX_TOKENS;
}

const DEFAULT_MAX_TOKENS = 128000;

const maxTokensByModel: { [key: string]: number } = {
  // GPT-4
  "gpt-4o": 128000,
  "gpt-4o-2024-05-13": 128000,
  "gpt-4-turbo": 128000,
  "gpt-4-turbo-2024-04-09": 128000,
  "gpt-4-0125-preview": 128000,
  "gpt-4-turbo-preview": 128000,
  "gpt-4-1106-preview": 128000,
  "gpt-4-vision-preview": 128000,
  "gpt-4-1106-vision-preview": 128000,
  "gpt-4-32k": 32768,
  "gpt-4-32k-0613": 32768,
  "gpt-4-32k-0314": 32768,
  "gpt-4": 8192,
  "gpt-4-0613": 8192,
  "gpt-4-0314": 8192,

  // GPT-3.5
  "gpt-3.5-turbo-0125": 16385,
  "gpt-3.5-turbo": 16385,
  "gpt-3.5-turbo-1106": 16385,
  "gpt-3.5-turbo-instruct": 4096,
  "gpt-3.5-turbo-16k": 16385,
  "gpt-3.5-turbo-0613": 4096,
  "gpt-3.5-turbo-16k-0613": 16385,
  "gpt-3.5-turbo-0301": 4097,
};

function countToolsTokens(model: string, tools: any[]): number {
  if (tools.length === 0) {
    return 0;
  }
  const json = JSON.stringify(tools);
  return countTokens(model, json);
}

function countMessageTokens(model: string, message: any): number {
  return countTokens(model, message.content || "");
}

function countTokens(model: string, text: string): number {
  return text.length / 3;
}

export function convertActionInputToOpenAITool(action: ActionInput): ChatCompletionTool {
  return {
    type: "function",
    function: {
      name: action.name,
      description: action.description,
      parameters: JSON.parse(action.jsonSchema),
    },
  };
}

export function convertMessageToOpenAIMessage(message: Message): ChatCompletionMessageParam {
  if (message instanceof TextMessage) {
    return {
      role: message.role,
      content: message.content,
    };
  } else if (message instanceof ActionExecutionMessage) {
    return {
      role: "assistant",
      tool_calls: [
        {
          id: message.id,
          type: "function",
          function: {
            name: message.name,
            arguments: JSON.stringify(message.arguments),
          },
        },
      ],
    };
  } else if (message instanceof ResultMessage) {
    return {
      role: "tool",
      content: message.result,
      tool_call_id: message.actionExecutionId,
    };
  }
}

export function convertSystemMessageToAssistantAPI(message: ChatCompletionMessageParam) {
  return {
    ...message,
    ...(message.role === "system" && {
      role: "assistant",
      content: "THE FOLLOWING MESSAGE IS A SYSTEM MESSAGE: " + message.content,
    }),
  };
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/unify/unify-adapter.ts
---

/**
 * CopilotKit Adapter for Unify
 *
 * <RequestExample>
 * ```jsx CopilotRuntime Example
 * const copilotKit = new CopilotRuntime();
 * return copilotKit.response(req, new UnifyAdapter());
 * ```
 * </RequestExample>
 *
 * You can easily set the model to use by passing it to the constructor.
 * ```jsx
 * const copilotKit = new CopilotRuntime();
 * return copilotKit.response(
 *   req,
 *   new UnifyAdapter({ model: "llama-3-8b-chat@fireworks-ai" }),
 * );
 * ```
 */
import { TextMessage } from "../../graphql/types/converted";
import {
  CopilotRuntimeChatCompletionRequest,
  CopilotRuntimeChatCompletionResponse,
  CopilotServiceAdapter,
} from "../service-adapter";
import OpenAI from "openai";
import { randomId } from "@copilotkit/shared";
import { convertActionInputToOpenAITool, convertMessageToOpenAIMessage } from "../openai/utils";

export interface UnifyAdapterParams {
  apiKey?: string;
  model: string;
}

export class UnifyAdapter implements CopilotServiceAdapter {
  private apiKey: string;
  private model: string;
  private start: boolean;

  constructor(options?: UnifyAdapterParams) {
    if (options?.apiKey) {
      this.apiKey = options.apiKey;
    } else {
      this.apiKey = "UNIFY_API_KEY";
    }
    this.model = options?.model;
    this.start = true;
  }

  async process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse> {
    const tools = request.actions.map(convertActionInputToOpenAITool);
    const openai = new OpenAI({
      apiKey: this.apiKey,
      baseURL: "https://api.unify.ai/v0/",
    });

    const messages = request.messages.map(convertMessageToOpenAIMessage);

    const stream = await openai.chat.completions.create({
      model: this.model,
      messages: messages,
      stream: true,
      ...(tools.length > 0 && { tools }),
    });

    let model = null;
    request.eventSource.stream(async (eventStream$) => {
      let mode: "function" | "message" | null = null;
      for await (const chunk of stream) {
        if (this.start) {
          model = chunk.model;
          eventStream$.sendTextMessageStart(randomId());
          eventStream$.sendTextMessageContent(`Model used: ${model}\n`);
          eventStream$.sendTextMessageEnd();
          this.start = false;
        }
        const toolCall = chunk.choices[0].delta.tool_calls?.[0];
        const content = chunk.choices[0].delta.content;

        // When switching from message to function or vice versa,
        // send the respective end event.
        // If toolCall?.id is defined, it means a new tool call starts.
        if (mode === "message" && toolCall?.id) {
          mode = null;
          eventStream$.sendTextMessageEnd();
        } else if (mode === "function" && (toolCall === undefined || toolCall?.id)) {
          mode = null;
          eventStream$.sendActionExecutionEnd();
        }

        // If we send a new message type, send the appropriate start event.
        if (mode === null) {
          if (toolCall?.id) {
            mode = "function";
            eventStream$.sendActionExecutionStart(toolCall!.id, toolCall!.function!.name);
          } else if (content) {
            mode = "message";
            eventStream$.sendTextMessageStart(chunk.id);
          }
        }

        // send the content events
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent(content);
        } else if (mode === "function" && toolCall?.function?.arguments) {
          eventStream$.sendActionExecutionArgs(toolCall.function.arguments);
        }
      }

      // send the end events
      if (mode === "message") {
        eventStream$.sendTextMessageEnd();
      } else if (mode === "function") {
        eventStream$.sendActionExecutionEnd();
      }

      eventStream$.complete();
    });

    return {
      threadId: request.threadId || randomId(),
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/conversion.ts
---

import {
  ActionExecutionMessage,
  Message,
  ResultMessage,
  TextMessage,
  AgentStateMessage,
} from "../graphql/types/converted";
import { MessageInput } from "../graphql/inputs/message.input";
import { plainToInstance } from "class-transformer";

export function convertGqlInputToMessages(inputMessages: MessageInput[]): Message[] {
  const messages: Message[] = [];

  for (const message of inputMessages) {
    if (message.textMessage) {
      messages.push(
        plainToInstance(TextMessage, {
          id: message.id,
          createdAt: message.createdAt,
          role: message.textMessage.role,
          content: message.textMessage.content,
        }),
      );
    } else if (message.actionExecutionMessage) {
      messages.push(
        plainToInstance(ActionExecutionMessage, {
          id: message.id,
          createdAt: message.createdAt,
          name: message.actionExecutionMessage.name,
          arguments: JSON.parse(message.actionExecutionMessage.arguments),
          scope: message.actionExecutionMessage.scope,
        }),
      );
    } else if (message.resultMessage) {
      messages.push(
        plainToInstance(ResultMessage, {
          id: message.id,
          createdAt: message.createdAt,
          actionExecutionId: message.resultMessage.actionExecutionId,
          actionName: message.resultMessage.actionName,
          result: message.resultMessage.result,
        }),
      );
    } else if (message.agentStateMessage) {
      messages.push(
        plainToInstance(AgentStateMessage, {
          id: message.id,
          threadId: message.agentStateMessage.threadId,
          createdAt: message.createdAt,
          agentName: message.agentStateMessage.agentName,
          nodeName: message.agentStateMessage.nodeName,
          runId: message.agentStateMessage.runId,
          active: message.agentStateMessage.active,
          role: message.agentStateMessage.role,
          state: JSON.parse(message.agentStateMessage.state),
          running: message.agentStateMessage.running,
        }),
      );
    }
  }

  return messages;
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/events.ts
---

import { Action } from "@copilotkit/shared";
import {
  of,
  concat,
  map,
  scan,
  concatMap,
  ReplaySubject,
  Subject,
  firstValueFrom,
  from,
} from "rxjs";
import { streamLangChainResponse } from "./langchain/utils";
import { GuardrailsResult } from "../graphql/types/guardrails-result.type";
import telemetry from "../lib/telemetry-client";
import { isLangGraphAgentAction } from "../lib/runtime/remote-actions";
import { ActionInput } from "../graphql/inputs/action.input";

export enum RuntimeEventTypes {
  TextMessageStart = "TextMessageStart",
  TextMessageContent = "TextMessageContent",
  TextMessageEnd = "TextMessageEnd",
  ActionExecutionStart = "ActionExecutionStart",
  ActionExecutionArgs = "ActionExecutionArgs",
  ActionExecutionEnd = "ActionExecutionEnd",
  ActionExecutionResult = "ActionExecutionResult",
  AgentStateMessage = "AgentStateMessage",
}

type FunctionCallScope = "client" | "server" | "passThrough";

export type RuntimeEvent =
  | { type: RuntimeEventTypes.TextMessageStart; messageId: string }
  | {
      type: RuntimeEventTypes.TextMessageContent;
      content: string;
    }
  | { type: RuntimeEventTypes.TextMessageEnd }
  | {
      type: RuntimeEventTypes.ActionExecutionStart;
      actionExecutionId: string;
      actionName: string;
      scope?: FunctionCallScope;
    }
  | { type: RuntimeEventTypes.ActionExecutionArgs; args: string }
  | { type: RuntimeEventTypes.ActionExecutionEnd }
  | {
      type: RuntimeEventTypes.ActionExecutionResult;
      actionName: string;
      actionExecutionId: string;
      result: string;
    }
  | {
      type: RuntimeEventTypes.AgentStateMessage;
      threadId: string;
      agentName: string;
      nodeName: string;
      runId: string;
      active: boolean;
      role: string;
      state: string;
      running: boolean;
    };

interface RuntimeEventWithState {
  event: RuntimeEvent | null;
  callActionServerSide: boolean;
  action: Action<any> | null;
  actionExecutionId: string | null;
  args: string;
}

type EventSourceCallback = (eventStream$: RuntimeEventSubject) => Promise<void>;

export class RuntimeEventSubject extends ReplaySubject<RuntimeEvent> {
  constructor() {
    super();
  }

  sendTextMessageStart(messageId: string) {
    this.next({ type: RuntimeEventTypes.TextMessageStart, messageId });
  }

  sendTextMessageContent(content: string) {
    this.next({ type: RuntimeEventTypes.TextMessageContent, content });
  }

  sendTextMessageEnd() {
    this.next({ type: RuntimeEventTypes.TextMessageEnd });
  }

  sendTextMessage(messageId: string, content: string) {
    this.sendTextMessageStart(messageId);
    this.sendTextMessageContent(content);
    this.sendTextMessageEnd();
  }

  sendActionExecutionStart(actionExecutionId: string, actionName: string) {
    this.next({
      type: RuntimeEventTypes.ActionExecutionStart,
      actionExecutionId,
      actionName,
    });
  }

  sendActionExecutionArgs(args: string) {
    this.next({ type: RuntimeEventTypes.ActionExecutionArgs, args });
  }

  sendActionExecutionEnd() {
    this.next({ type: RuntimeEventTypes.ActionExecutionEnd });
  }

  sendActionExecution(actionExecutionId: string, toolName: string, args: string) {
    this.sendActionExecutionStart(actionExecutionId, toolName);
    this.sendActionExecutionArgs(args);
    this.sendActionExecutionEnd();
  }

  sendActionExecutionResult(actionExecutionId: string, actionName: string, result: string) {
    this.next({
      type: RuntimeEventTypes.ActionExecutionResult,
      actionName,
      actionExecutionId,
      result,
    });
  }

  sendAgentStateMessage(
    threadId: string,
    agentName: string,
    nodeName: string,
    runId: string,
    active: boolean,
    role: string,
    state: string,
    running: boolean,
  ) {
    this.next({
      type: RuntimeEventTypes.AgentStateMessage,
      threadId,
      agentName,
      nodeName,
      runId,
      active,
      role,
      state,
      running,
    });
  }
}

export class RuntimeEventSource {
  private eventStream$ = new RuntimeEventSubject();
  private callback!: EventSourceCallback;

  async stream(callback: EventSourceCallback): Promise<void> {
    this.callback = callback;
  }

  processRuntimeEvents({
    serverSideActions,
    guardrailsResult$,
    actionInputsWithoutAgents,
  }: {
    serverSideActions: Action<any>[];
    guardrailsResult$?: Subject<GuardrailsResult>;
    actionInputsWithoutAgents: ActionInput[];
  }) {
    this.callback(this.eventStream$).catch((error) => {
      console.error("Error in event source callback", error);
    });
    return this.eventStream$.pipe(
      // mark tools for server side execution
      map((event) => {
        if (event.type === RuntimeEventTypes.ActionExecutionStart) {
          if (event.scope !== "passThrough") {
            event.scope = serverSideActions.find((action) => action.name === event.actionName)
              ? "server"
              : "client";
          }
        }
        return event;
      }),
      // track state
      scan(
        (acc, event) => {
          // It seems like this is needed so that rxjs recognizes the object has changed
          // This fixes an issue where action were executed multiple times
          // Not investigating further for now (Markus)
          acc = { ...acc };

          if (event.type === RuntimeEventTypes.ActionExecutionStart) {
            acc.callActionServerSide = event.scope === "server";
            acc.args = "";
            acc.actionExecutionId = event.actionExecutionId;
            if (acc.callActionServerSide) {
              acc.action = serverSideActions.find((action) => action.name === event.actionName);
            }
          } else if (event.type === RuntimeEventTypes.ActionExecutionArgs) {
            acc.args += event.args;
          }

          acc.event = event;

          return acc;
        },
        {
          event: null,
          callActionServerSide: false,
          args: "",
          actionExecutionId: null,
          action: null,
        } as RuntimeEventWithState,
      ),
      concatMap((eventWithState) => {
        if (
          eventWithState.event!.type === RuntimeEventTypes.ActionExecutionEnd &&
          eventWithState.callActionServerSide
        ) {
          const toolCallEventStream$ = new RuntimeEventSubject();
          executeAction(
            toolCallEventStream$,
            guardrailsResult$ ? guardrailsResult$ : null,
            eventWithState.action!,
            eventWithState.args,
            eventWithState.actionExecutionId,
            actionInputsWithoutAgents,
          ).catch((error) => {
            console.error(error);
          });

          telemetry.capture("oss.runtime.server_action_executed", {});
          return concat(of(eventWithState.event!), toolCallEventStream$);
        } else {
          return of(eventWithState.event!);
        }
      }),
    );
  }
}

async function executeAction(
  eventStream$: RuntimeEventSubject,
  guardrailsResult$: Subject<GuardrailsResult> | null,
  action: Action<any>,
  actionArguments: string,
  actionExecutionId: string,
  actionInputsWithoutAgents: ActionInput[],
) {
  if (guardrailsResult$) {
    const { status } = await firstValueFrom(guardrailsResult$);

    if (status === "denied") {
      eventStream$.complete();
      return;
    }
  }

  // Prepare arguments for function calling
  let args: Record<string, any>[] = [];
  if (actionArguments) {
    args = JSON.parse(actionArguments);
  }

  // handle LangGraph agents
  if (isLangGraphAgentAction(action)) {
    eventStream$.sendActionExecutionResult(
      actionExecutionId,
      action.name,
      `${action.name} agent started`,
    );
    const stream = await action.langGraphAgentHandler({
      name: action.name,
      actionInputsWithoutAgents,
    });

    // forward to eventStream$
    from(stream).subscribe({
      next: (event) => eventStream$.next(event),
      error: (err) => console.error("Error in stream", err),
      complete: () => eventStream$.complete(),
    });
  } else {
    // call the function
    const result = await action.handler?.(args);

    await streamLangChainResponse({
      result,
      eventStream$,
      actionExecution: {
        name: action.name,
        id: actionExecutionId,
      },
    });
  }
}



---
File: /CopilotKit/packages/runtime/src/service-adapters/index.ts
---

export type { CopilotServiceAdapter } from "./service-adapter";
export type { RemoteChainParameters } from "./langchain/langserve";
export { RemoteChain } from "./langchain/langserve";
export * from "./openai/openai-adapter";
export * from "./langchain/langchain-adapter";
export * from "./google/google-genai-adapter";
export * from "./openai/openai-assistant-adapter";
export * from "./unify/unify-adapter";
export * from "./groq/groq-adapter";
export * from "./anthropic/anthropic-adapter";



---
File: /CopilotKit/packages/runtime/src/service-adapters/service-adapter.ts
---

import { Message } from "../graphql/types/converted";
import { RuntimeEventSource } from "./events";
import { ActionInput } from "../graphql/inputs/action.input";
import { ForwardedParametersInput } from "../graphql/inputs/forwarded-parameters.input";

export interface CopilotKitResponse {
  stream: ReadableStream;
  headers?: Record<string, string>;
}

export interface CopilotRuntimeChatCompletionRequest {
  eventSource: RuntimeEventSource;
  messages: Message[];
  actions: ActionInput[];
  model?: string;
  threadId?: string;
  runId?: string;
  forwardedParameters?: ForwardedParametersInput;
}

export interface CopilotRuntimeChatCompletionResponse {
  threadId: string;
  runId?: string;
}

export interface CopilotServiceAdapter {
  process(
    request: CopilotRuntimeChatCompletionRequest,
  ): Promise<CopilotRuntimeChatCompletionResponse>;
}



---
File: /CopilotKit/packages/runtime/src/utils/failed-response-status-reasons.ts
---

import {
  FailedResponseStatus,
  FailedResponseStatusReason,
} from "../graphql/types/response-status.type";

export class GuardrailsValidationFailureResponse extends FailedResponseStatus {
  reason = FailedResponseStatusReason.GUARDRAILS_VALIDATION_FAILED;
  declare details: {
    guardrailsReason: string;
  };

  constructor({ guardrailsReason }) {
    super();
    this.details = {
      guardrailsReason,
    };
  }
}

export class MessageStreamInterruptedResponse extends FailedResponseStatus {
  reason = FailedResponseStatusReason.MESSAGE_STREAM_INTERRUPTED;
  declare details: {
    messageId: string;
    description: string;
  };

  constructor({ messageId }: { messageId: string }) {
    super();
    this.details = {
      messageId,
      description: "Check the message for mode details",
    };
  }
}

export class UnknownErrorResponse extends FailedResponseStatus {
  reason = FailedResponseStatusReason.UNKNOWN_ERROR;
  declare details: {
    description?: string;
  };

  constructor({ description }: { description?: string }) {
    super();
    this.details = {
      description,
    };
  }
}



---
File: /CopilotKit/packages/runtime/src/utils/index.ts
---

export * from "./failed-response-status-reasons";



---
File: /CopilotKit/packages/runtime/src/index.ts
---

import "reflect-metadata";
export * from "./lib";
export * from "./utils";
export * from "./service-adapters";



---
File: /CopilotKit/packages/runtime/.eslintrc.js
---

module.exports = {
  rules: {
    'react-hooks/rules-of-hooks': 'off', // Disables React hooks rules
    'react-hooks/exhaustive-deps': 'off', // Disables checking of dependency arrays
    'turbo/no-undeclared-env-vars': 'off'
  }
};



---
File: /CopilotKit/packages/runtime/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/runtime/tsup.config.ts
---

import { defineConfig, Options } from "tsup";

export default defineConfig((options: Options) => ({
  ...options,
  entry: ["src/**/index.ts"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: [],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
}));



---
File: /CopilotKit/packages/runtime-client-gql/src/client/conversion.ts
---

import {
  GenerateCopilotResponseMutation,
  MessageInput,
  MessageStatusCode,
} from "../graphql/@generated/graphql";
import {
  ActionExecutionMessage,
  AgentStateMessage,
  Message,
  ResultMessage,
  TextMessage,
} from "./types";

import untruncateJson from "untruncate-json";

export function filterAgentStateMessages(messages: Message[]): Message[] {
  return messages.filter((message) => !(message instanceof AgentStateMessage));
}

export function convertMessagesToGqlInput(messages: Message[]): MessageInput[] {
  return messages.map((message) => {
    if (message instanceof TextMessage) {
      return {
        id: message.id,
        createdAt: message.createdAt,
        textMessage: {
          content: message.content,
          role: message.role as any,
        },
      };
    } else if (message instanceof ActionExecutionMessage) {
      return {
        id: message.id,
        createdAt: message.createdAt,
        actionExecutionMessage: {
          name: message.name,
          arguments: JSON.stringify(message.arguments),
          scope: message.scope as any,
        },
      };
    } else if (message instanceof ResultMessage) {
      return {
        id: message.id,
        createdAt: message.createdAt,
        resultMessage: {
          result: message.result,
          actionExecutionId: message.actionExecutionId,
          actionName: message.actionName,
        },
      };
    } else if (message instanceof AgentStateMessage) {
      return {
        id: message.id,
        createdAt: message.createdAt,
        agentStateMessage: {
          threadId: message.threadId,
          role: message.role,
          agentName: message.agentName,
          nodeName: message.nodeName,
          runId: message.runId,
          active: message.active,
          running: message.running,
          state: JSON.stringify(message.state),
        },
      };
    } else {
      throw new Error("Unknown message type");
    }
  });
}

export function filterAdjacentAgentStateMessages(
  messages: GenerateCopilotResponseMutation["generateCopilotResponse"]["messages"],
): GenerateCopilotResponseMutation["generateCopilotResponse"]["messages"] {
  const filteredMessages: GenerateCopilotResponseMutation["generateCopilotResponse"]["messages"] =
    [];

  messages.forEach((message, i) => {
    // keep all other message types
    if (message.__typename !== "AgentStateMessageOutput" || i === messages.length - 1) {
      filteredMessages.push(message);
    } else {
      const nextMessage = messages[i + 1];
      if (
        !(
          (
            nextMessage.__typename === "AgentStateMessageOutput" &&
            nextMessage.agentName === message.agentName &&
            nextMessage.nodeName === message.nodeName
          )
          // not grouping by runId for now
          // && nextMessage.runId === message.runId
        )
      ) {
        filteredMessages.push(message);
      }
    }
  });

  return filteredMessages;
}

export function convertGqlOutputToMessages(
  messages: GenerateCopilotResponseMutation["generateCopilotResponse"]["messages"],
): Message[] {
  return messages.map((message) => {
    if (message.__typename === "TextMessageOutput") {
      return new TextMessage({
        id: message.id,
        role: message.role,
        content: message.content.join(""),
        createdAt: new Date(),
        status: message.status || { code: MessageStatusCode.Pending },
      });
    } else if (message.__typename === "ActionExecutionMessageOutput") {
      return new ActionExecutionMessage({
        id: message.id,
        name: message.name,
        arguments: getPartialArguments(message.arguments),
        scope: message.scope,
        createdAt: new Date(),
        status: message.status || { code: MessageStatusCode.Pending },
      });
    } else if (message.__typename === "ResultMessageOutput") {
      return new ResultMessage({
        id: message.id,
        result: message.result,
        actionExecutionId: message.actionExecutionId,
        actionName: message.actionName,
        createdAt: new Date(),
        status: message.status || { code: MessageStatusCode.Pending },
      });
    } else if (message.__typename === "AgentStateMessageOutput") {
      return new AgentStateMessage({
        id: message.id,
        threadId: message.threadId,
        role: message.role,
        agentName: message.agentName,
        nodeName: message.nodeName,
        runId: message.runId,
        active: message.active,
        running: message.running,
        state: JSON.parse(message.state),
        createdAt: new Date(),
      });
    }

    throw new Error("Unknown message type");
  });
}

function getPartialArguments(args: string[]) {
  try {
    return JSON.parse(untruncateJson(args.join("")));
  } catch (e) {
    return {};
  }
}



---
File: /CopilotKit/packages/runtime-client-gql/src/client/CopilotRuntimeClient.ts
---

import { Client, cacheExchange, fetchExchange } from "@urql/core";
import * as packageJson from "../../package.json";

import {
  GenerateCopilotResponseMutation,
  GenerateCopilotResponseMutationVariables,
} from "../graphql/@generated/graphql";
import { generateCopilotResponseMutation } from "../graphql/definitions/mutations";
import { OperationResultSource, OperationResult } from "urql";

interface CopilotRuntimeClientOptions {
  url: string;
  publicApiKey?: string;
  headers?: Record<string, string>;
  credentials?: RequestCredentials;
}

export class CopilotRuntimeClient {
  client: Client;

  constructor(options: CopilotRuntimeClientOptions) {
    const headers: Record<string, string> = {};

    if (options.headers) {
      Object.assign(headers, options.headers);
    }

    if (options.publicApiKey) {
      headers["x-copilotcloud-public-api-key"] = options.publicApiKey;
    }

    this.client = new Client({
      url: options.url,
      exchanges: [cacheExchange, fetchExchange],
      fetchOptions: {
        headers: {
          ...headers,
          "X-CopilotKit-Runtime-Client-GQL-Version": packageJson.version,
        },
        ...(options.credentials ? { credentials: options.credentials } : {}),
      },
    });
  }

  generateCopilotResponse({
    data,
    properties,
    signal,
  }: {
    data: GenerateCopilotResponseMutationVariables["data"];
    properties?: GenerateCopilotResponseMutationVariables["properties"];
    signal?: AbortSignal;
  }) {
    const result = this.client.mutation<
      GenerateCopilotResponseMutation,
      GenerateCopilotResponseMutationVariables
    >(
      generateCopilotResponseMutation,
      { data, properties },
      { fetch: (url, opts) => fetch(url, { ...opts, signal }) },
    );

    return result;
  }

  static asStream<S, T>(source: OperationResultSource<OperationResult<S, { data: T }>>) {
    return new ReadableStream<S>({
      start(controller) {
        source.subscribe(({ data, hasNext }) => {
          controller.enqueue(data);
          if (!hasNext) {
            controller.close();
          }
        });
      },
    });
  }
}



---
File: /CopilotKit/packages/runtime-client-gql/src/client/index.ts
---

export * from "./CopilotRuntimeClient";
export {
  convertMessagesToGqlInput,
  convertGqlOutputToMessages,
  filterAdjacentAgentStateMessages,
  filterAgentStateMessages,
} from "./conversion";
export * from "./types";



---
File: /CopilotKit/packages/runtime-client-gql/src/client/types.ts
---

import { randomId } from "@copilotkit/shared";
import {
  ActionExecutionMessageInput,
  MessageRole,
  MessageStatus,
  ResultMessageInput,
  TextMessageInput,
  BaseMessageOutput,
  AgentStateMessageInput,
  MessageStatusCode,
} from "../graphql/@generated/graphql";

export class Message {
  id: BaseMessageOutput["id"];
  createdAt: BaseMessageOutput["createdAt"];
  status: MessageStatus;

  constructor(props: any) {
    props.id ??= randomId();
    props.status ??= { code: MessageStatusCode.Success };
    props.createdAt ??= new Date();
    Object.assign(this, props);
  }
}

// alias Role to MessageRole
export const Role = MessageRole;

// when constructing any message, the base fields are optional
type MessageConstructorOptions = Partial<Message>;

type TextMessageConstructorOptions = MessageConstructorOptions & TextMessageInput;

export class TextMessage extends Message implements TextMessageConstructorOptions {
  role: TextMessageInput["role"];
  content: TextMessageInput["content"];

  constructor(props: TextMessageConstructorOptions) {
    super(props);
  }
}

type ActionExecutionMessageConstructorOptions = MessageConstructorOptions &
  Omit<ActionExecutionMessageInput, "arguments"> & {
    arguments: Record<string, any>;
  };

export class ActionExecutionMessage
  extends Message
  implements Omit<ActionExecutionMessageInput, "arguments">
{
  name: ActionExecutionMessageInput["name"];
  arguments: Record<string, any>;
  scope: ActionExecutionMessageInput["scope"];

  constructor(props: ActionExecutionMessageConstructorOptions) {
    super(props);
  }
}

type ResultMessageConstructorOptions = MessageConstructorOptions & ResultMessageInput;

export class ResultMessage extends Message implements ResultMessageConstructorOptions {
  actionExecutionId: ResultMessageInput["actionExecutionId"];
  actionName: ResultMessageInput["actionName"];
  result: ResultMessageInput["result"];

  constructor(props: ResultMessageConstructorOptions) {
    super(props);
  }

  static decodeResult(result: string): any {
    try {
      return JSON.parse(result);
    } catch (e) {
      return result;
    }
  }

  static encodeResult(result: any): string {
    if (result === undefined) {
      return "";
    } else if (typeof result === "string") {
      return result;
    } else {
      return JSON.stringify(result);
    }
  }
}

export class AgentStateMessage extends Message implements Omit<AgentStateMessageInput, "state"> {
  agentName: AgentStateMessageInput["agentName"];
  state: any;
  running: AgentStateMessageInput["running"];
  threadId: AgentStateMessageInput["threadId"];
  role: AgentStateMessageInput["role"];
  nodeName: AgentStateMessageInput["nodeName"];
  runId: AgentStateMessageInput["runId"];
  active: AgentStateMessageInput["active"];
}



---
File: /CopilotKit/packages/runtime-client-gql/src/graphql/definitions/mutations.ts
---

import { graphql } from "../@generated/gql";

export const generateCopilotResponseMutation = graphql(/** GraphQL **/ `
  mutation generateCopilotResponse($data: GenerateCopilotResponseInput!, $properties: JSONObject) {
    generateCopilotResponse(data: $data, properties: $properties) {
      threadId
      runId
      ... on CopilotResponse @defer {
        status {
          ... on BaseResponseStatus {
            code
          }
          ... on FailedResponseStatus {
            reason
            details
          }
        }
      }
      messages @stream {
        __typename
        ... on BaseMessageOutput {
          id
          createdAt
        }
        ... on BaseMessageOutput @defer {
          status {
            ... on SuccessMessageStatus {
              code
            }
            ... on FailedMessageStatus {
              code
              reason
            }
            ... on PendingMessageStatus {
              code
            }
          }
        }
        ... on TextMessageOutput {
          content @stream
          role
        }
        ... on ActionExecutionMessageOutput {
          name
          scope
          arguments @stream
        }
        ... on ResultMessageOutput {
          result
          actionExecutionId
          actionName
        }
        ... on AgentStateMessageOutput {
          threadId
          state
          running
          agentName
          nodeName
          runId
          active
          role
        }
      }
    }
  }
`);



---
File: /CopilotKit/packages/runtime-client-gql/src/index.ts
---

export * from "./client";
export * from "./graphql/@generated/graphql";



---
File: /CopilotKit/packages/runtime-client-gql/codegen.ts
---

import type { CodegenConfig } from "@graphql-codegen/cli";
import path from "node:path";

const schema = path.resolve(__dirname, "../runtime/__snapshots__/schema/schema.graphql");

const config: CodegenConfig = {
  schema,
  documents: ["src/graphql/definitions/**/*.{ts,tsx}"],
  generates: {
    "./src/graphql/@generated/": {
      preset: "client",
      config: {
        useTypeImports: true,
        withHooks: false,
      },
      plugins: [],
    },
  },
  hooks: {},
};

export default config;



---
File: /CopilotKit/packages/runtime-client-gql/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/runtime-client-gql/tsup.config.ts
---

import { defineConfig, Options } from "tsup";
import { Plugin } from "esbuild";
import { generate } from "@graphql-codegen/cli";
import codegenConfig from "./codegen";

const runBeforeBuildPlugin: Plugin = {
  name: "run-before-build",
  setup(build) {
    const prefix = build.initialOptions.format;

    build.onStart(async () => {
      console.log(`[${prefix}] Running graphql-codegen`);
      await generate(codegenConfig);
      console.log(`[${prefix}] graphql-codegen completed successfully`);
    });
  },
};

export default defineConfig((options: Options) => ({
  entry: ["src/**/*.{ts,tsx}"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: ["react"],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
  esbuildPlugins: [runBeforeBuildPlugin as any],
  ...options,
}));



---
File: /CopilotKit/packages/shared/src/constants/index.ts
---

export const COPILOT_CLOUD_API_URL = "https://api.copilotkit.ai";
export const COPILOT_CLOUD_VERSION = "v1";
export const COPILOT_CLOUD_CHAT_URL = `${COPILOT_CLOUD_API_URL}/copilotkit/${COPILOT_CLOUD_VERSION}`;
export const COPILOT_CLOUD_PUBLIC_API_KEY_HEADER = "X-CopilotCloud-Public-Api-Key";



---
File: /CopilotKit/packages/shared/src/telemetry/events.ts
---

export type AnalyticsEvents = {
  "oss.runtime.instance_created": {};
  "oss.runtime.copilot_request_created": {
    "cloud.guardrails.enabled": boolean;
    requestType: string;
  };
  "oss.runtime.server_action_executed": {};
  "oss.runtime.remote_action_executed": {};
};



---
File: /CopilotKit/packages/shared/src/telemetry/index.ts
---

export * from "./telemetry-client";



---
File: /CopilotKit/packages/shared/src/telemetry/security-check.ts
---




---
File: /CopilotKit/packages/shared/src/telemetry/telemetry-client.ts
---

import { Analytics } from "@segment/analytics-node";
import { AnalyticsEvents } from "./events";
import { flattenObject, printSecurityNotice } from "./utils";
import { randomUUID } from "crypto";

export class TelemetryClient {
  segment: Analytics | undefined;
  globalProperties: Record<string, any> = {};
  cloudConfiguration: { publicApiKey: string; baseUrl: string } | null = null;
  packageName: string;
  packageVersion: string;
  private telemetryDisabled: boolean = false;
  private sampleRate: number = 0.05;
  private anonymousId = `anon_${randomUUID()}`;

  constructor({
    packageName,
    packageVersion,
    telemetryDisabled,
    telemetryBaseUrl,
    sampleRate,
  }: {
    packageName: string;
    packageVersion: string;
    telemetryDisabled?: boolean;
    telemetryBaseUrl?: string;
    sampleRate?: number;
  }) {
    this.packageName = packageName;
    this.packageVersion = packageVersion;
    this.telemetryDisabled =
      telemetryDisabled ||
      (process.env as any).COPILOTKIT_TELEMETRY_DISABLED === "true" ||
      (process.env as any).COPILOTKIT_TELEMETRY_DISABLED === "1" ||
      (process.env as any).DO_NOT_TRACK === "true" ||
      (process.env as any).DO_NOT_TRACK === "1";

    if (this.telemetryDisabled) {
      return;
    }

    this.setSampleRate(sampleRate);

    // eslint-disable-next-line
    const writeKey = process.env.COPILOTKIT_SEGMENT_WRITE_KEY || "n7XAZtQCGS2v1vvBy3LgBCv2h3Y8whja";

    this.segment = new Analytics({
      writeKey,
    });

    this.setGlobalProperties({
      "copilotkit.package.name": packageName,
      "copilotkit.package.version": packageVersion,
    });
  }

  private shouldSendEvent() {
    const randomNumber = Math.random();
    return randomNumber < this.sampleRate;
  }

  async capture<K extends keyof AnalyticsEvents>(event: K, properties: AnalyticsEvents[K]) {
    if (!this.shouldSendEvent() || !this.segment) {
      return;
    }

    const flattenedProperties = flattenObject(properties);
    const propertiesWithGlobal = {
      ...this.globalProperties,
      ...flattenedProperties,
    };
    const orderedPropertiesWithGlobal = Object.keys(propertiesWithGlobal)
      .sort()
      .reduce(
        (obj, key) => {
          obj[key] = propertiesWithGlobal[key];
          return obj;
        },
        {} as Record<string, any>,
      );

    this.segment.track({
      anonymousId: this.anonymousId,
      event,
      properties: { ...orderedPropertiesWithGlobal },
    });
  }

  setGlobalProperties(properties: Record<string, any>) {
    const flattenedProperties = flattenObject(properties);
    this.globalProperties = { ...this.globalProperties, ...flattenedProperties };
  }

  setCloudConfiguration(properties: { publicApiKey: string; baseUrl: string }) {
    this.cloudConfiguration = properties;

    this.setGlobalProperties({
      cloud: {
        publicApiKey: properties.publicApiKey,
        baseUrl: properties.baseUrl,
      },
    });
  }

  private setSampleRate(sampleRate: number | undefined) {
    let _sampleRate: number;

    _sampleRate = sampleRate ?? 0.05;

    // eslint-disable-next-line
    if (process.env.COPILOTKIT_TELEMETRY_SAMPLE_RATE) {
      // eslint-disable-next-line
      _sampleRate = parseFloat(process.env.COPILOTKIT_TELEMETRY_SAMPLE_RATE);
    }

    if (_sampleRate < 0 || _sampleRate > 1) {
      throw new Error("Sample rate must be between 0 and 1");
    }

    this.sampleRate = _sampleRate;
    this.setGlobalProperties({
      sampleRate: this.sampleRate,
      sampleRateAdjustmentFactor: 1 - this.sampleRate,
    });
  }
}



---
File: /CopilotKit/packages/shared/src/telemetry/utils.ts
---

import chalk from "chalk";

export function flattenObject(
  obj: Record<string, any>,
  parentKey = "",
  res: Record<string, any> = {},
): Record<string, any> {
  for (let key in obj) {
    const propName = parentKey ? `${parentKey}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      flattenObject(obj[key], propName, res);
    } else {
      res[propName] = obj[key];
    }
  }
  return res;
}

export function printSecurityNotice(advisory: {
  advisory: string | null;
  message: string;
  severity: "low" | "medium" | "high" | "none";
}) {
  const severityColor =
    {
      low: chalk.blue,
      medium: chalk.yellow,
      high: chalk.red,
    }[advisory.severity.toLowerCase()] || chalk.white;

  console.log();
  console.log(`━━━━━━━━━━━━━━━━━━ ${chalk.bold(`CopilotKit`)} ━━━━━━━━━━━━━━━━━━`);
  console.log();
  console.log(`${chalk.bold(`Severity: ${severityColor(advisory.severity.toUpperCase())}`)}`);
  console.log();
  console.log(`${chalk.bold(advisory.message)}`);
  console.log();
  console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
}



---
File: /CopilotKit/packages/shared/src/types/action.ts
---

type TypeMap = {
  string: string;
  number: number;
  boolean: boolean;
  object: object;
  "string[]": string[];
  "number[]": number[];
  "boolean[]": boolean[];
  "object[]": object[];
};

type AbstractParameter = {
  name: string;
  type?: keyof TypeMap;
  description?: string;
  required?: boolean;
};

interface StringParameter extends AbstractParameter {
  type: "string";
  enum?: string[];
}

interface ObjectParameter extends AbstractParameter {
  type: "object";
  attributes?: Parameter[];
}

interface ObjectArrayParameter extends AbstractParameter {
  type: "object[]";
  attributes?: Parameter[];
}

type SpecialParameters = StringParameter | ObjectParameter | ObjectArrayParameter;
interface BaseParameter extends AbstractParameter {
  type?: Exclude<AbstractParameter["type"], SpecialParameters["type"]>;
}

export type Parameter = BaseParameter | SpecialParameters;

type OptionalParameterType<P extends AbstractParameter> = P["required"] extends false
  ? undefined
  : never;

type StringParameterType<P> = P extends StringParameter
  ? P extends { enum?: Array<infer E> }
    ? E
    : string
  : never;

type ObjectParameterType<P> = P extends ObjectParameter
  ? P extends { attributes?: infer Attributes extends Parameter[] }
    ? MappedParameterTypes<Attributes>
    : object
  : never;

type ObjectArrayParameterType<P> = P extends ObjectArrayParameter
  ? P extends { attributes?: infer Attributes extends Parameter[] }
    ? MappedParameterTypes<Attributes>[]
    : any[]
  : never;

type MappedTypeOrString<T> = T extends keyof TypeMap ? TypeMap[T] : string;
type BaseParameterType<P extends AbstractParameter> = P extends { type: infer T }
  ? T extends BaseParameter["type"]
    ? MappedTypeOrString<T>
    : never
  : string;

export type MappedParameterTypes<T extends Parameter[] | [] = []> = T extends []
  ? Record<string, any>
  : {
      [P in T[number] as P["name"]]:
        | OptionalParameterType<P>
        | StringParameterType<P>
        | ObjectParameterType<P>
        | ObjectArrayParameterType<P>
        | BaseParameterType<P>;
    };

export type Action<T extends Parameter[] | [] = []> = {
  name: string;
  description?: string;
  parameters?: T;
  handler?: T extends []
    ? () => any | Promise<any>
    : (args: MappedParameterTypes<T>) => any | Promise<any>;
};

// This is the original "ceiling is being raised" version of MappedParameterTypes.
//
// ceiling is being raised. cursor's copilot helped us write "superhuman code"
// for a critical feature. We can read this code, but VERY few engineers out
// there could write it from scratch.
// Took lots of convincing too. "come on, this must be possible, try harder".
// and obviously- done in parts.
//
// - https://twitter.com/ataiiam/status/1765089261374914957
//   (Mar 5, 2024)
//
// export type MappedParameterTypes<T extends Parameter[]> = {
//   // Check if the parameter has an 'enum' defined
//   [P in T[number] as P["name"]]: P extends { enum: Array<infer E> }
//     ? E extends string // Ensure the enum values are strings
//       ? P["required"] extends false // Check if the parameter is optional
//         ? E | undefined // If so, include 'undefined' in the type
//         : E // Otherwise, use the enum type directly
//       : never // This case should not occur since 'enum' implies string values
//     : // Handle parameters defined as 'object' with specified attributes
//     P extends { type: "object"; attributes: infer Attributes }
//     ? Attributes extends Parameter[]
//       ? MappedParameterTypes<Attributes> // Recursively map the attributes of the object
//       : never // If 'attributes' is not an array of Parameters, this is invalid
//     : // Handle parameters defined as 'object[]' without specified attributes
//     P extends { type: "object[]"; attributes?: never }
//     ? any[] // Default to 'any[]' for arrays of objects without specific attributes
//     : // Handle parameters defined as 'object[]' with specified attributes
//     P extends { type: "object[]"; attributes: infer Attributes }
//     ? Attributes extends Parameter[]
//       ? MappedParameterTypes<Attributes>[] // Recursively map each object in the array
//       : any[] // Default to 'any[]' if attributes are not properly defined
//     : // Handle all other parameter types
//     P["required"] extends false
//     ? // Include 'undefined' for optional parameters
//       TypeMap[P["type"] extends keyof TypeMap ? P["type"] : "string"] | undefined
//     : // Use the direct mapping from 'TypeMap' for the parameter's type
//       TypeMap[P["type"] extends keyof TypeMap ? P["type"] : "string"];
// };



---
File: /CopilotKit/packages/shared/src/types/copilot-cloud-config.ts
---

export interface CopilotCloudConfig {
  guardrails: {
    input: {
      restrictToTopic: {
        enabled: boolean;
        validTopics: string[];
        invalidTopics: string[];
      };
    };
  };
}



---
File: /CopilotKit/packages/shared/src/types/index.ts
---

export * from "./openai-assistant";
export * from "./action";
export * from "./copilot-cloud-config";



---
File: /CopilotKit/packages/shared/src/types/openai-assistant.ts
---

export interface FunctionDefinition {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain
   * underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the
   * [guide](/docs/guides/gpt/function-calling) for examples, and the
   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
   * documentation about the format.
   *
   * To describe a function that accepts no parameters, provide the value
   * `{"type": "object", "properties": {}}`.
   */
  parameters: Record<string, unknown>;
  /**
   * A description of what the function does, used by the model to choose when and
   * how to call the function.
   */
  description?: string;
}

export interface ToolDefinition {
  type: "function";
  function: FunctionDefinition;
}

export interface FunctionCallHandlerArguments {
  messages: any[];
  name: string;
  args: any;
}

export type FunctionCallHandler = (args: FunctionCallHandlerArguments) => Promise<any>;

export type CoagentActionHandlerArguments = {
  name: string;
  nodeName: string;
  state: any;
};

export type CoagentActionHandler = (args: CoagentActionHandlerArguments) => Promise<any>;

export type AssistantMessage = {
  id: string;
  role: "assistant";
  content: Array<{
    type: "text";
    text: {
      value: string;
    };
  }>;
};

export type JSONValue =
  | null
  | string
  | number
  | boolean
  | { [x: string]: JSONValue }
  | Array<JSONValue>;



---
File: /CopilotKit/packages/shared/src/utils/index.ts
---

export * from "./json-schema";
export * from "./random-id";



---
File: /CopilotKit/packages/shared/src/utils/json-schema.ts
---

import { Parameter } from "../types";

export type JSONSchemaString = {
  type: "string";
  description?: string;
  enum?: string[];
};

export type JSONSchemaNumber = {
  type: "number";
  description?: string;
};

export type JSONSchemaBoolean = {
  type: "boolean";
  description?: string;
};

export type JSONSchemaObject = {
  type: "object";
  properties?: Record<string, JSONSchema>;
  required?: string[];
  description?: string;
};

export type JSONSchemaArray = {
  type: "array";
  items: JSONSchema;
  description?: string;
};

export type JSONSchema =
  | JSONSchemaString
  | JSONSchemaNumber
  | JSONSchemaBoolean
  | JSONSchemaObject
  | JSONSchemaArray;

export function actionParametersToJsonSchema(actionParameters: Parameter[]): JSONSchema {
  // Create the parameters object based on the argumentAnnotations
  let parameters: { [key: string]: any } = {};
  for (let parameter of actionParameters || []) {
    parameters[parameter.name] = convertAttribute(parameter);
  }

  let requiredParameterNames: string[] = [];
  for (let arg of actionParameters || []) {
    if (arg.required !== false) {
      requiredParameterNames.push(arg.name);
    }
  }

  // Create the ChatCompletionFunctions object
  return {
    type: "object",
    properties: parameters,
    required: requiredParameterNames,
  };
}

function convertAttribute(attribute: Parameter): JSONSchema {
  switch (attribute.type) {
    case "string":
      return {
        type: "string",
        description: attribute.description,
        ...(attribute.enum && { enum: attribute.enum }),
      };
    case "number":
    case "boolean":
      return {
        type: attribute.type,
        description: attribute.description,
      };
    case "object":
    case "object[]":
      const properties = attribute.attributes?.reduce(
        (acc, attr) => {
          acc[attr.name] = convertAttribute(attr);
          return acc;
        },
        {} as Record<string, any>,
      );
      const required = attribute.attributes
        ?.filter((attr) => attr.required !== false)
        .map((attr) => attr.name);
      if (attribute.type === "object[]") {
        return {
          type: "array",
          items: {
            type: "object",
            ...(properties && { properties }),
            ...(required && required.length > 0 && { required }),
          },
          description: attribute.description,
        };
      }
      return {
        type: "object",
        description: attribute.description,
        ...(properties && { properties }),
        ...(required && required.length > 0 && { required }),
      };
    default:
      // Handle arrays of primitive types and undefined attribute.type
      if (attribute.type?.endsWith("[]")) {
        const itemType = attribute.type.slice(0, -2);
        return {
          type: "array",
          items: { type: itemType as any },
          description: attribute.description,
        };
      }
      // Fallback for undefined type or any other unexpected type
      return {
        type: "string",
        description: attribute.description,
      };
  }
}



---
File: /CopilotKit/packages/shared/src/utils/random-id.ts
---

import { v4 as uuidv4 } from "uuid";

export function randomId() {
  return "ck-" + uuidv4();
}



---
File: /CopilotKit/packages/shared/src/index.ts
---

export * from "./types";
export * from "./utils";
export * from "./constants";
export * from "./telemetry";

import * as packageJson from "../package.json";
export const COPILOTKIT_VERSION = packageJson.version;



---
File: /CopilotKit/packages/shared/jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


---
File: /CopilotKit/packages/shared/tsup.config.ts
---

import { defineConfig, Options } from "tsup";

export default defineConfig((options: Options) => ({
  entry: ["src/**/*.{ts,tsx}"],
  format: ["esm", "cjs"],
  dts: true,
  minify: false,
  external: [],
  sourcemap: true,
  exclude: [
    "**/*.test.ts", // Exclude TypeScript test files
    "**/*.test.tsx", // Exclude TypeScript React test files
    "**/__tests__/*", // Exclude any files inside a __tests__ directory
  ],
  ...options,
}));



---
File: /CopilotKit/scripts/docs/lib/comments.ts
---

import * as ts from "typescript";

export class Comments {
  static getCleanedCommentsForNode(node: ts.Node, sourceFile: ts.SourceFile): string {
    const fullText = sourceFile.getFullText();
    const commentRanges = ts.getLeadingCommentRanges(fullText, node.getFullStart());

    if (!commentRanges) return "";

    return commentRanges
      .map((comment) => {
        let commentText = fullText.substring(comment.pos, comment.end);
        commentText = Comments.removeCommentSyntax(commentText);

        // for now, remove @default annotations
        commentText = commentText
          .split("\n")
          .filter((line) => !line.includes("@default"))
          .join("\n");

        return commentText;
      })
      .join("\n")
      .trim();
  }

  static getDefaultValueForNode(node: ts.Node, sourceFile: ts.SourceFile): string | undefined {
    const fullText = sourceFile.getFullText();
    const commentRanges = ts.getLeadingCommentRanges(fullText, node.getFullStart());

    if (!commentRanges) return "";
    let defaultValue: string | undefined = undefined;

    for (const comment of commentRanges) {
      let commentText = fullText.substring(comment.pos, comment.end);
      commentText = Comments.removeCommentSyntax(commentText);

      for (const line of commentText.split("\n")) {
        if (line.includes("@default")) {
          defaultValue = line.split("@default")[1].trim();
          break;
        }
      }

      if (defaultValue !== undefined) break;
    }

    return defaultValue;
  }

  static removeCommentSyntax(commentText: string): string {
    return commentText
      .replace(/\/\*\*|\*\/|\*|\/\* ?/gm, "")
      .replace(/^  /gm, "")
      .trim();
  }

  static getFirstCommentBlock(sourceFile: ts.SourceFile): string | null {
    for (const statement of sourceFile.statements) {
      const comments = Comments.getCleanedCommentsForNode(statement, sourceFile);
      if (comments) return comments;
    }

    return null;
  }

  static getTsDocCommentsForFunction(node: ts.Node, sourceFile: ts.SourceFile) {
    const params: Record<string, string> = {};
    const trivia = ts.getLeadingCommentRanges(sourceFile.text, node.getFullStart()) || [];

    let comment = "";

    for (const range of trivia) {
      const commentText = Comments.removeCommentSyntax(
        sourceFile.text.substring(range.pos, range.end),
      );

      const lines = commentText.split("\n").map((line) => line.trim());

      if (lines.length && !lines[0].startsWith("@param")) {
        comment = lines[0];
      }

      lines.forEach((line) => {
        if (line.startsWith("@param")) {
          const parts = line.split(/\s+/);
          if (parts.length >= 3) {
            const paramName = parts[1];
            const description = parts.slice(2).join(" ");
            params[paramName] = description.trim();
          }
        }
      });
    }

    return { comment, params };
  }
}



---
File: /CopilotKit/scripts/docs/lib/files.ts
---

import { ReferenceDocConfiguration } from "./reference-doc";

export const REFERENCE_DOCS: ReferenceDocConfiguration[] = [
  /* Runtime */
  {
    sourcePath: "packages/runtime/src/service-adapters/google/google-genai-adapter.ts",
    destinationPath:
      "docs/content/docs/reference/classes/llm-adapters/GoogleGenerativeAIAdapter.mdx",
    className: "GoogleGenerativeAIAdapter",
    description: "Copilot Runtime adapter for Google Generative AI (e.g. Gemini).",
  },
  {
    sourcePath: "packages/runtime/src/service-adapters/groq/groq-adapter.ts",
    destinationPath: "docs/content/docs/reference/classes/llm-adapters/GroqAdapter.mdx",
    className: "GroqAdapter",
    description: "Copilot Runtime adapter for Groq.",
  },
  {
    sourcePath: "packages/runtime/src/service-adapters/langchain/langchain-adapter.ts",
    destinationPath: "docs/content/docs/reference/classes/llm-adapters/LangChainAdapter.mdx",
    className: "LangChainAdapter",
    description: "Copilot Runtime adapter for LangChain.",
  },
  {
    sourcePath: "packages/runtime/src/service-adapters/openai/openai-adapter.ts",
    destinationPath: "docs/content/docs/reference/classes/llm-adapters/OpenAIAdapter.mdx",
    className: "OpenAIAdapter",
    description: "Copilot Runtime adapter for OpenAI.",
  },
  {
    sourcePath: "packages/runtime/src/service-adapters/openai/openai-assistant-adapter.ts",
    destinationPath:
      "docs/content/docs/reference/classes/llm-adapters/OpenAIAssistantAdapter.mdx",
    className: "OpenAIAssistantAdapter",
    description: "Copilot Runtime adapter for OpenAI Assistant API.",
  },
  {
    sourcePath: "packages/runtime/src/service-adapters/anthropic/anthropic-adapter.ts",
    destinationPath: "docs/content/docs/reference/classes/llm-adapters/AnthropicAdapter.mdx",
    className: "AnthropicAdapter",
    description: "Copilot Runtime adapter for Anthropic.",
  },
  /* Classes */
  {
    sourcePath: "packages/react-core/src/lib/copilot-task.ts",
    destinationPath: "docs/content/docs/reference/classes/CopilotTask.mdx",
    className: "CopilotTask",
    description: "CopilotTask is used to execute one-off tasks, for example on button click.",
  },
  {
    sourcePath: "packages/runtime/src/lib/runtime/copilot-runtime.ts",
    destinationPath: "docs/content/docs/reference/classes/CopilotRuntime.mdx",
    className: "CopilotRuntime",
    description:
      "Copilot Runtime is the back-end component of CopilotKit, enabling interaction with LLMs.",
  },
  /* Components */
  {
    sourcePath: "packages/react-ui/src/components/chat/Chat.tsx",
    destinationPath: "docs/content/docs/reference/components/chat/CopilotChat.mdx",
    component: "CopilotChat",
    description:
      "The CopilotChat component, providing a chat interface for interacting with your copilot.",
  },
  {
    sourcePath: "packages/react-core/src/components/copilot-provider/copilotkit.tsx",
    destinationPath: "docs/content/docs/reference/components/CopilotKit.mdx",
    component: "CopilotKit",
    description: "The CopilotKit provider component, wrapping your application.",
  },
  {
    sourcePath: "packages/react-ui/src/components/chat/Popup.tsx",
    destinationPath: "docs/content/docs/reference/components/chat/CopilotPopup.mdx",
    component: "CopilotPopup",
    description:
      "The CopilotPopup component, providing a popup interface for interacting with your copilot.",
  },
  {
    sourcePath: "packages/react-ui/src/components/chat/Sidebar.tsx",
    destinationPath: "docs/content/docs/reference/components/chat/CopilotSidebar.mdx",
    component: "CopilotSidebar",
    description:
      "The CopilotSidebar component, providing a sidebar interface for interacting with your copilot.",
  },
  {
    sourcePath: "packages/react-textarea/src/components/copilot-textarea/copilot-textarea.tsx",
    destinationPath: "docs/content/docs/reference/components/CopilotTextarea.mdx",
    component: "CopilotTextarea",
    description:
      "An AI-powered textarea component for your application, which serves as a drop-in replacement for any textarea.",
  },
  /* Hooks */
  {
    sourcePath: "packages/react-core/src/hooks/use-copilot-chat.ts",
    destinationPath: "docs/content/docs/reference/hooks/useCopilotChat.mdx",
    hook: "useCopilotChat",
  },
  {
    sourcePath: "packages/react-ui/src/hooks/use-copilot-chat-suggestions.tsx",
    destinationPath: "docs/content/docs/reference/hooks/useCopilotChatSuggestions.mdx",
    hook: "useCopilotChatSuggestions",
    description:
      "The useCopilotChatSuggestions hook generates suggestions in the chat window based on real-time app state.",
  },
  {
    sourcePath: "packages/react-core/src/hooks/use-copilot-readable.ts",
    destinationPath: "docs/content/docs/reference/hooks/useCopilotReadable.mdx",
    hook: "useCopilotReadable",
    description:
      "The useCopilotReadable hook allows you to provide knowledge to your copilot (e.g. application state).",
  },
];



---
File: /CopilotKit/scripts/docs/lib/mdx.ts
---

// import { promises as fs } from "fs";
// import { join, resolve } from "path";
// import { glob } from "glob";

// type AnnotationType = "hook" | "component" | "class";

// export interface AnnotatedDoc {
//   path: string;
//   comment: string;
//   type: AnnotationType;
//   name: string;
//   sourcePath: string;
// }

// export async function getAnnotatedMdxDocs(directory: string): Promise<AnnotatedDoc[]> {
//   const fullPath = resolve(directory);
//   const pattern = join(fullPath, "**/*.mdx");
//   const files = await glob(pattern);
//   const annotations: AnnotatedDoc[] = [];

//   for (const file of files) {
//     const content = await fs.readFile(file, "utf8");
//     // Regular expression to find the specific comment format
//     const commentRegex = /{\/\*\s*GENERATE-DOCS\s*(.*?)\s*\*\/}/g;
//     let match;
//     while ((match = commentRegex.exec(content)) !== null) {
//       const details = parseKeyValuePairs(match[1].trim());
//       const sourcePath = details["path"];

//       let type: AnnotationType | undefined;
//       let name: string | undefined;

//       for (const key of ["hook", "component", "class"]) {
//         if (details[key]) {
//           type = key as AnnotationType;
//           name = details[key];
//           break;
//         }
//       }

//       if (type && name && sourcePath) {
//         const annotatedDoc: AnnotatedDoc = {
//           path: file,
//           comment: match[1].trim(),
//           type,
//           name,
//           sourcePath,
//         };
//         annotations.push(annotatedDoc);
//       }
//     }
//   }

//   return annotations;
// }

// function parseKeyValuePairs(input: string): Record<string, string> {
//   return input.split(/\s+/).reduce(
//     (acc, current) => {
//       const [key, value] = current.split("=");
//       if (key && value) {
//         acc[key] = value.replace(/^['"]|['"]$/g, ""); // Remove quotes around the value
//       }
//       return acc;
//     },
//     {} as Record<string, string>,
//   );
// }



---
File: /CopilotKit/scripts/docs/lib/reference-doc.ts
---

import { SourceFile } from "./source";
import { Comments } from "./comments";

// @ts-ignore
import fs from "fs";

export interface ReferenceDocConfiguration {
  sourcePath: string;
  destinationPath: string;
  className?: string;
  component?: string;
  hook?: string;
  description?: string;
}
// docs/pages/reference/classes/CopilotRuntime/service-adapters/GoogleGenerativeAIAdapter.mdx
export class ReferenceDoc {
  constructor(private readonly referenceDoc: ReferenceDocConfiguration) {}

  async generate() {
    const generatedDocumentation = await this.generatedDocs();
    // console.log(generatedDocumentation);
    if (generatedDocumentation) {
      const dest = "../" + this.referenceDoc.destinationPath;
      fs.writeFileSync(dest, generatedDocumentation);
      console.log(`Successfully autogenerated ${dest} from ${this.referenceDoc.sourcePath}`);
    }
  }

  async generatedDocs(): Promise<string | null> {
    const source = new SourceFile(this.referenceDoc.sourcePath);
    await source.parse();

    const comment = Comments.getFirstCommentBlock(source.sourceFile);

    if (!comment) {
      console.warn(`No comment found for ${this.referenceDoc.sourcePath}`);
      console.warn("Skipping...");
      return null;
    }

    const arg0Interface = await source.getArg0Interface(
      this.referenceDoc.className || this.referenceDoc.component || this.referenceDoc.hook || "",
    );

    let result: string = "";

    // handle imports
    const slashes = this.referenceDoc.destinationPath.split("/").length;
    let importPathPrefix = "";
    for (let i = 0; i < slashes - 2; i++) {
      importPathPrefix += "../";
    }

    result += `---\n`;
    result += `title: "${this.referenceDoc.className || this.referenceDoc.component || this.referenceDoc.hook}"\n`;
    if (this.referenceDoc.description) {
      result += `description: "${this.referenceDoc.description}"\n`;
    }
    result += `---\n\n`;

    result += `${comment}\n\n`;

    if (this.referenceDoc.hook) {
      result += `## Parameters\n\n`;
    } else if (this.referenceDoc.component) {
      result += `## Properties\n\n`;
    } else if (this.referenceDoc.className) {
      result += `## Constructor Parameters\n\n`;
    }

    if (arg0Interface) {
      for (const property of arg0Interface.properties) {
        if (property.comment.includes("@deprecated")) {
          continue;
        }
        const type = property.type.replace(/"/g, "'");

        result += `<PropertyReference name="${property.name}" type="${type}" ${property.required ? "required" : ""} ${property.defaultValue ? `default="${property.defaultValue}"` : ""}> \n`;
        result += `${property.comment}\n`;
        result += `</PropertyReference>\n\n`;
      }
    } else if (this.referenceDoc.className) {
      const constr = source.getConstructorDefinition(this.referenceDoc.className);
      if (constr) {
        result += `## ${constr.signature}\n\n`;
        result += `${constr.comment}\n\n`;
        for (const param of constr.parameters) {
          const type = param.type.replace(/"/g, "'");

          result += `<PropertyReference name="${param.name}" type="${type}" ${param.required ? "required" : ""}>\n`;
          result += `${param.comment}\n`;
          result += `</PropertyReference>\n\n`;
        }
      }
    }

    if (this.referenceDoc.className) {
      const methodDefinitions = await source.getPublicMethodDefinitions(
        this.referenceDoc.className,
      );

      for (const method of methodDefinitions) {
        if (
          method.signature === "process(request: CopilotRuntimeChatCompletionRequest)" ||
          method.signature === "process(request: CopilotRuntimeRequest)"
        ) {
          // skip the process method
          continue;
        }

        const methodName = method.signature.split("(")[0];
        const methodArgs = method.signature.split("(")[1].split(")")[0];
        result += `<PropertyReference name="${methodName}" type="${methodArgs}">\n`;
        result += `${method.comment}\n\n`;
        for (const param of method.parameters) {
          const type = param.type.replace(/"/g, "'");

          result += `  <PropertyReference name="${param.name}" type="${type}" ${param.required ? "required" : ""}>\n`;
          result += `  ${param.comment}\n`;
          result += `  </PropertyReference>\n\n`;
        }
        result += `</PropertyReference>\n\n`;
      }
    }

    return result;
  }
}



---
File: /CopilotKit/scripts/docs/lib/source.ts
---

import * as ts from "typescript";
// @ts-ignore
import * as fs from "fs";
// @ts-ignore
import { existsSync } from "fs";
// @ts-ignore
import { dirname, resolve } from "path";
import { Comments } from "./comments";

export interface InterfaceDefinition {
  name: string;
  properties: {
    name: string;
    type: string;
    required: boolean;
    comment: string;
    defaultValue?: string;
  }[];
}

export interface MethodDefinition {
  signature: string;
  comment: string;
  parameters: {
    name: string;
    type: string;
    required: boolean;
    comment: string;
  }[];
}

export class SourceFile {
  public sourceFile!: ts.SourceFile;

  constructor(private readonly filePath: string) {}

  parse() {
    const fileContents = fs.readFileSync(this.filePath, "utf8");
    this.sourceFile = ts.createSourceFile(
      this.filePath,
      fileContents,
      ts.ScriptTarget.Latest,
      true,
    );
  }

  /**
   * Get the interface definition of the first argument of the function or class constructor.
   */
  getArg0Interface(name: string): InterfaceDefinition | null {
    let interfaceName: string = "";

    const visit = (node: ts.Node) => {
      // if we find a matching function declaration
      if (
        ts.isFunctionDeclaration(node) &&
        node.name?.getText() === name &&
        node.parameters.length &&
        node.parameters[0].type &&
        ts.isTypeReferenceNode(node.parameters[0].type)
      ) {
        interfaceName = node.parameters[0].type.typeName.getText();
      }
      // if we find a matching class declaration
      else if (ts.isClassDeclaration(node) && node.name?.getText() === name) {
        const constructor = node.members.find((member) =>
          ts.isConstructorDeclaration(member),
        ) as ts.ConstructorDeclaration;
        if (
          constructor &&
          constructor.parameters.length &&
          constructor.parameters[0].type &&
          ts.isTypeReferenceNode(constructor.parameters[0].type)
        ) {
          interfaceName = constructor.parameters[0].type.typeName.getText();
        }
      }
      // if we find a matching forwardRef declaration
      else if (ts.isVariableStatement(node) || ts.isVariableDeclaration(node)) {
        const declarations = ts.isVariableStatement(node)
          ? node.declarationList.declarations
          : [node];

        declarations.forEach((declaration) => {
          if (
            ts.isVariableDeclaration(declaration) &&
            declaration.name.getText() === name &&
            declaration.initializer &&
            ts.isCallExpression(declaration.initializer) &&
            declaration.initializer.expression.getText() === "React.forwardRef"
          ) {
            const func = declaration.initializer.arguments[0];
            if (
              ts.isArrowFunction(func) &&
              func.parameters.length &&
              func.parameters[0].type &&
              ts.isTypeReferenceNode(func.parameters[0].type)
            ) {
              interfaceName = func.parameters[0].type.typeName.getText();
            }
          }
        });
      }

      ts.forEachChild(node, visit);
    };

    // analyze the source file
    visit(this.sourceFile);

    if (!interfaceName) {
      return null;
    }

    // extract the interface definition
    let interfaceFilePath = this.findTypeDeclaration(interfaceName) || this.filePath;

    const interfaceSource = new SourceFile(interfaceFilePath);
    interfaceSource.parse();

    return interfaceSource.extractInterfaceDefinition(interfaceName);
  }

  /**
   * Extracts the interface definition from the source file.
   */
  protected extractInterfaceDefinition(interfaceName: string): InterfaceDefinition {
    const definition: InterfaceDefinition = {
      name: interfaceName,
      properties: [],
    };
    const visit = (node: ts.Node) => {
      if (ts.isInterfaceDeclaration(node) && node.name.text === interfaceName) {
        let omittedProperties: Set<string> = new Set();

        // Check for extended interfaces
        if (node.heritageClauses && node.heritageClauses.length > 0) {
          const firstClause = node.heritageClauses[0];
          firstClause.types.forEach((type) => {
            const typeName = type.expression.getText(this.sourceFile);
            let extendedInterfaceName = typeName;

            // Check if the type is an Omit
            if (typeName.startsWith("Omit")) {
              const omitArgs = type.typeArguments;
              if (omitArgs && omitArgs.length > 0) {
                extendedInterfaceName = omitArgs[0].getText(this.sourceFile);
                if (omitArgs.length > 1) {
                  const omittedProps = omitArgs[1];
                  if (ts.isUnionTypeNode(omittedProps)) {
                    omittedProps.types.forEach((prop) => {
                      omittedProperties.add(prop.getText(this.sourceFile).replace(/['"]/g, ""));
                    });
                  } else if (ts.isLiteralTypeNode(omittedProps)) {
                    omittedProperties.add(
                      omittedProps.getText(this.sourceFile).replace(/['"]/g, ""),
                    );
                  }
                }
              }
            }

            const extendedInterfaceFilePath = this.findTypeDeclaration(extendedInterfaceName);
            if (extendedInterfaceFilePath) {
              // Parse the extended interface file and extract its definition
              const extendedInterfaceSource = new SourceFile(extendedInterfaceFilePath);
              extendedInterfaceSource.parse();
              const extendedDefinition =
                extendedInterfaceSource.extractInterfaceDefinition(extendedInterfaceName);
              // Merge properties from the extended interface, excluding omitted properties
              extendedDefinition.properties.forEach((prop) => {
                if (!omittedProperties.has(prop.name)) {
                  definition.properties.push(prop);
                }
              });
            }
          });
        }
        node.members.forEach((member) => {
          if (ts.isPropertySignature(member)) {
            const propertyName = member.name.getText(this.sourceFile);
            const comment = Comments.getCleanedCommentsForNode(member, this.sourceFile);
            const defaultValue = Comments.getDefaultValueForNode(member, this.sourceFile);

            definition.properties.push({
              name: propertyName,
              type: (member.type?.getText(this.sourceFile) || "unknown")
                .replace(/\n/g, "")
                .replace(/\s+/g, " "),
              required: !member.questionToken,
              comment,
              defaultValue,
            });
          }
        });
      }
      ts.forEachChild(node, visit);
    };

    visit(this.sourceFile);
    return definition;
  }

  /**
   * Finds the absolute declaration file path of a type if imported.
   */
  findTypeDeclaration(typeName: string): string | null {
    for (const statement of this.sourceFile.statements) {
      if (ts.isImportDeclaration(statement) && statement.importClause) {
        const namedBindings = statement.importClause.namedBindings;
        if (namedBindings && ts.isNamedImports(namedBindings)) {
          const imports = namedBindings.elements.filter(
            (element) => element.name.text === typeName,
          );
          if (imports.length > 0) {
            const moduleSpecifier = (statement.moduleSpecifier as ts.StringLiteral).text;
            // Resolve the path relative to the directory of the current source file
            let resolvedPath = resolve(dirname(this.sourceFile.fileName), moduleSpecifier);

            if (existsSync(resolvedPath + ".ts")) {
              return resolvedPath + ".ts";
            } else if (existsSync(resolvedPath + ".tsx")) {
              return resolvedPath + ".tsx";
            }
            return null;
          }
        }
      }
    }
    return null;
  }

  /**
   * Get the public method definitions of a class.
   */
  getPublicMethodDefinitions(className: string): MethodDefinition[] {
    const methodDefinitions: MethodDefinition[] = [];

    const visit = (node: ts.Node) => {
      if (ts.isClassDeclaration(node) && node.name?.getText() === className) {
        node.members.forEach((member) => {
          if (
            ts.isMethodDeclaration(member) &&
            member.modifiers?.every((modifier) => modifier.kind !== ts.SyntaxKind.PrivateKeyword)
          ) {
            methodDefinitions.push(this.extractMethodDefinition(member));
          }
        });
      }
      ts.forEachChild(node, visit);
    };

    visit(this.sourceFile);

    return methodDefinitions;
  }

  /**
   * Extracts the method definition from a method declaration.
   */
  private extractMethodDefinition(member: ts.MethodDeclaration): MethodDefinition {
    const functionComments = Comments.getTsDocCommentsForFunction(member, this.sourceFile);
    const name = ts.isConstructorDeclaration(member) ? "constructor" : member.name.getText();
    let signature = name + "(" + member.parameters.map((param) => param.getText()).join(", ") + ")";
    signature = signature.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return {
      signature,
      comment: functionComments.comment,
      parameters: member.parameters.map((param) => {
        return {
          name: param.name.getText(),
          type: param.type?.getText() || "unknown",
          required: !param.questionToken,
          comment: functionComments.params[param.name.getText()] || "",
        };
      }),
    };
  }

  /**
   * Get the constructor definition of a class.
   */
  getConstructorDefinition(className: string): MethodDefinition | null {
    let constructorDefinition: MethodDefinition | null = null;

    const visit = (node: ts.Node) => {
      if (ts.isClassDeclaration(node) && node.name?.getText() === className) {
        const constr = node.members.find((member) => ts.isConstructorDeclaration(member)) as any;
        if (constr) {
          constructorDefinition = this.extractMethodDefinition(constr);
        }
      }
      ts.forEachChild(node, visit);
    };

    visit(this.sourceFile);

    return constructorDefinition;
  }
}



---
File: /CopilotKit/scripts/docs/gen.ts
---

import { REFERENCE_DOCS } from "./lib/files";
import { ReferenceDoc } from "./lib/reference-doc";

Promise.all(
  REFERENCE_DOCS.map(async (referenceDoc) => {
    const doc = new ReferenceDoc(referenceDoc);
    await doc.generate();
  }),
)
  .then(() => {
    console.log("All reference docs processed");
  })
  .catch((error) => {
    console.error("Error processing reference docs:", error);
  });



---
File: /CopilotKit/scripts/qa/lib/actions/bad/array.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "object",
  parameters: [
    {
      name: "arg",
      type: "object[]",
      description: "The object argument to display.",
      attributes: [
        {
          name: "x",
          type: "string",
          description: "The x attribute.",
        },
        {
          name: "y",
          type: "number",
          description: "The y attribute.",
        },
      ],
    },
  ],
  handler: async ({ arg }) => {
    const x: string = arg[0].x;
    const y: number = arg[0].y;
    const z: boolean = arg[0].z;
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/bad/enum.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "enum",
  parameters: [
    {
      name: "arg",
      type: "string",
      description: "The enum to display.",
      enum: ["one", "two", "three"],
    },
  ],
  handler: async ({ arg }) => {
    switch (arg) {
      case "one":
        console.log("One");
        break;
      case "two":
        console.log("Two");
        break;
      default:
        const exhaustiveCheck: never = arg;
    }
    console.log("No args action");
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/bad/noargs.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "noargs",
  handler: async (args) => {
    console.log("No args action");
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/bad/object.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "object",
  parameters: [
    {
      name: "arg",
      type: "object",
      description: "The object argument to display.",
      attributes: [
        {
          name: "x",
          type: "string",
          description: "The x attribute.",
        },
        {
          name: "y",
          type: "number",
          description: "The y attribute.",
        },
      ],
    },
  ],
  handler: async ({ arg }) => {
    const x: string = arg.x;
    const y: number = arg.y;
    const z: boolean = arg.z;
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/bad/optional.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "optional",
  parameters: [
    {
      name: "arg",
      type: "string",
      description: "The optional argument to display.",
      required: false,
    },
  ],
  handler: async ({ arg }) => {
    // TODO this should fail
    let x: string = arg;
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/good/array.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "array",
  parameters: [
    {
      name: "arg",
      type: "object[]",
      description: "The object argument to display.",
      attributes: [
        {
          name: "x",
          type: "string",
          description: "The x attribute.",
        },
        {
          name: "y",
          type: "number",
          description: "The y attribute.",
        },
      ],
    },
  ],
  handler: async ({ arg }) => {
    const x: string = arg[0].x;
    const y: number = arg[0].y;
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/good/enum.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "enum",
  parameters: [
    {
      name: "arg",
      type: "string",
      description: "The enum to display.",
      enum: ["one", "two", "three"],
    },
  ],
  handler: async ({ arg }) => {
    switch (arg) {
      case "one":
        console.log("One");
        break;
      case "two":
        console.log("Two");
        break;
      case "three":
        console.log("Three");
        break;
      default:
        const exhaustiveCheck: never = arg;
    }
    console.log("No args action");
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/good/noargs.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "noargs",
  handler: async () => {
    console.log("No args action");
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/good/object.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "object",
  parameters: [
    {
      name: "arg",
      type: "object",
      description: "The object argument to display.",
      attributes: [
        {
          name: "x",
          type: "string",
          description: "The x attribute.",
        },
        {
          name: "y",
          type: "number",
          description: "The y attribute.",
        },
      ],
    },
  ],
  handler: async ({ arg }) => {
    const x: string = arg.x;
    const y: number = arg.y;
  },
});



---
File: /CopilotKit/scripts/qa/lib/actions/good/optional.ts
---

import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "optional",
  parameters: [
    {
      name: "arg",
      type: "string",
      description: "The optional argument to display.",
      required: false,
    },
  ],
  handler: async ({ arg }) => {
    let x: string = "y";

    if (arg !== undefined) {
      x = arg;
    }
  },
});



---
File: /CopilotKit/scripts/qa/lib/css/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotKitCSSProperties, CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <div
      style={
        {
          height: `100vh`,
          "--copilot-kit-primary-color": "red",
        } as CopilotKitCSSProperties
      }
    >
      <CopilotKit url="/api/copilotkit/openai">
        <CopilotSidebar
          defaultOpen={true}
          labels={{
            title: "Presentation Copilot",
            initial: "Hi you! 👋 I can give you a presentation on any topic.",
          }}
          icons={{
            sendIcon: "📩",
          }}
        >
          <InsideHome />
        </CopilotSidebar>
      </CopilotKit>
    </div>
  );
}



---
File: /CopilotKit/scripts/qa/lib/css/route.ts
---

import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/runtime";

export async function POST(req: Request): Promise<Response> {
  const copilotKit = new CopilotRuntime();
  return copilotKit.response(req, new OpenAIAdapter({}));
}



---
File: /CopilotKit/scripts/qa/lib/firebase/index.ts
---

/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import { onRequest } from "firebase-functions/v2/https";
// import * as logger from "firebase-functions/logger";
import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/runtime";

// Start writing functions
// https://firebase.google.com/docs/functions/typescript

export const copilotKit = onRequest((request, response) => {
  const copilotKit = new CopilotRuntime();
  copilotKit.streamHttpServerResponse(request, response, new OpenAIAdapter({}));
});



---
File: /CopilotKit/scripts/qa/lib/firebase/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return <div className="h-screen w-full flex items-center justify-center text-2xl">{message}</div>;
}
export default function Home() {
  return (
    <CopilotKit url="http://127.0.0.1:5001/copilotkit-test-12345/us-central1/copilotKit">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
        clickOutsideToClose={false}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/langchain/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      {/* <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      /> */}
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="/api/copilotkit/langchain">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/langchain/route.ts
---

import {
  CopilotRuntime,
  LangChainAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";

import { ChatOpenAI } from "@langchain/openai";

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "Says hello to someone.",
      parameters: [
        {
          name: "arg",
          type: "string",
          description: "The name of the person to say hello to.",
          required: true,
        },
      ],
      handler: async ({ arg }) => {
        console.log("Hello from the server", arg, "!");
      },
    },
  ],
});

const serviceAdapter = new LangChainAdapter({
  chainFn: async ({ messages, tools }) => {
    const model = new ChatOpenAI({ modelName: "gpt-4-1106-preview" }).bind(tools as any);
    return model.stream(messages);
  },
});

export const { GET, POST, OPTIONS } = copilotRuntimeNextJSAppRouterEndpoint({
  runtime,
  serviceAdapter,
  endpoint: "/api/copilotkit/langchain",
  debug: true,
}) as any;



---
File: /CopilotKit/scripts/qa/lib/langserve/app/server.py
---

#!/usr/bin/env python
"""Example LangChain server exposes multiple runnables (LLMs in this case)."""
from dotenv import load_dotenv
load_dotenv()

from fastapi import FastAPI
from langchain.chat_models import ChatOpenAI
from langchain.vectorstores import FAISS
from langchain.embeddings import OpenAIEmbeddings
from langchain.agents import AgentExecutor, tool
from langchain.tools.render import format_tool_to_openai_function
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser
from langchain.pydantic_v1 import BaseModel
from typing import Any
from langchain.agents.format_scratchpad import format_to_openai_functions

from langserve import add_routes

app = FastAPI(
    title="LangChain Server",
    version="1.0",
    description="Spin up a simple api server using Langchain's Runnable interfaces",
)

# ChatOpenAI
# ----------
# We probably can't support ChatOpenAI...
# see input schema: http://localhost:8000/openai/input_schema
# also playground: http://localhost:8000/openai/playground/
# it looks tricky to support this in a generic way
add_routes(
    app,
    ChatOpenAI(),
    path="/openai",
)

# Retriever
# ---------
# receives a single input VectorStoreRetrieverInput (type string)
# Input Schema: {"title":"VectorStoreRetrieverInput","type":"string"}
# according to the client docs, it can be called like this:
# - requests.post("http://localhost:8000/invoke", json={"input": "tree"})
# - remote_runnable.invoke("tree")
vectorstore = FAISS.from_texts(
    ["cats like fish", "dogs like sticks"], embedding=OpenAIEmbeddings()
)
retriever = vectorstore.as_retriever()

add_routes(
    app, 
    retriever,
    path="/retriever",
)

# Agent
# -----
# Input Schema: {"title":"Input","type":"object","properties":{"input":{"title":"Input","type":"string"}},"required":["input"]}
# - requests.post("http://localhost:8000/invoke", json={"input": {"input": "what does eugene think of cats?"}})
# - remote_runnable.invoke({"input": "what does eugene think of cats?"})
@tool
def get_eugene_thoughts(query: str) -> list:
    """Returns Eugene's thoughts on a topic."""
    return retriever.get_relevant_documents(query)

tools = [get_eugene_thoughts]
llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0, streaming=True)
llm_with_tools = llm.bind(functions=[format_tool_to_openai_function(t) for t in tools])
prompt = ChatPromptTemplate.from_messages(
    [
        ("system", "You are a helpful assistant."),
        ("user", "{input}"),
        MessagesPlaceholder(variable_name="agent_scratchpad"),
    ]
)
agent = (
    {
        "input": lambda x: x["input"],
        "agent_scratchpad": lambda x: format_to_openai_functions(
            x["intermediate_steps"]
        ),
    }
    | prompt
    | llm_with_tools
    | OpenAIFunctionsAgentOutputParser()
)
agent_executor = AgentExecutor(agent=agent, tools=tools)

class Input(BaseModel):
    input: str

class Output(BaseModel):
    output: Any

add_routes(
    app,
    agent_executor.with_types(input_type=Input, output_type=Output).with_config(
        {"run_name": "agent"}
    ),
    path="/agent",
)


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="localhost", port=8000)



---
File: /CopilotKit/scripts/qa/lib/langserve/next/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      {/* <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      /> */}
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="/api/copilotkit/openai">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/langserve/next/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { ChatOpenAI } from "@langchain/openai";

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "Says hello to someone.",
      parameters: [
        {
          name: "name",
          type: "string",
          description: "The name of the person to say hello to.",
          required: true,
        },
      ],
      handler: async ({ name }) => {
        const prompt = ChatPromptTemplate.fromMessages([
          [
            "system",
            "The user tells you their name. Say hello to the person in the most " +
              " ridiculous way, roasting their name.",
          ],
          ["user", "My name is {name}"],
        ]);
        const chain = prompt.pipe(new ChatOpenAI());
        return chain.invoke({
          name: name,
        });
      },
    },
    {
      name: "sayGoodbye",
      description: "Says goodbye to someone.",
      parameters: [
        {
          name: "name",
          type: "string",
          description: "The name of the person to say goodbye to.",
          required: true,
        },
      ],
      handler: async ({ name }) => {
        const prompt = ChatPromptTemplate.fromMessages([
          [
            "system",
            "The user tells you their name. Say goodbye to the person in the most " +
              " ridiculous way, roasting their name.",
          ],
          ["user", "My name is {name}"],
        ]);
        const chain = prompt.pipe(new ChatOpenAI());
        return chain.stream({
          name: name,
        });
      },
    },
  ],
  langserve: [
    {
      chainUrl: "http://localhost:8000/retriever",
      name: "askAboutAnimals",
      description: "Always call this function if the users asks about a certain animal.",
    },
    {
      chainUrl: "http://localhost:8000/agent",
      name: "askAboutEugeneThoughts",
      description:
        "Always call this function if the users asks about Eugene's thoughts on a certain topic.",
    },
  ],
});

const serviceAdapter = new OpenAIAdapter();

export const { GET, POST, OPTIONS } = copilotRuntimeNextJSAppRouterEndpoint({
  runtime,
  serviceAdapter,
  endpoint: "/api/copilotkit/openai",
  debug: true,
}) as any;



---
File: /CopilotKit/scripts/qa/lib/next/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="/api/copilotkit/openai">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/next/route.ts
---

/**
 * @filePath app/copilotkit/route.ts
 */
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import { NextRequest } from "next/server";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime();

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/scripts/qa/lib/next-pages/copilotkit.ts
---

/**
 * @filePath pages/api/copilotkit.ts
 */
import { NextApiRequest, NextApiResponse } from "next";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSPagesRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime();

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const handleRequest = copilotRuntimeNextJSPagesRouterEndpoint({
    endpoint: "/api/copilotkit",
    runtime,
    serviceAdapter,
  });

  return await handleRequest(req, res);
};

export default handler;



---
File: /CopilotKit/scripts/qa/lib/next-pages/index.tsx
---

import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}

export default function Home() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/node/express.ts
---

/**
 * @filePath server.ts
 */
import express from "express";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime();

const copilotRuntime = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/copilotkit",
  runtime,
  serviceAdapter,
});

const app = express();

app.use("/copilotkit", copilotRuntime);

app.listen(4000, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/scripts/qa/lib/node/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="http://localhost:4000">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/node/server.ts
---

/**
 * @filePath server.ts
 */
import { createServer } from "node:http";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const runtime = new CopilotRuntime();

const copilotRuntime = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/copilotkit",
  runtime,
  serviceAdapter,
});

const server = createServer((req, res) => {
  return copilotRuntime(req, res);
});

server.listen(4000, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/scripts/qa/lib/remix/_index.tsx
---

import type { MetaFunction } from "@remix-run/node";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";

export const meta: MetaFunction = () => {
  return [{ title: "New Remix App" }, { name: "description", content: "Welcome to Remix!" }];
};

function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
      render: (props) => {
        return (
          <div style={{ backgroundColor: "black", color: "white" }}>
            <div>Status: {props.status}</div>
            <div>Message: {props.args.message}</div>
          </div>
        );
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}

export default function Index() {
  return (
    <CopilotKit runtimeUrl="/copilotkit">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/remix/copilotkit.tsx
---

import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/runtime";
import type { ActionFunctionArgs } from "@remix-run/node";

export async function action({ request }: ActionFunctionArgs) {
  if (request.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const copilotKit = new CopilotRuntime();
  return copilotKit.response(request, new OpenAIAdapter({}));
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-express/new/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="http://localhost:4000" properties={{ userId: "xyz" }}>
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-express/new/server.ts
---

import express from "express";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";

const port = 4000;
var HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, OPTIONS, PUT, PATCH, DELETE",
  "Access-Control-Allow-Headers": "X-Requested-With,content-type",
};

const handler = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/",
  runtime: new CopilotRuntime(),
  serviceAdapter: new OpenAIAdapter(),
});

const app = express();

app.use("/", (req, res, next) => {
  if (req.method === "OPTIONS") {
    res.writeHead(200, HEADERS);
    res.end();
    return;
  }
  return handler(req, res, next);
});

app.listen(port, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/scripts/qa/lib/upgrade-express/old/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="http://localhost:4000">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-express/old/server.ts
---

import express from "express";
import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/backend";

const port = 4000;
var HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, OPTIONS, PUT, PATCH, DELETE",
  "Access-Control-Allow-Headers": "X-Requested-With,content-type",
};

const app = express();

app.use("/", (req, res, next) => {
  if (req.method === "OPTIONS") {
    res.writeHead(200, HEADERS);
    res.end();
    return;
  }
  var copilotKit = new CopilotRuntime();
  copilotKit.streamHttpServerResponse(req, res, new OpenAIAdapter(), HEADERS);
});

app.listen(port, () => {
  console.log("Listening at http://localhost:4000/copilotkit");
});



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-app/new/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit/openai" properties={{ userid: "abc_123" }}>
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-app/new/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "say hello so someone by roasting their name",
      parameters: [
        {
          name: "roast",
          description: "A sentence or two roasting the name of the person",
          type: "string",
          required: true,
        },
      ],
      handler: ({ roast }) => {
        console.log(roast);
      },
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter: new OpenAIAdapter(),
    endpoint: req.nextUrl.pathname,
  });

  return handleRequest(req);
};



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-app/old/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit/openai">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-app/old/route.ts
---

import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/backend";

export async function POST(req: Request): Promise<Response> {
  const copilotKit = new CopilotRuntime({
    actions: [
      {
        name: "research",
        description:
          "Call this function to conduct research on a certain topic. Respect other notes about when to call this function",
        parameters: [
          {
            name: "topic",
            type: "string",
            description: "The topic to research. 5 characters or longer.",
            required: true,
          },
        ],
        handler: async ({ topic }) => {
          console.log("Researching topic: ", topic);
          return "The secret is xyz";
        },
      },
    ],
  });
  return copilotKit.response(req, new OpenAIAdapter({}));
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-pages/new/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit/openai" properties={{ userid: "abc_123" }}>
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-pages/new/route.ts
---

import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSPagesRouterEndpoint,
} from "@copilotkit/runtime";
import { NextApiRequest, NextApiResponse } from "next";

const serviceAdapter = new OpenAIAdapter();

const runtime = new CopilotRuntime({
  actions: [
    {
      name: "sayHello",
      description: "say hello so someone by roasting their name",
      parameters: [
        {
          name: "roast",
          description: "A sentence or two roasting the name of the person",
          type: "string",
          required: true,
        },
      ],
      handler: ({ roast }) => {
        console.log(roast);
        return "The person has been roasted.";
      },
    },
  ],
});

// This is required for file upload to work
export const config = {
  api: {
    bodyParser: false,
  },
};

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const handleRequest = copilotRuntimeNextJSPagesRouterEndpoint({
    endpoint: "/api/copilotkit",
    runtime,
    serviceAdapter,
  });

  return await handleRequest(req, res);
};

export default handler;



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-pages/old/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
      <CopilotTextarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        autosuggestionsConfig={{
          textareaPurpose: "an outline of a presentation about elephants",
          chatApiConfigs: {},
        }}
      />
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit runtimeUrl="/api/copilotkit/openai">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-next-pages/old/route.ts
---

// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from "next";
import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/backend";

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const copilotKit = new CopilotRuntime({});
  copilotKit.streamHttpServerResponse(req, res, new OpenAIAdapter({ model: "gpt-4o" }));
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-node/new/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="http://localhost:4000" properties={{ userId: "xyz" }}>
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-node/new/server.ts
---

import * as http from "http";
import { CopilotRuntime, OpenAIAdapter, copilotRuntimeNodeHttpEndpoint } from "@copilotkit/runtime";

const port = 4000;
var HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, OPTIONS, PUT, PATCH, DELETE",
  "Access-Control-Allow-Headers": "X-Requested-With,content-type",
};

const handler = copilotRuntimeNodeHttpEndpoint({
  endpoint: "/",
  runtime: new CopilotRuntime(),
  serviceAdapter: new OpenAIAdapter(),
});

var server = http.createServer(function (req, res) {
  // Respond to OPTIONS (preflight) request
  if (req.method === "OPTIONS") {
    res.writeHead(200, HEADERS);
    res.end();
    return;
  }

  return handler(req, res);
});
server.listen(port, function () {
  console.log(`Server running at http://localhost:${port}`);
});



---
File: /CopilotKit/scripts/qa/lib/upgrade-node/old/page.tsx
---

"use client";
import { CopilotKit, useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { CopilotTextarea } from "@copilotkit/react-textarea";
import { CopilotSidebar } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";
import { useState } from "react";
import "@copilotkit/react-textarea/styles.css";
import "@copilotkit/react-ui/styles.css";
function InsideHome() {
  const [message, setMessage] = useState("Hello World!");
  const [text, setText] = useState("");
  useCopilotReadable({
    description: "This is the current message",
    value: message,
  });
  useCopilotAction(
    {
      name: "displayMessage",
      description: "Display a message.",
      parameters: [
        {
          name: "message",
          type: "string",
          description: "The message to display.",
          required: true,
        },
      ],
      handler: async ({ message }) => {
        setMessage(message);
      },
    },
    [],
  );
  return (
    <>
      <div>{message}</div>
    </>
  );
}
export default function Home() {
  return (
    <CopilotKit url="http://localhost:4000">
      <CopilotSidebar
        defaultOpen={true}
        labels={{
          title: "Presentation Copilot",
          initial: "Hi you! 👋 I can give you a presentation on any topic.",
        }}
      >
        <InsideHome />
      </CopilotSidebar>
    </CopilotKit>
  );
}



---
File: /CopilotKit/scripts/qa/lib/upgrade-node/old/server.ts
---

import * as http from "http";
import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/backend";

const port = 4000;
var HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, OPTIONS, PUT, PATCH, DELETE",
  "Access-Control-Allow-Headers": "X-Requested-With,content-type",
};
var server = http.createServer(function (req, res) {
  // Respond to OPTIONS (preflight) request
  if (req.method === "OPTIONS") {
    res.writeHead(200, HEADERS);
    res.end();
    return;
  }
  var copilotKit = new CopilotRuntime();
  copilotKit.streamHttpServerResponse(req, res, new OpenAIAdapter(), HEADERS);
});
server.listen(port, function () {
  console.log(`Server running at http://localhost:${port}`);
});



---
File: /CopilotKit/utilities/eslint-config-custom/index.js
---

module.exports = {
  extends: ["next", "prettier"],
  rules: {
    "@next/next/no-html-link-for-pages": "off",
  },
  parserOptions: {
    babelOptions: {
      presets: [require.resolve("next/babel")],
    },
  },
};



---
File: /CopilotKit/utilities/tailwind-config/tailwind.config.js
---

const colors = require("tailwindcss/colors");

module.exports = {
  content: [
    // app content
    `src/**/*.{js,ts,jsx,tsx}`,
    // include packages if not transpiling
    // "../../packages/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        brandblue: colors.blue[500],
        brandred: colors.red[500],
      },
    },
  },
  plugins: [],
};



---
File: /CopilotKit/.eslintrc.js
---

module.exports = {
  root: true,
  // This tells ESLint to load the config from the package `eslint-config-custom`
  extends: ["custom"],
  settings: {
    next: {
      rootDir: ["examples/*/"],
    },
  },
};



---
File: /docs/app/(home)/[[...slug]]/page.tsx
---

import { source } from "@/app/source";
import type { Metadata } from "next";
import {
  DocsPage,
  DocsBody,
  DocsDescription,
  DocsTitle,
} from "fumadocs-ui/page";
import { notFound } from "next/navigation";
import defaultMdxComponents from "fumadocs-ui/mdx";

import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";
import { TypeTable } from "fumadocs-ui/components/type-table";
import { Pre, CodeBlock } from "fumadocs-ui/components/codeblock";
import { Callout } from "fumadocs-ui/components/callout";
import { Frame } from "@/components/react/frame";
import { Mermaid } from "@theguild/remark-mermaid/mermaid";
import { Cards, Card } from "fumadocs-ui/components/card";
import { PropertyReference } from "@/components/react/property-reference";
import { getImageMeta } from "fumadocs-ui/og";

const mdxComponents = {
  ...defaultMdxComponents,
  Tabs: Tabs,
  Tab: Tab,
  Steps: Steps,
  Step: Step,
  TypeTable: TypeTable,
  Callout: Callout,
  Frame: Frame,
  Mermaid: Mermaid,
  Cards: Cards,
  Card: Card,
  PropertyReference: PropertyReference,
  // HTML `ref` attribute conflicts with `forwardRef`
  pre: ({ ref: _ref, ...props }: any) => (
    <CodeBlock {...props}>
      <Pre>{props.children}</Pre>
    </CodeBlock>
  ),
};

export default async function Page({
  params,
}: {
  params: { slug?: string[] };
}) {
  const page = source.getPage(params.slug);
  if (!page) notFound();

  const MDX = page.data.body;

  return (
    <DocsPage
      toc={page.data.toc}
      full={page.data.full}
      editOnGithub={{
        owner: "CopilotKit",
        repo: "CopilotKit",
        sha: "main",
        path: `/docs/content/docs/${page.file.path}`,
      }}
    >
      <DocsTitle>{page.data.title}</DocsTitle>
      <DocsDescription>{page.data.description}</DocsDescription>
      <DocsBody>
        <MDX components={mdxComponents} renderSmth={() => <div>test</div>} />
      </DocsBody>
    </DocsPage>
  );
}

export async function generateStaticParams() {
  return source.generateParams();
}

export function generateMetadata({ params }: { params: { slug?: string[] } }) {
  const page = source.getPage(params.slug);
  if (!page) notFound();

  const image = getImageMeta("og", page.slugs);

  return {
    title: page.data.title,
    description: page.data.description,
    openGraph: {
      images: image,
    },
    twitter: {
      images: image,
      card: "summary_large_image",
    },
  } satisfies Metadata;
}



---
File: /docs/app/(home)/layout.tsx
---

import { DocsLayout } from "fumadocs-ui/layout";
import type { ReactNode } from "react";
import { baseOptions } from "../layout.config";
import { source } from "@/app/source";
import { SubdocsMenu } from "@/components/react/subdocs-menu";
import { TerminalIcon, RocketIcon, ZapIcon } from "lucide-react";
import { TopBar } from "@/components/layout/top-bar";

export default function Layout({ children }: { children: ReactNode }) {
  return (
    <>
      <TopBar />
      <DocsLayout
        tree={source.pageTree}
        {...baseOptions}
        sidebar={{
          hideSearch: true,
          banner: (
            <SubdocsMenu
              options={[
                {
                  title: "Quickstart & Guides",
                  description: "Quickstart & Guides",
                  url: "/",
                  icon: <RocketIcon className="w-4 h-4" />,
                  bgGradient:
                    "bg-gradient-to-b from-indigo-700 to-indigo-400 text-indigo-100",
                  selectedBorder: "ring-indigo-500/70",
                },
                {
                  title: "CoAgents (LangGraph)",
                  description: "CoAgents (LangGraph)",
                  url: "/coagents",
                  icon: <ZapIcon className="w-4 h-4" />,
                  bgGradient:
                    "bg-gradient-to-b from-rose-700 to-rose-400 text-rose-100",
                  selectedBorder: "ring-rose-500/70",
                },
                {
                  title: "API Reference",
                  description: "API Reference",
                  url: "/reference",
                  icon: <TerminalIcon className="w-4 h-4" />,
                  bgGradient:
                    "bg-gradient-to-b from-teal-700 to-teal-400 text-teal-100",
                  selectedBorder: "ring-teal-500/70",
                },
              ]}
            />
          ),
        }}
      >
        {children}
      </DocsLayout>
    </>
  );
}



---
File: /docs/app/api/search/route.ts
---

import { source } from '@/app/source';
import { createSearchAPI } from 'fumadocs-core/search/server';

export const { GET } = createSearchAPI('advanced', {
  indexes: source.getPages().map((page) => ({
    title: page.data.title,
    description: page.data.description,
    structuredData: page.data.structuredData,
    id: page.url,
    url: page.url,
  })),
});



---
File: /docs/app/og/[...slug]/route.tsx
---

import React from "react";
import { type NextRequest } from "next/server";
import { notFound } from "next/navigation";
import { source } from "../../source";
import { ImageResponse } from "next/og";

const getInter = async () => {
  const response = await fetch(
    `https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZg.ttf`
  );
  const res = await response.arrayBuffer();
  return res;
};

const getInterSemibold = async () => {
  const response = await fetch(
    `https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuGKYMZg.ttf`
  );
  const res = await response.arrayBuffer();
  return res;
};

export async function GET(
  _: NextRequest,
  { params }: { params: { slug: string[] } }
) {
  const page = source.getPage(params.slug.slice(0, -1));
  if (!page) notFound();

  return new ImageResponse(
    (
      <section
        style={{
          backgroundColor: "#000000",
          background: "#FAEEDC",
          backgroundImage:
            "url('https://docs.copilotkit.ai/images/opengraph-background.png')",
          backgroundSize: "cover",
          backgroundPosition: "0% 0%",
          width: "100%",
          height: "100%",
          padding: "5%",
          display: "block",
          position: "relative",
          fontFamily: "Satori",
        }}
      >
        <section style={{ display: "flex", flexDirection: "column" }}>
          <div style={{ display: "flex" }}>
            <img
              style={{
                width: "14rem",
              }}
              src="https://github-production-user-asset-6210df.s3.amazonaws.com/746397/288400836-bd5c9079-929b-4d55-bdc9-16d1c8181b71.png"
            />
          </div>

          <section
            style={{
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              justifyContent: "flex-end",
            }}
          >
            {page.data.title && (
              <p
                style={{
                  color: "#4f46e5",
                  fontFamily: "Inter",
                  fontWeight: 700,
                  margin: 0,
                  fontSize: 48,
                }}
              >
                {page.data.title}
              </p>
            )}
            {(page.data as any).description && (
              <p
                style={{
                  color: "#000000",
                  fontSize: 34,
                  marginBottom: 12,
                  fontWeight: 500,
                  fontFamily: "Inter",
                }}
              >
                {(page.data as any).description}
              </p>
            )}
          </section>
        </section>
      </section>
    ),
    {
      // width: width,
      // height: height,
      fonts: [
        {
          name: "Inter",
          weight: 500,
          data: await getInter(),
          style: "normal",
        },
        {
          name: "Inter",
          weight: 700,
          data: await getInterSemibold(),
          style: "normal",
        },
      ],
    }
  );
}

export function generateStaticParams() {
  return source.generateParams().map((params) => ({
    ...params,
    slug: [...params.slug, "og.png"],
  }));
}



---
File: /docs/app/global.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;

.line.diff.remove {
  background-color: red;
}

.line.diff.add {
  background-color: green;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }

  .fd-codeblock pre {
    @apply max-h-none;
  }

  div[data-toc] {
    @apply lg:mt-10;
  }

  article {
    @apply lg:mt-10;
  }
} 


---
File: /docs/app/layout.config.tsx
---

import { type HomeLayoutProps } from 'fumadocs-ui/home-layout';
import { Logo } from "./logo";

/**
 * Shared layout configurations
 *
 * you can configure layouts individually from:
 * Home Layout: app/(home)/layout.tsx
 * Docs Layout: app/docs/layout.tsx
 */
export const baseOptions: HomeLayoutProps = {
  nav: {
    title: <Logo />,
  },
  links: [],
};




---
File: /docs/app/layout.tsx
---

import "./global.css";
import { RootProvider } from "fumadocs-ui/provider";
import { Inter } from "next/font/google";
import type { ReactNode } from "react";
import { ProvidersWrapper } from "@/lib/providers/providers-wrapper";

const inter = Inter({
  subsets: ["latin"],
});

export default async function Layout({ children }: { children: ReactNode }) {
  return (
    <html lang="en" className={inter.className} suppressHydrationWarning>
      <body>
        <ProvidersWrapper clerkPublishableKey={process.env.CLERK_PUBLISHABLE_KEY as string}>
          <RootProvider theme={{ enabled: true }}>{children}</RootProvider>
        </ProvidersWrapper>
      </body>
    </html>
  );
}



---
File: /docs/app/logo.tsx
---

import Image from "next/image";

export function Logo() {

  return (
    // <div className="w-[--fd-sidebar-width] flex items-center justify-center gap-1 ml-[-12px]">
    <div className="flex items-center justify-center gap-1">
      <Image src={"/copilotkit-logo-light.png"} width={120} height={40} alt="Logo" className="block dark:hidden" />
      <Image src={"/copilotkit-logo-dark.png"} width={120} height={40} alt="Logo" className="hidden dark:block" />
      <div className="text-md font-medium">Docs</div>
    </div>
  )
  
}


---
File: /docs/app/sitemap.ts
---

import type { MetadataRoute } from 'next';
import { source } from "./source";

export const revalidate = false;

const baseUrl =
  process.env.NODE_ENV === 'development' || !process.env.VERCEL_URL
    ? new URL('http://localhost:3000')
    : new URL(`https://${process.env.VERCEL_URL}`);

export default function sitemap(): MetadataRoute.Sitemap {
  const url = (path: string): string => new URL(path, baseUrl).toString();

  return [
    {
      url: url('/'),
      changeFrequency: 'monthly',
      priority: 1,
    },
    ...source.getPages().map<MetadataRoute.Sitemap[number]>((page) => ({
      url: url(page.url),
      lastModified: page.data.lastModified
        ? new Date(page.data.lastModified)
        : undefined,
      changeFrequency: 'weekly',
      priority: 0.5,
    })),
  ];
}



---
File: /docs/app/source.ts
---

import { docs, meta } from '@/.source';
import { createMDXSource } from 'fumadocs-mdx';
import { loader } from 'fumadocs-core/source';
import { icon } from "@/lib/icons";

export const source = loader({
  baseUrl: '/',
  source: createMDXSource(docs, meta),
  icon,
});



---
File: /docs/components/layout/top-bar.tsx
---

"use client";
import { SearchIcon } from "lucide-react";

export function TopBar() {
  return (
    <>
      <div className="p-2 h-[60px] hidden lg:block justify-center absolute w-[calc(100vw-var(--fd-sidebar-width)-20px)] ml-[var(--fd-sidebar-width)]">
        <div className="flex justify-center">
          <SearchToggle />
        </div>
      </div>
    </>
  );
}

export function SearchToggle() {
  return (
    <div onClick={toggleSearch} className="cursor-pointer h-10 absolute w-[400px] inline-flex items-center gap-2 border bg-fd-secondary/50 p-1.5 text-sm text-fd-muted-foreground transition-colors hover:bg-fd-accent hover:text-fd-accent-foreground rounded-lg max-md:hidden">
      <SearchIcon className="w-4 h-4" />
      Search
      <div className="ms-auto inline-flex gap-0.5">
        <kbd className="rounded-md border bg-fd-background px-1.5">⌘</kbd>
        <kbd className="rounded-md border bg-fd-background px-1.5">K</kbd>
      </div>
    </div>
  );
}

const toggleSearch = () => {
  const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
  document.dispatchEvent(
    new KeyboardEvent("keydown", {
      key: "k",
      metaKey: isMac,
      ctrlKey: !isMac,
      bubbles: true,
    })
  );
};



---
File: /docs/components/react/coagents/coagents-enterprise-cta.tsx
---

import React from "react";
import Link from "next/link";

export function CoAgentsEnterpriseCTA() {
  return (
    <div className="mt-4 mb-4 ring-1 ring-indigo-200 selected bg-gradient-to-r from-indigo-100/80 to-purple-100 shadow-lg rounded-lg p-5 space-y-2 relative overflow-hidden">
      <p className="text-lg mt-0 font-medium">
        Want to Run CoAgents in Production?
      </p>
      <p className="text-sm text-neutral-600 z-1">
        We offer tailored solutions for Enterprise customers. We'd be happy to
        support you with custom use cases, deploying and scaling CoAgents in
        production.
      </p>
      <p>
        <Link
          href="https://calendly.com/atai_/copilotkit"
          target="_blank"
          className="block mt-3 no-underline"
        >
          <button className="bg-indigo-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 mt-2 font-medium">
            <span>Let's Talk</span>
          </button>
        </Link>
      </p>
      <p className="absolute bottom-[-40px] right-[10px] text-[150px] z-0 opacity-15">
        🪁
      </p>
    </div>
  );
}



---
File: /docs/components/react/coagents/coagents-features.tsx
---

"use client"

import { useTailoredContent } from "@/lib/hooks/use-tailored-content";
import cn from "classnames";
import { useEffect, useState } from "react";
import { AiOutlineRobot as GenerativeUiIcon } from "react-icons/ai";
import { TbActivityHeartbeat as StreamAgentStateIcon } from "react-icons/tb";
import { IoShareSocialOutline as ShareAgentStateIcon } from "react-icons/io5";
import { FaQuestionCircle as AgentQAndAIcon } from "react-icons/fa";

type FeatureMode = "generative-ui" | "stream-agent-state" | "share-agent-state" | "agent-q-and-a";

export const CoAgentsFeatureToggle: React.FC<{ className?: string }> = ({ className }) => {
  const { mode, setMode } = useTailoredContent<FeatureMode>(
    ["generative-ui", "stream-agent-state", "share-agent-state", "agent-q-and-a"],
    "generative-ui"
  );
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return null;
  }

  const itemCn =
    "border p-4 rounded-md flex-1 flex flex-col items-center justify-center cursor-pointer bg-white relative overflow-hidden group transition-all";
  const selectedCn =
    "ring-1 ring-indigo-400 selected bg-gradient-to-r from-indigo-100/80 to-purple-200 shadow-lg";
  const iconCn =
    "w-7 h-7 mb-2 opacity-20 group-[.selected]:text-indigo-500 group-[.selected]:opacity-60 transition-all";

  const features: { id: FeatureMode; title: string; description: string; Icon: React.FC<React.SVGProps<SVGSVGElement>> }[] = [
    {
      id: "generative-ui",
      title: "Generative UI",
      description: "Create dynamic user interfaces with AI-generated components.",
      Icon: GenerativeUiIcon,
    },
    {
      id: "stream-agent-state",
      title: "Stream Agent State",
      description: "Real-time updates on agent activities and decision-making processes.",
      Icon: StreamAgentStateIcon,
    },
    {
      id: "share-agent-state",
      title: "Share Agent State",
      description: "Collaborate and share agent states across different sessions or users.",
      Icon: ShareAgentStateIcon,
    },
    {
      id: "agent-q-and-a",
      title: "Agent Q&A",
      description: "Interactive question and answer sessions with AI agents.",
      Icon: AgentQAndAIcon,
    },
  ];

  return (
    <div className={cn("coagents-features-wrapper mt-4", className)}>
      <div className="grid grid-cols-2 md:grid-cols-4 gap-3 my-2 w-full">
        {features.map((feature) => (
          <div
            key={feature.id}
            className={cn(itemCn, mode === feature.id && selectedCn)}
            onClick={() => setMode(feature.id)}
          >
            <feature.Icon className={cn(iconCn, mode === feature.id && "text-indigo-500")} />
            <p className="font-semibold text-sm md:text-base text-center">{feature.title}</p>
            <p className="text-xs text-center hidden md:block">{feature.description}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

const FeatureContent: React.FC<{
  children: React.ReactNode;
  className?: string;
  mode: FeatureMode;
}> = ({ children, className, mode }) => {
  const { mode: currentMode } = useTailoredContent<FeatureMode>(
    ["generative-ui", "stream-agent-state", "share-agent-state", "agent-q-and-a"],
    "generative-ui"
  );
  
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return null;
  }

  return (
    <div
      className={cn(
        "feature-content mt-6",
        currentMode !== mode && "hidden",
        className
      )}
    >
      {children}
    </div>
  );
};

export const CoAgentsFeatureRender: React.FC<{ children: React.ReactNode; className?: string, feature: "generative-ui" | "stream-agent-state" | "share-agent-state" | "agent-q-and-a" }> = (props) => (
  <FeatureContent {...props} mode={props.feature} />
);



---
File: /docs/components/react/copilotkit-css.tsx
---

"use client";

import React from "react";
import { Frame } from "./frame";

export function CopilotKitCSS() {
  return (
    <style suppressHydrationWarning>
      {`
/* src/css/colors.css */
html {
  --copilot-kit-primary-color: rgb(59 130 246);
  --copilot-kit-contrast-color: rgb(255 255 255);
  --copilot-kit-secondary-color: rgb(243 244 246);
  --copilot-kit-secondary-contrast-color: rgb(0 0 0);
  --copilot-kit-background-color: rgb(255 255 255);
  --copilot-kit-muted-color: rgb(106 106 106);
  --copilot-kit-separator-color: rgba(0, 0, 0, 0.08);
  --copilot-kit-scrollbar-color: rgba(0, 0, 0, 0.2);
  --copilot-kit-response-button-color: #333;
  --copilot-kit-response-button-background-color: #fff;
}

/* src/css/popup.css */
.copilotKitPopup {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
}
.copilotKitPopup svg {
  display: inline-block;
  vertical-align: middle;
}

/* src/css/sidebar.css */
.copilotKitSidebar {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
}
.copilotKitSidebar svg {
  display: inline-block;
  vertical-align: middle;
}
.copilotKitSidebarContentWrapper {
  overflow: visible;
  margin-right: 0px;
  transition: margin-right 0.3s ease;
}
@media (min-width: 640px) {
  .copilotKitSidebarContentWrapper.sidebarExpanded {
    margin-right: 28rem;
  }
}

/* src/css/button.css */
.copilotKitButton {
  width: 3.5rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  outline: none;
  position: relative;
  transform: scale(1);
  transition: transform 200ms;
  background-color: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  cursor: pointer;
}
.copilotKitButton:hover {
  transform: scale(1.1);
}
.copilotKitButton:active {
  transform: scale(0.75);
}
.copilotKitButtonIcon {
  transition: opacity 100ms, transform 300ms;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.copilotKitButton.open .copilotKitButtonIconOpen {
  transform: translate(-50%, -50%) scale(0) rotate(90deg);
  opacity: 0;
}
.copilotKitButton.open .copilotKitButtonIconClose {
  transform: translate(-50%, -50%) scale(1) rotate(0deg);
  opacity: 1;
}
.copilotKitButton:not(.open) .copilotKitButtonIconOpen {
  transform: translate(-50%, -50%) scale(1) rotate(0deg);
  opacity: 1;
}
.copilotKitButton:not(.open) .copilotKitButtonIconClose {
  transform: translate(-50%, -50%) scale(0) rotate(-90deg);
  opacity: 0;
}

/* src/css/header.css */
.copilotKitHeader {
  height: 56px;
  font-weight: 500;
  display: flex;
  justify-content: center;
  align-items: center;  
  position: relative;
  background-color: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom: 1px solid var(--copilot-kit-separator-color);
}
.copilotKitSidebar .copilotKitHeader {
  border-radius: 0;
}
@media (min-width: 640px) {
  .copilotKitHeader {
    padding-left: 24px;
    padding-right: 24px;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
  }
}
.copilotKitHeader button {
  border: 0;
  padding: 0px;
  position: absolute;
  top: 50%;
  right: 16px;
  transform: translateY(-50%);
  outline: none;
  color: var(--copilot-kit-contrast-color);
  background-color: transparent;
  cursor: pointer;
}
.copilotKitHeader button:focus {
  outline: none;
}

/* src/css/input.css */
.copilotKitInput {
  border-top: 1px solid var(--copilot-kit-separator-color);
  padding-left: 2rem;
  padding-right: 1rem;
  padding-top: 1rem;
  padding-bottom: 1rem;
  display: flex;
  align-items: center;
  cursor: text;
  position: relative;
  border-bottom-left-radius: 0.75rem;
  border-bottom-right-radius: 0.75rem;
  background-color: var(--copilot-kit-background-color);
}

.copilotKitInput .copilotKitInputControls button {
  padding: 0.25rem;
  cursor: pointer;
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
  transform: scale(1);
  color: rgba(0, 0, 0, 0.25);
  -webkit-appearance: button;
  appearance: button;
  background-color: transparent;
  background-image: none;
  text-transform: none;
  font-family: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  border: 0;
  margin: 0;
  text-indent: 0px;
  text-shadow: none;
  display: inline-block;
  text-align: center;
  margin-left: 0.5rem;
}
.copilotKitInput .copilotKitInputControls button:not([disabled]) {
  color: var(--copilot-kit-primary-color);
}
.copilotKitInput .copilotKitInputControls button:not([disabled]):hover {
  transform: scale(1.1);
}
.copilotKitInput .copilotKitInputControls button[disabled] {
  color: var(--copilot-kit-muted-color);
}
.copilotKitInputControls {
  display: flex;
}
.copilotKitInput textarea {
  flex: 1;
  outline: 2px solid transparent;
  outline-offset: 2px;
  resize: none;
  white-space: pre-wrap;
  overflow-wrap: break-word;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  cursor: text;
  font-size: 0.875rem;
  line-height: 1.25rem;
  margin: 0;
  padding: 0;
  font-family: inherit;
  font-weight: inherit;
  color: var(--copilot-kit-secondary-contrast-color);
  border: 0px;
  background-color: var(--copilot-kit-background-color);
}
.copilotKitInput textarea::placeholder {
  color: var(--copilot-kit-muted-color);
  opacity: 1;
}
.copilotKitInput .copilotKitInputControls button.copilotKitPushToTalkRecording {
  background-color: red;
  color: white;
  border-radius: 50%;
  animation: copilotKitPulseAnimation 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* src/css/messages.css */
.copilotKitMessages {
  overflow-y: scroll;
  flex: 1;
  padding: 1rem 2rem;
  display: flex;
  flex-direction: column;
  background-color: var(--copilot-kit-background-color);
}
.copilotKitMessages::-webkit-scrollbar {
  width: 9px;
}
.copilotKitMessages::-webkit-scrollbar-thumb {
  background-color: var(--copilot-kit-scrollbar-color);
  border-radius: 10rem;
  border: 2px solid var(--copilot-kit-background-color);
}
.copilotKitMessages::-webkit-scrollbar-track-piece:start {
  background: transparent;
}
.copilotKitMessages::-webkit-scrollbar-track-piece:end {
  background: transparent;
}
.copilotKitMessage {
  border-radius: 0.5rem;
  padding: 1rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  overflow-wrap: break-word;
  max-width: 80%;
  margin-bottom: 0.5rem;
}
.copilotKitMessage.copilotKitUserMessage {
  background: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
  margin-left: auto;
  white-space: pre-wrap;
}
.copilotKitMessage.copilotKitAssistantMessage {
  background: var(--copilot-kit-secondary-color);
  color: var(--copilot-kit-secondary-contrast-color);
  margin-right: auto;
}
.copilotKitMessage.copilotKitUserMessage
  + .copilotKitMessage.copilotKitAssistantMessage {
  margin-top: 1.5rem;
}
.copilotKitMessage.copilotKitAssistantMessage
  + .copilotKitMessage.copilotKitUserMessage {
  margin-top: 1.5rem;
}
.copilotKitCustomAssistantMessage {
  margin-top: 1.5rem;
  margin-bottom: 1.5rem;
}
.copilotKitMessage .inProgressLabel {
  margin-left: 10px;
}
.copilotKitMessages footer {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

/* src/css/window.css */
.copilotKitWindow {
  position: fixed;
  inset: 0px;
  transform-origin: bottom;
  border-color: rgb(229 231 235);
  background-color: rgb(255 255 255);
  border-radius: 0.75rem;
  box-shadow: rgba(0, 0, 0, 0.16) 0px 5px 40px;
  flex-direction: column;
  transition: opacity 100ms ease-out, transform 200ms ease-out;
  opacity: 0;
  transform: scale(0.95) translateY(20px);
  display: flex;
  pointer-events: none;
}
.copilotKitSidebar .copilotKitWindow {
  border-radius: 0;
  opacity: 1;
  transform: translateX(100%);
}
.copilotKitWindow.open {
  opacity: 1;
  transform: scale(1) translateY(0);
  pointer-events: auto;
}
.copilotKitSidebar .copilotKitWindow.open {
  transform: translateX(0);
}
@media (min-width: 640px) {
  .copilotKitWindow {
    transform-origin: bottom right;
    bottom: 5rem;
    right: 1rem;
    top: auto;
    left: auto;
    border-width: 0px;
    margin-bottom: 1rem;
    width: 24rem;
    height: 600px;
    min-height: 200px;
    max-height: calc(100% - 6rem);
  }
  .copilotKitSidebar .copilotKitWindow {
    bottom: 0;
    right: 0;
    top: auto;
    left: auto;
    width: 28rem;
    min-height: 100%;
    margin-bottom: 0;
    max-height: none;
  }
}

/* src/css/animations.css */
.copilotKitActivityDot1 {
  animation: copilotKitActivityDotsAnimation 1.05s infinite;
}
.copilotKitActivityDot2 {
  animation-delay: 0.1s;
}
.copilotKitActivityDot3 {
  animation-delay: 0.2s;
}
@keyframes copilotKitActivityDotsAnimation {
  0%,
  57.14% {
    animation-timing-function: cubic-bezier(0.33, 0.66, 0.66, 1);
    transform: translate(0);
  }
  28.57% {
    animation-timing-function: cubic-bezier(0.33, 0, 0.66, 0.33);
    transform: translateY(-6px);
  }
  100% {
    transform: translate(0);
  }
}
@keyframes copilotKitSpinAnimation {
  to {
    transform: rotate(360deg);
  }
}
@keyframes copilotKitPulseAnimation {
  50% {
    opacity: 0.5;
  }
}

/* src/css/response.css */
.copilotKitResponseButton {
  background-color: var(--copilot-kit-response-button-background-color);
  border: 1px solid var(--copilot-kit-separator-color);
  border-radius: 4px;
  color: var(--copilot-kit-response-button-color);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  height: 32px;
  line-height: 30px;
  margin: 0;
  padding: 0 16px;
  text-align: center;
  text-decoration: none;
  text-transform: none;
  white-space: nowrap;
  margin-top: 15px;
}
.copilotKitResponseButton:hover {
  filter: brightness(95%);
}
.copilotKitResponseButton span {
  margin-right: 0.5rem;
}

/* src/css/markdown.css */
.copilotKitMarkdown h1,
.copilotKitMarkdown h2,
.copilotKitMarkdown h3,
.copilotKitMarkdown h4,
.copilotKitMarkdown h5,
.copilotKitMarkdown h6 {
  font-weight: bold;
  line-height: 1.2;
}
.copilotKitMarkdown h1:not(:last-child),
.copilotKitMarkdown h2:not(:last-child),
.copilotKitMarkdown h3:not(:last-child),
.copilotKitMarkdown h4:not(:last-child),
.copilotKitMarkdown h5:not(:last-child),
.copilotKitMarkdown h6:not(:last-child) {
  margin-bottom: 1rem;
}
.copilotKitMarkdown h1 {
  font-size: 1.5em;
}
.copilotKitMarkdown h2 {
  font-size: 1.25em;
  font-weight: 600;
}
.copilotKitMarkdown h3 {
  font-size: 1.1em;
}
.copilotKitMarkdown h4 {
  font-size: 1em;
}
.copilotKitMarkdown h5 {
  font-size: 0.9em;
}
.copilotKitMarkdown h6 {
  font-size: 0.8em;
}
.copilotKitMarkdown p:not(:last-child) {
  margin-bottom: 1.25em;
}
.copilotKitMarkdown pre:not(:last-child) {
  margin-bottom: 1.25em;
}
.copilotKitMarkdown blockquote {
  border-color: rgb(142, 142, 160);
  border-left-width: 2px;
  border-left-style: solid;
  line-height: 1.2;
  padding-left: 10px;
}
.copilotKitMarkdown blockquote p {
  padding: 0.7em 0;
}
.copilotKitMarkdown ul {
  list-style-type: disc;
  padding-left: 20px;
  overflow: visible;
}
.copilotKitMarkdown li {
  list-style-type: inherit;
  list-style-position: outside;
  margin-left: 0;
  padding-left: 0;
  position: relative;
  overflow: visible;
}
.copilotKitCodeBlock {
  position: relative;
  width: 100%;
  background-color: rgb(9 9 11);
  border-radius: 0.375rem;
}
.copilotKitCodeBlockToolbar {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  background-color: rgb(39 39 42);
  padding-left: 1rem;
  padding-top: 0.09rem;
  padding-bottom: 0.09rem;
  color: rgb(228, 228, 228);
  border-top-left-radius: 0.375rem;
  border-top-right-radius: 0.375rem;
  font-family: sans-serif;
}
.copilotKitCodeBlockToolbarLanguage {
  font-size: 0.75rem;
  line-height: 1rem;
  text-transform: lowercase;
}
.copilotKitCodeBlockToolbarButtons {
  display: flex;
  align-items: center;
  margin-right: 0.25rem;
  margin-left: 0.25rem;
}
.copilotKitCodeBlockToolbarButton {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 500;
  height: 2.5rem;
  width: 2.5rem;
  padding: 3px;
  margin: 2px;
}
.copilotKitCodeBlockToolbarButton:hover {
  background-color: rgb(55, 55, 58);
}

/* src/css/suggestions.css */
.copilotKitMessages footer .suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.copilotKitMessages footer h6 {
  font-weight: 500;
  font-size: 0.7rem;
  margin-bottom: 8px;
}
.copilotKitMessages footer .suggestions .suggestion {
  padding: 8px 12px;
  font-size: 0.7rem;
  border-radius: 0.5rem;
  background: var(--copilot-kit-primary-color);
  color: var(--copilot-kit-contrast-color);
}
.copilotKitMessages footer .suggestions button {
  transition: transform 0.3s ease;
}
.copilotKitMessages footer .suggestions button:not(:disabled):hover {
  transform: scale(1.05);
}
.copilotKitMessages footer .suggestions button:disabled {
  cursor: wait;
}
.copilotKitMessages footer .suggestions button svg {
  margin-right: 6px;
}

/* src/css/panel.css */
.copilotKitChat {
  z-index: 30;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  touch-action: manipulation;
  display: flex;
  flex-direction: column;
}
.copilotKitChat svg {
  display: inline-block;
  vertical-align: middle;
}
.copilotKitChat .copilotKitMessages {
  flex-grow: 1;
}
.tooltip {
  display: none;
  position: absolute;
  background-color: white;
  border: 1px solid #ddd;
  color: #222;
  padding: 15px;
  border-radius: 5px;
  z-index: 1000;
  font-size: 13px;
  width: 350px;
}
.tooltip b {
  color: rgb(59, 130, 246);
  font-family: monospace;
}

.copilotKitInput {
  cursor: pointer;
}

.copilotKitInput input {
  flex: 1; /* Allow textarea to take up remaining space */
  outline: 2px solid transparent;
  outline-offset: 2px;
  resize: none;
  white-space: pre-wrap;
  overflow-wrap: break-word;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  cursor: pointer;
  font-size: 0.875rem;
  line-height: 1.25rem;
  margin: 0;
  padding: 0;
  font-family: inherit;
  font-weight: inherit;
  color: var(--copilot-kit-secondary-contrast-color);
  border: 0px;
  background-color: var(--copilot-kit-background-color);
}

.copilotKitHeader:hover {
  box-shadow: 0 0 0 2px rgb(7, 201, 131);
}

.copilotKitAssistantMessage:hover {
  box-shadow: 0 0 0 2px rgb(7, 201, 131);
}

.copilotKitUserMessage:hover {
  box-shadow: 0 0 0 2px rgb(7, 201, 131);
}

.micButton:hover {
  box-shadow: 0 0 0 2px rgb(7, 201, 131);
  border-radius: 5px;
}

.sendButton:hover {
  box-shadow: 0 0 0 2px rgb(7, 201, 131);
  border-radius: 5px;
}
    `}
    </style>
  );
}

export const handleMouseMove = (e: any) => {
  const tooltip: any = document.querySelector(".tooltip");
  tooltip.style.display = "block";
  const rect = tooltip.parentElement.getBoundingClientRect();
  tooltip.style.left = `${e.clientX - rect.left + 15}px`;
  tooltip.style.top = `${e.clientY - rect.top + 15}px`;

  let element = e.target;

  while (element && element !== document.body) {
    console.log(element.classList);
    if (element.classList.contains("copilotKitHeader")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-primary-color</b>: Header background color.<br/><br/><b>--copilot-kit-contrast-color</b>: Header foreground color.";
      return;
    } else if (element.classList.contains("copilotKitAssistantMessage")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-secondary-color</b>: Assistant message background color.<br/><br/><b>--copilot-kit-secondary-contrast-color</b>: Assistant message foreground color.";
      return;
    } else if (element.classList.contains("copilotKitUserMessage")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-primary-color</b>: User message background color.<br/><br/><b>--copilot-kit-contrast-color</b>: User message foreground color.";
      return;
    } else if (element.classList.contains("copilotKitMessages")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-background-color</b>: Chat window background color.<br/><br/><b>--copilot-kit-scrollbar-color</b>: Chat window scrollbar color.<br/><br/><b>--copilot-kit-separator-color</b>: Bottom separator color.";
      return;
    } else if (element.classList.contains("micButton")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-primary-color</b>: Active button color";
      return;
    } else if (element.classList.contains("sendButton")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-muted-color</b>: Muted button color";
      return;
    } else if (element.classList.contains("copilotKitInput")) {
      tooltip.innerHTML =
        "<b>--copilot-kit-muted-color</b>: Placeholder color.";
      return;
    }
    element = element.parentElement;
  }

  tooltip.style.display = "none";
};

export const handleMouseLeave = (e: any) => {
  const tooltip: any = document.querySelector(".tooltip");
  tooltip.style.display = "none";
};

export const InteractiveCSSInspector = () => {
  return (
    <>
      <div className="tooltip">Close CopilotKit</div>
      <Frame className="">
        <div
          className=""
          onMouseMove={handleMouseMove}
          onMouseLeave={handleMouseLeave}
          style={{
            width: "384px",
            cursor: "pointer",
          }}
        >
          <div className="open">
            <div className="copilotKitHeader">
              <div>CopilotKit</div>
              <button aria-label="Close">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  strokeWidth="1.5"
                  stroke="currentColor"
                  width={24}
                  height={24}
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>
            <div className="copilotKitMessages">
              <div className="copilotKitMessage copilotKitAssistantMessage">
                Hi you! 👋 I can help you create a presentation on any topic.
              </div>
              <div className="copilotKitMessage copilotKitUserMessage">
                Hello CopilotKit!
              </div>
            </div>
            <div className="copilotKitInput">
              <input
                placeholder="Type a message..."
                style={{
                  overflow: "auto",
                  resize: "none",
                  maxHeight: 100,
                  height: 20,
                }}
                defaultValue={""}
                disabled={false}
              />
              <div className="copilotKitInputControls">
                <button className="micButton">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    strokeWidth="1.5"
                    stroke="currentColor"
                    className="w-6 h-6"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      d="M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 0 1-3-3V4.5a3 3 0 1 1 6 0v8.25a3 3 0 0 1-3 3Z"
                    />
                  </svg>
                </button>
                <button className="sendButton" disabled={false}>
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    width={24}
                    height={24}
                    strokeWidth="1.5"
                    stroke="currentColor"
                    style={{}}
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5"
                    />
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>
      </Frame>
    </>
  );
};



---
File: /docs/components/react/dynamic-content-wrapper.tsx
---

"use client"
import React from "react";
import { TailoredContentProvider } from "@/lib/hooks/use-tailored-content";

export function DynamicContentWrapper({ children }: { children: React.ReactNode }) {
  return (
    <TailoredContentProvider>
      {children}
    </TailoredContentProvider>
  );
}


---
File: /docs/components/react/frame.tsx
---

import React from "react";

export function Frame({
  children,
  className,
  description,
}: {
  children: React.ReactNode;
  className: string;
  description?: string;
}) {
  return (
    <>
      <div
        className={`flex space-x-4 w-full mx-auto justify-center ${className}`}
      >
        {React.Children.map(children, (child) =>
          React.isValidElement(child)
            ? React.cloneElement(child as React.ReactElement<any>, {
                className: `border border-neutral-200 rounded-md shadow-lg bg-white ${
                  child.props.className || ""
                }`,
              })
            : child
        )}
      </div>
      {description && <p className="text-sm text-neutral-500 text-center">{description}</p>}
    </>
  );
}



---
File: /docs/components/react/property-reference.tsx
---

"use client"

import React from "react";
import { IoSparklesSharp } from "react-icons/io5";
import { FaCaretRight, FaCaretDown } from "react-icons/fa";

type Props = {
  name: string;
  type: string;
  required?: boolean;
  deprecated?: boolean;
  children?: React.ReactNode;
  cloudOnly?: boolean;
  default?: string;
  collapsable?: boolean;
};

export function PropertyReference({
  children,
  name,
  type,
  required = false,
  deprecated = false,
  cloudOnly = false,
  default: defaultValue,
  collapsable = false,
}: Props) {
  const [isCollapsed, setIsCollapsed] = React.useState(
    collapsable ? true : false
  );

  const enhancedChildren = React.Children.map(children, (child) => {
    if (
      React.isValidElement(child) &&
      (child.type as any).name === "PropertyReference"
    ) {
      return React.cloneElement(child, { collapsable: true } as Props);
    }
    return child;
  });

  const collapseClassName = `${isCollapsed ? "hidden" : ""}`;

  const renderChips = () => {
    return (
      <>
        <span className="font-mono text-neutral-600 py-1 px-2 rounded-md bg-neutral-100 text-xs font-semibold">
          {type}
        </span>
        {required && (
          <span className="font-mono text-neutral-600 py-1 px-2 rounded-md bg-red-200 text-xs font-semibold">
            required
          </span>
        )}
        {deprecated && (
          <span className="font-mono text-neutral-600 py-1 px-2 rounded-md bg-yellow-200 text-xs font-semibold">
            deprecated
          </span>
        )}
      </>
    );
  };

  return (
    <div className="ck-property-reference py-4 space-y-3 text-sm">
      <div className="flex justify-betweem items-center">
        <div className="flex-1 space-x-3">
          {collapsable ? (
            <button
              onClick={() => setIsCollapsed(!isCollapsed)}
              className="flex gap-x-2 items-center font-mono font-semibold text-indigo-600"
            >
              {isCollapsed ? <FaCaretRight /> : <FaCaretDown />}
              {name}
              {renderChips()}
            </button>
          ) : (
            <span className="flex gap-x-2 items-center font-mono font-semibold text-indigo-600">
              {name}
              {renderChips()}
            </span>
          )}
        </div>

        <div>
          {cloudOnly && (
            <span className="flex space-x-1 items-center justify-center bg-indigo-500 text-white py-1 px-2 rounded-md text-xs font-semibold">
              <IoSparklesSharp className="w-3 h-3" />
              <span>COPILOT CLOUD</span>
            </span>
          )}
        </div>
      </div>
      <div className={`space-y-1 ${collapseClassName}`}>
        {defaultValue !== undefined && (
          <div>
            <span className="font-semibold">Default:</span>{" "}
            <span className="font-mono text-neutral-500">
              {typeof defaultValue === "string"
                ? `"${defaultValue}"`
                : `${defaultValue}`}
            </span>
          </div>
        )}
        <div>{enhancedChildren}</div>
      </div>
    </div>
  );
}



---
File: /docs/components/react/select-llm-provider.tsx
---

"use client";

import { useState } from "react";
import { useLocalStorage } from "usehooks-ts";

export function SelectLLMProvider() {
  const [llmProvider, setLLMProvider] = useLocalStorage<string | null>("llmProvider", "openai");
  // const [llmProvider, setLLMProvider] = useState<string | null>("openai");

  return (
    <div className="flex gap-2">
      <button onClick={() => setLLMProvider("openai")} className={`${llmProvider === "openai" ? "bg-blue-500" : "bg-gray-200"}`}>OpenAI</button>
      <button onClick={() => setLLMProvider("anthropic")} className={`${llmProvider === "anthropic" ? "bg-blue-500" : "bg-gray-200"}`}>Anthropic</button>
    </div>
  )
}


---
File: /docs/components/react/subdocs-menu.tsx
---

"use client";
import { ChevronDown } from "lucide-react";
import {
  type HTMLAttributes,
  type ReactNode,
  useCallback,
  useMemo,
  useState,
} from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { useSidebar } from "fumadocs-ui/provider";

export function isActive(
  url: string,
  pathname: string,
  nested = true,
  root = false
): boolean {
  const isActive =
    url === pathname || (nested && pathname.startsWith(root ? url : `${url}/`));
  return isActive;
}

export interface Option {
  /**
   * Redirect URL of the folder, usually the index page
   */
  url: string;

  icon?: ReactNode;
  title: ReactNode;
  description?: ReactNode;
  bgGradient: string;
  selectedBorder: string;
  props?: HTMLAttributes<HTMLElement>;
}

export function SubdocsMenu({
  options,
  ...props
}: {
  options: Option[];
} & HTMLAttributes<HTMLButtonElement>): React.ReactElement {
  const { closeOnRedirect } = useSidebar();
  const pathname = usePathname();
  const selected = useMemo(() => {
    // First, try all non-root options
    const nonRootOptions = options.filter((item) => item.url !== "/");
    const activeNonRootOption = nonRootOptions.find((item) =>
      isActive(item.url, pathname, true)
    );

    if (activeNonRootOption) {
      return activeNonRootOption;
    }

    // If no non-root options are active, try the root options ("/*")
    return options.find((item) => isActive(item.url, pathname, true, true));
  }, [options, pathname]);

  const onClick = useCallback(() => {
    closeOnRedirect.current = false;
  }, [closeOnRedirect]);

  return (
    <div className="flex flex-col gap-2 border-b pb-4 pt-2 px-1">
      {options.map((item) => (
        <Link
          key={item.url}
          href={item.url}
          onClick={onClick}
          {...item.props}
          className={cn(
            "p-1 flex flex-row gap-3 items-center cursor-pointer group opacity-70 hover:opacity-100",
            selected === item && "opacity-100",
            item.props?.className
          )}
        >
          <div
            className={cn(
              "rounded-sm p-1.5",
              item.bgGradient,
              selected !== item && "",
              selected === item && `${item.selectedBorder} ring-2`
            )}
          >
            {item.icon}
          </div>
          <div className="font-medium">{item.title}</div>
        </Link>
      ))}
    </div>
  );
}



---
File: /docs/components/react/test-react-component.tsx
---

import React from "react";

export function TestReactComponent() {
  return <div>Test Componentzzz</div>
}


---
File: /docs/components/react/youtube-video.tsx
---

"use client"

import YouTube from "react-youtube";

export function YouTubeVideo({
  videoId,
  defaultPlaybackRate = 1.0,
}: {
  videoId: string;
  defaultPlaybackRate?: number;
}) {
  const onPlayerReady: YouTube["props"]["onReady"] = (event) => {
    const player = event.target;

    if (defaultPlaybackRate) {
      player.setPlaybackRate(defaultPlaybackRate);
    }
  };

  const opts: YouTube["props"]["opts"] = {
    playerVars: {},
  };

  return (
    <YouTube
      videoId={videoId}
      className="max-w-[600px] w-full rounded-lg"
      opts={opts}
      onReady={onPlayerReady}
    />
  );
}


---
File: /docs/components/ui/button.tsx
---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



---
File: /docs/lib/hooks/use-rb2b.tsx
---

"use client"

import { useEffect } from "react";

export function useRB2B() {
  useEffect(() => {
    const RB2B_ID = process.env.RB2B_ID;

    if (!RB2B_ID) {
      return;
    }

    // @ts-ignore
    !(function () {
      var reb2b = ((window as any).reb2b = (window as any).reb2b || []);
      if (reb2b.invoked) return;
      reb2b.invoked = true;
      reb2b.methods = ["identify", "collect"];
      reb2b.factory = function (method: any) {
        return function () {
          var args = Array.prototype.slice.call(arguments);
          args.unshift(method);
          reb2b.push(args);
          return reb2b;
        };
      };
      for (var i = 0; i < reb2b.methods.length; i++) {
        var key = reb2b.methods[i];
        reb2b[key] = reb2b.factory(key);
      }
      reb2b.load = function (key: any) {
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.async = true;
        script.src =
          "https://s3-us-west-2.amazonaws.com/b2bjsstore/b/" +
          key +
          "/reb2b.js.gz";
        var first = document.getElementsByTagName("script")[0];
        first.parentNode?.insertBefore(script, first);
      };
      reb2b.SNIPPET_VERSION = "1.0.1";
      reb2b.load(RB2B_ID);
    })();
  }, []);
}



---
File: /docs/lib/hooks/use-tailored-content.tsx
---

import React from "react";
import { createContext, useContext, useEffect, ReactNode } from "react";
import { useLocalStorage } from "usehooks-ts";

type TailoredContentOption = string;

type TailoredContentContextType<T extends TailoredContentOption> = {
  mode: T;
  setMode: any;
};

const TailoredContentContext = createContext<
  TailoredContentContextType<TailoredContentOption> | undefined
>(undefined);

export const TailoredContentProvider = <T extends TailoredContentOption>({
  children,
}: {
  children: ReactNode;
}) => {
  const [mode, setMode] = useLocalStorage<T>(
    "copilotkit-tailored-content",
    "empty" as T
  );

  return (
    <TailoredContentContext.Provider value={{ mode, setMode }}>
      {children}
    </TailoredContentContext.Provider>
  );
};

export const useTailoredContent = <T extends TailoredContentOption>(
  options: T[],
  defaultOption: T
): TailoredContentContextType<T> => {
  const context = useContext(TailoredContentContext);
  if (context === undefined) {
    throw new Error(
      "useTailoredContent must be used within a TailoredContentProvider"
    );
  }

  useEffect(() => {
    if (!options.includes(context.mode as any)) {
      context.setMode(defaultOption);
    }
  }, [context.mode]);

  return context as TailoredContentContextType<T>;
};



---
File: /docs/lib/icons/custom-icons.tsx
---

import { FaReact } from "react-icons/fa";
import { HiOutlineServerStack } from "react-icons/hi2";
import { LuBrush, LuZap, LuGlobe } from "react-icons/lu";

export const customIcons = {
  react: FaReact,
  server: HiOutlineServerStack,
  zap: LuZap,
  brush: LuBrush,
  globe: LuGlobe,
}



---
File: /docs/lib/icons/index.tsx
---

import { icons as lucideIcons } from "lucide-react";
import { createElement } from "react";
import { customIcons } from "./custom-icons";

export function icon(icon: any) {
  if (!icon) {
    return;
  }

  let iconElement: React.ReactNode = null;

  if (icon.startsWith("lucide/")) {
    const iconName = icon.split("lucide/")[1];
    if (iconName in lucideIcons)
      iconElement = createElement(
        lucideIcons[iconName as keyof typeof lucideIcons]
      );
  }

  if (icon.startsWith("custom/")) {
    const iconName = icon.split("custom/")[1];
    if (iconName in customIcons)
      iconElement = createElement(
        customIcons[iconName as keyof typeof customIcons]
      );
  }

  return (
    <div className="border border-fd-primary/10 rounded-md p-1.5 bg-gradient-to-b from-fd-muted/40 to-fd-muted/80 text-primary">
      {iconElement}
    </div>
  );
}



---
File: /docs/lib/providers/posthog-provider.tsx
---

"use client"

import { PostHogProvider as PostHogProviderBase } from "posthog-js/react";
import posthog from "posthog-js";
import { useEffect } from "react";
import { useAuth } from "@clerk/nextjs";
import { usePathname, useSearchParams } from "next/navigation";

const POSTHOG_KEY = process.env.POSTHOG_KEY;
const POSTHOG_HOST = process.env.POSTHOG_HOST;

if (typeof window !== "undefined") {
  // Get search param
  const searchParams = new URLSearchParams(window.location.search);
  const sessionId = searchParams.get("session_id");
  
  if (POSTHOG_KEY && POSTHOG_HOST) {
    posthog.init(POSTHOG_KEY, {
      api_host: POSTHOG_HOST,
      person_profiles: "identified_only",
      bootstrap: {
        sessionID: sessionId ?? undefined,
      },
      // Enable debug mode in development
      loaded: (posthog) => {
        if (process.env.NODE_ENV === "development") posthog.debug();
      },
    });
  }
}

export function PostHogProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const sessionId = searchParams.get("session_id");
  const { userId } = useAuth();

  posthog?.set_config({
    bootstrap: {
      sessionID: sessionId ?? undefined,
    },
  });

  useEffect(() => {
    if (userId) {
      posthog?.identify(userId);
    }
  }, [userId]);

  useEffect(() => {
    if (POSTHOG_KEY && POSTHOG_HOST) {
      posthog?.capture("$pageview");
    }
  }, [pathname])

  return <PostHogProviderBase client={posthog}>{children}</PostHogProviderBase>;
}


---
File: /docs/lib/providers/providers-wrapper.tsx
---

"use client";

import React, { Suspense } from "react";
import { PostHogProvider } from "@/lib/providers/posthog-provider";
import { ClerkProvider } from "@clerk/clerk-react";
import { ScarfPixel } from "./scarf-pixel";
import { useRB2B } from "@/lib/hooks/use-rb2b";

export function ProvidersWrapper({
  children,
  clerkPublishableKey,
}: {
  children: React.ReactNode;
  clerkPublishableKey: string;
}) {
  useRB2B();

  return (
    <>
      {/* <ClerkProvider publishableKey={clerkPublishableKey}> */}
        {/* <PostHogProvider>{children}</PostHogProvider> */}
        {children}
        <ScarfPixel />
      {/* </ClerkProvider> */}
    </>
  );
}



---
File: /docs/lib/providers/scarf-pixel.tsx
---

"use client"

import React from 'react';

export function ScarfPixel() {
  const SCARF_PIXEL_ID = process.env.SCARF_PIXEL_ID;
  if (!SCARF_PIXEL_ID) return null;
  return <img referrerPolicy="no-referrer-when-downgrade" src={`https://static.scarf.sh/a.png?x-pxid=${SCARF_PIXEL_ID}`} />;
}


---
File: /docs/lib/utils.ts
---

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}




---
File: /docs/next-env.d.ts
---

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.



---
File: /docs/postcss.config.js
---

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};



---
File: /docs/props.ts
---

export type SomeProps = {
  some: string;
}


---
File: /docs/source.config.ts
---

import { defineDocs, defineConfig } from "fumadocs-mdx/config";

import {
  fileGenerator,
  remarkDocGen,
  remarkInstall,
  typescriptGenerator,
} from "fumadocs-docgen";
import { rehypeCode } from "fumadocs-core/mdx-plugins";
import {
  transformerNotationDiff,
  transformerNotationHighlight,
  transformerNotationWordHighlight,
  // ...
} from "@shikijs/transformers";
import { remarkMermaid } from '@theguild/remark-mermaid'

export const { docs, meta } = defineDocs();

export default defineConfig({
  mdxOptions: {
    rehypePlugins: [
      [
        rehypeCode,
        {
          transformers: [
            transformerNotationDiff(),
            transformerNotationHighlight(),
            transformerNotationWordHighlight(),
          ],
        },
      ],
    ],
    remarkPlugins: [
      remarkMermaid,
      [remarkInstall, { persist: { id: "package-manager" } }],
      [remarkDocGen, { generators: [typescriptGenerator(), fileGenerator()] }],
    ],
  },
});



---
File: /docs/tailwind.config.js
---

import { createPreset } from 'fumadocs-ui/tailwind-plugin';

/** @type {import('tailwindcss').Config} */
export default {
    darkMode: ['class'],
    content: [
		'./lib/icons/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './content/**/*.{md,mdx}',
    './mdx-components.{ts,tsx}',
    './node_modules/fumadocs-ui/dist/**/*.js',
  ],
  presets: [createPreset()],
    plugins: [require("tailwindcss-animate")],
    theme: {
    	extend: {
    		borderRadius: {
    			lg: 'var(--radius)',
    			md: 'calc(var(--radius) - 2px)',
    			sm: 'calc(var(--radius) - 4px)'
    		},
    		colors: {
    			background: 'hsl(var(--background))',
    			foreground: 'hsl(var(--foreground))',
    			card: {
    				DEFAULT: 'hsl(var(--card))',
    				foreground: 'hsl(var(--card-foreground))'
    			},
    			popover: {
    				DEFAULT: 'hsl(var(--popover))',
    				foreground: 'hsl(var(--popover-foreground))'
    			},
    			primary: {
    				DEFAULT: 'hsl(var(--primary))',
    				foreground: 'hsl(var(--primary-foreground))'
    			},
    			secondary: {
    				DEFAULT: 'hsl(var(--secondary))',
    				foreground: 'hsl(var(--secondary-foreground))'
    			},
    			muted: {
    				DEFAULT: 'hsl(var(--muted))',
    				foreground: 'hsl(var(--muted-foreground))'
    			},
    			accent: {
    				DEFAULT: 'hsl(var(--accent))',
    				foreground: 'hsl(var(--accent-foreground))'
    			},
    			destructive: {
    				DEFAULT: 'hsl(var(--destructive))',
    				foreground: 'hsl(var(--destructive-foreground))'
    			},
    			border: 'hsl(var(--border))',
    			input: 'hsl(var(--input))',
    			ring: 'hsl(var(--ring))',
    			chart: {
    				'1': 'hsl(var(--chart-1))',
    				'2': 'hsl(var(--chart-2))',
    				'3': 'hsl(var(--chart-3))',
    				'4': 'hsl(var(--chart-4))',
    				'5': 'hsl(var(--chart-5))'
    			}
    		}
    	}
    }
};



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/__init__.py
---




---
File: /examples/coagents-ai-researcher/agent/ai_researcher/agent.py
---

"""
This is the main entry point for the AI.
It defines the workflow graph and the entry point for the agent.
"""
# pylint: disable=line-too-long, unused-import
import json

from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

from ai_researcher.state import AgentState
from ai_researcher.steps import steps_node
from ai_researcher.search import search_node
from ai_researcher.summarize import summarize_node
from ai_researcher.extract import extract_node

def route(state):
    """Route to research nodes."""
    if not state.get("steps", None):
        return END

    current_step = next((step for step in state["steps"] if step["status"] == "pending"), None)

    if not current_step:
        return "summarize_node"

    if current_step["type"] == "search":
        return "search_node"

    raise ValueError(f"Unknown step type: {current_step['type']}")

# Define a new graph
workflow = StateGraph(AgentState)
workflow.add_node("steps_node", steps_node)
workflow.add_node("search_node", search_node)
workflow.add_node("summarize_node", summarize_node)
workflow.add_node("extract_node", extract_node)
# Chatbot
workflow.set_entry_point("steps_node")

workflow.add_conditional_edges(
    "steps_node", 
    route,
    ["summarize_node", "search_node", END]
)

workflow.add_edge("search_node", "extract_node")

workflow.add_conditional_edges(
    "extract_node",
    route,
    ["summarize_node", "search_node"]
)

workflow.add_edge("summarize_node", END)

memory = MemorySaver()
graph = workflow.compile(checkpointer=memory)



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv()

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from ai_researcher.agent import graph

app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="search_agent",
            description="Search agent.",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("ai_researcher.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/extract.py
---

"""
The extract node is responsible for extracting information from a tavily search.
"""
import json

from langchain_core.messages import HumanMessage
from langchain_core.runnables import RunnableConfig
from ai_researcher.state import AgentState
from ai_researcher.model import get_model

async def extract_node(state: AgentState, config: RunnableConfig):
    """
    The extract node is responsible for extracting information from a tavily search.
    """

    current_step = next((step for step in state["steps"] if step["status"] == "pending"), None)

    if current_step is None:
        raise ValueError("No current step")

    if current_step["type"] != "search":
        raise ValueError("Current step is not of type search")

    system_message = f"""
This step was just executed: {json.dumps(current_step)}

This is the result of the search:

Please summarize ONLY the result of the search and include all relevant information from the search and reference links.
DO NOT INCLUDE ANY EXTRA INFORMATION. ALL OF THE INFORMATION YOU ARE LOOKING FOR IS IN THE SEARCH RESULTS.

DO NOT answer the user's query yet. Just summarize the search results.

Use markdown formatting and put the references inline and the links at the end.
Like this:
This is a sentence with a reference to a source [source 1][1] and another reference [source 2][2].
[1]: http://example.com/source1 "Title of Source 1"
[2]: http://example.com/source2 "Title of Source 2"
"""

    response = await get_model().ainvoke([
        state["messages"][0],
        HumanMessage(
            content=system_message
        )
    ], config)

    current_step["result"] = response.content
    current_step["search_result"] = None
    current_step["status"] = "complete"
    current_step["updates"] = [*current_step["updates"], "Done."]

    next_step = next((step for step in state["steps"] if step["status"] == "pending"), None)
    if next_step:
        next_step["updates"] = ["Searching the web..."]

    return state



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/model.py
---

"""
This module provides a function to get a model based on the configuration.
"""
import os
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic


def get_model():
    """
    Get a model based on the environment variable.
    """
    model = os.getenv("MODEL", "openai")


    if model == "openai":
        return ChatOpenAI(temperature=0, model_name="gpt-4o")
    if model == "anthropic":
        return ChatAnthropic(temperature=0, model_name="claude-3-5-sonnet-20240620")

    raise ValueError("Invalid model specified")



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/search.py
---

"""
The search node is responsible for searching the internet for information.
"""
import json
from datetime import datetime
from langchain_core.messages import HumanMessage
from langchain_core.runnables import RunnableConfig
from langchain_community.tools import TavilySearchResults
from ai_researcher.state import AgentState
from ai_researcher.model import get_model
async def search_node(state: AgentState, config: RunnableConfig):
    """
    The search node is responsible for searching the internet for information.
    """
    tavily_tool = TavilySearchResults(
        max_results=10,
        search_depth="advanced",
        include_answer=True,
        include_raw_content=True,
        include_images=True,
    )

    current_step = next((step for step in state["steps"] if step["status"] == "pending"), None)

    if current_step is None:
        raise ValueError("No step to search for")

    if current_step["type"] != "search":
        raise ValueError("Current step is not a search step")

    instructions = f"""
This is a step in a series of steps that are being executed to answer the user's query.
These are all of the steps: {json.dumps(state["steps"])}

You are responsible for carrying out the step: {json.dumps(current_step)}

The current date is {datetime.now().strftime("%Y-%m-%d")}.

This is what you need to search for, please come up with a good search query: {current_step["description"]}
"""
    model = get_model().bind_tools(
        [tavily_tool],
        tool_choice=tavily_tool.name
    )

    response = await model.ainvoke([
        HumanMessage(
            content=instructions
        )
    ], config)

    tool_msg = tavily_tool.invoke(response.tool_calls[0])

    current_step["search_result"] = json.loads(tool_msg.content)
    current_step["updates"] = [*current_step["updates"],"Extracting information..."]

    return state



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/state.py
---

"""
This is the state definition for the AI.
It defines the state of the agent and the state of the conversation.
"""

from typing import List, TypedDict, Optional
from langgraph.graph import MessagesState

class Step(TypedDict):
    """
    Represents a step taken in the research process.
    """
    id: str
    description: str
    status: str
    type: str
    description: str
    search_result: Optional[str]
    result: Optional[str]
    updates: Optional[List[str]]

class AgentState(MessagesState):
    """
    This is the state of the agent.
    It is a subclass of the MessagesState class from langgraph.
    """
    steps: List[Step]
    answer: Optional[str]



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/steps.py
---

"""
This node is responsible for creating the steps for the research process.
"""

# pylint: disable=line-too-long

from datetime import datetime
from langchain_core.messages import HumanMessage
from langchain_core.runnables import RunnableConfig
from copilotkit.langchain import copilotkit_customize_config
from pydantic import BaseModel, Field
from ai_researcher.state import AgentState
from ai_researcher.model import get_model
class WeatherResponse(BaseModel):
    """Respond to the user with this"""

    temperature: float = Field(description="The temperature in fahrenheit")
    wind_direction: str = Field(
        description="The direction of the wind in abbreviated form"
    )
    wind_speed: float = Field(description="The speed of the wind in km/h")


class SearchStep(BaseModel):
    """Model for a search step"""

    id: str = Field(description="The id of the step. This is used to identify the step in the state. Just make sure it is unique.")
    description: str = Field(description='The description of the step, i.e. "search for information about the latest AI news"')
    status: str = Field(description='The status of the step. Always "pending".', enum=['pending'])
    type: str = Field(description='The type of step.', enum=['search'])

class SearchTool(BaseModel):
    """
    Break the user's query into smaller steps.
    Use step type "search" to search the web for information.
    Make sure to add all the steps needed to answer the user's query.
    """

    steps: list[SearchStep] = Field(description="The steps to be executed.")

async def steps_node(state: AgentState, config: RunnableConfig):
    """
    The steps node is responsible for building the steps in the research process.
    """

    config = copilotkit_customize_config(
        config,
        emit_intermediate_state=[
            {
                "state_key": "steps",
                "tool": "SearchTool",
                "tool_argument": "steps"
            },
        ]
    )

    instructions = f"""
You are a search assistant. Your task is to help the user with complex search queries by breaking the down into smaller steps.

These steps are then executed serially. In the end, a final answer is produced in markdown format.

The current date is {datetime.now().strftime("%Y-%m-%d")}.
"""

    response = await get_model().bind_tools(
        [SearchTool],
        tool_choice="SearchTool"
    ).ainvoke([
        state["messages"][0],
        HumanMessage(
            content=instructions
        ),
    ], config)

    steps = response.tool_calls[0]["args"]["steps"]

    if len(steps):
        steps[0]["updates"] = ["Searching the web..."]

    return {
        "steps": steps,
    }



---
File: /examples/coagents-ai-researcher/agent/ai_researcher/summarize.py
---

"""
The summarize node is responsible for summarizing the information.
"""

import json
from langchain_core.messages import HumanMessage
from langchain_core.runnables import RunnableConfig
from copilotkit.langchain import copilotkit_customize_config
from pydantic import BaseModel, Field
from ai_researcher.state import AgentState
from ai_researcher.model import get_model

class Reference(BaseModel):
    """Model for a reference"""

    title: str = Field(description="The title of the reference.")
    url: str = Field(description="The url of the reference.")

class SummarizeTool(BaseModel):
    """
    Summarize the final result. Make sure that the summary is complete and 
    includes all relevant information and reference links.
    """

    markdown: str = Field(
        description="""
        The markdown formatted summary of the final result. 
        If you add any headings, make sure to start at the top level (#).
        """
    )
    references: list[Reference] = Field(description="A list of references.")

async def summarize_node(state: AgentState, config: RunnableConfig):
    """
    The summarize node is responsible for summarizing the information.
    """

    config = copilotkit_customize_config(
        config,
        emit_intermediate_state=[
            {
                "state_key": "answer",
                "tool": "SummarizeTool",
            }
        ]
    )

    system_message = f"""
The system has performed a series of steps to answer the user's query.
These are all of the steps: {json.dumps(state["steps"])}

Please summarize the final result and include all relevant information and reference links.
"""

    response = await get_model().bind_tools(
        [SummarizeTool],
        tool_choice="SummarizeTool"
    ).ainvoke([
        HumanMessage(
            content=system_message
        ),
    ], config)

    return {
        "answer": response.tool_calls[0]["args"],
    }



---
File: /examples/coagents-ai-researcher/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-ai-researcher/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;
/*
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
} */



---
File: /examples/coagents-ai-researcher/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "AI Researcher",
  description: "AI Researcher",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-ai-researcher/ui/app/page.tsx
---

"use client";

import { ResearchWrapper } from "@/components/ResearchWrapper";
import { ResearchProvider } from "@/lib/research-provider";
import { CopilotKit } from "@copilotkit/react-core";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit
        runtimeUrl="/api/copilotkit"
        agent="search_agent"
      >
        <ResearchProvider>
          <ResearchWrapper />
        </ResearchProvider>
      </CopilotKit>
    </main>
  );
}




---
File: /examples/coagents-ai-researcher/ui/components/ui/accordion.tsx
---

"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger> & {
    hideChevron?: boolean;
  }
>(({ className, hideChevron = false, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-2 transition-all hover:bg-slate-100 px-2 rounded-md [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      {
        !hideChevron && (
          <ChevronDown className="h-4 w-4 mt-1 shrink-0 transition-transform duration-200" />
        )
      }
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-0 px-2 py-1", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



---
File: /examples/coagents-ai-researcher/ui/components/ui/background-beams.tsx
---

"use client";
import React from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

export const BackgroundBeams = React.memo(
  ({ className }: { className?: string }) => {
    const paths = [
      "M-380 -189C-380 -189 -312 216 152 343C616 470 684 875 684 875",
      "M-373 -197C-373 -197 -305 208 159 335C623 462 691 867 691 867",
      "M-366 -205C-366 -205 -298 200 166 327C630 454 698 859 698 859",
      "M-359 -213C-359 -213 -291 192 173 319C637 446 705 851 705 851",
      "M-352 -221C-352 -221 -284 184 180 311C644 438 712 843 712 843",
      "M-345 -229C-345 -229 -277 176 187 303C651 430 719 835 719 835",
      "M-338 -237C-338 -237 -270 168 194 295C658 422 726 827 726 827",
      "M-331 -245C-331 -245 -263 160 201 287C665 414 733 819 733 819",
      "M-324 -253C-324 -253 -256 152 208 279C672 406 740 811 740 811",
      "M-317 -261C-317 -261 -249 144 215 271C679 398 747 803 747 803",
      "M-310 -269C-310 -269 -242 136 222 263C686 390 754 795 754 795",
      "M-303 -277C-303 -277 -235 128 229 255C693 382 761 787 761 787",
      "M-296 -285C-296 -285 -228 120 236 247C700 374 768 779 768 779",
      "M-289 -293C-289 -293 -221 112 243 239C707 366 775 771 775 771",
      "M-282 -301C-282 -301 -214 104 250 231C714 358 782 763 782 763",
      "M-275 -309C-275 -309 -207 96 257 223C721 350 789 755 789 755",
      "M-268 -317C-268 -317 -200 88 264 215C728 342 796 747 796 747",
      "M-261 -325C-261 -325 -193 80 271 207C735 334 803 739 803 739",
      "M-254 -333C-254 -333 -186 72 278 199C742 326 810 731 810 731",
      "M-247 -341C-247 -341 -179 64 285 191C749 318 817 723 817 723",
      "M-240 -349C-240 -349 -172 56 292 183C756 310 824 715 824 715",
      "M-233 -357C-233 -357 -165 48 299 175C763 302 831 707 831 707",
      "M-226 -365C-226 -365 -158 40 306 167C770 294 838 699 838 699",
      "M-219 -373C-219 -373 -151 32 313 159C777 286 845 691 845 691",
      "M-212 -381C-212 -381 -144 24 320 151C784 278 852 683 852 683",
      "M-205 -389C-205 -389 -137 16 327 143C791 270 859 675 859 675",
      "M-198 -397C-198 -397 -130 8 334 135C798 262 866 667 866 667",
      "M-191 -405C-191 -405 -123 0 341 127C805 254 873 659 873 659",
      "M-184 -413C-184 -413 -116 -8 348 119C812 246 880 651 880 651",
      "M-177 -421C-177 -421 -109 -16 355 111C819 238 887 643 887 643",
      "M-170 -429C-170 -429 -102 -24 362 103C826 230 894 635 894 635",
      "M-163 -437C-163 -437 -95 -32 369 95C833 222 901 627 901 627",
      "M-156 -445C-156 -445 -88 -40 376 87C840 214 908 619 908 619",
      "M-149 -453C-149 -453 -81 -48 383 79C847 206 915 611 915 611",
      "M-142 -461C-142 -461 -74 -56 390 71C854 198 922 603 922 603",
      "M-135 -469C-135 -469 -67 -64 397 63C861 190 929 595 929 595",
      "M-128 -477C-128 -477 -60 -72 404 55C868 182 936 587 936 587",
      "M-121 -485C-121 -485 -53 -80 411 47C875 174 943 579 943 579",
      "M-114 -493C-114 -493 -46 -88 418 39C882 166 950 571 950 571",
      "M-107 -501C-107 -501 -39 -96 425 31C889 158 957 563 957 563",
      "M-100 -509C-100 -509 -32 -104 432 23C896 150 964 555 964 555",
      "M-93 -517C-93 -517 -25 -112 439 15C903 142 971 547 971 547",
      "M-86 -525C-86 -525 -18 -120 446 7C910 134 978 539 978 539",
      "M-79 -533C-79 -533 -11 -128 453 -1C917 126 985 531 985 531",
      "M-72 -541C-72 -541 -4 -136 460 -9C924 118 992 523 992 523",
      "M-65 -549C-65 -549 3 -144 467 -17C931 110 999 515 999 515",
      "M-58 -557C-58 -557 10 -152 474 -25C938 102 1006 507 1006 507",
      "M-51 -565C-51 -565 17 -160 481 -33C945 94 1013 499 1013 499",
      "M-44 -573C-44 -573 24 -168 488 -41C952 86 1020 491 1020 491",
      "M-37 -581C-37 -581 31 -176 495 -49C959 78 1027 483 1027 483",
    ];
    return (
      <div
        className={cn(
          "absolute  h-full w-full inset-0  [mask-size:40px] [mask-repeat:no-repeat] flex items-center justify-center",
          className
        )}
      >
        <svg
          className=" z-0 h-full w-full pointer-events-none absolute "
          width="100%"
          height="100%"
          viewBox="0 0 696 316"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M-380 -189C-380 -189 -312 216 152 343C616 470 684 875 684 875M-373 -197C-373 -197 -305 208 159 335C623 462 691 867 691 867M-366 -205C-366 -205 -298 200 166 327C630 454 698 859 698 859M-359 -213C-359 -213 -291 192 173 319C637 446 705 851 705 851M-352 -221C-352 -221 -284 184 180 311C644 438 712 843 712 843M-345 -229C-345 -229 -277 176 187 303C651 430 719 835 719 835M-338 -237C-338 -237 -270 168 194 295C658 422 726 827 726 827M-331 -245C-331 -245 -263 160 201 287C665 414 733 819 733 819M-324 -253C-324 -253 -256 152 208 279C672 406 740 811 740 811M-317 -261C-317 -261 -249 144 215 271C679 398 747 803 747 803M-310 -269C-310 -269 -242 136 222 263C686 390 754 795 754 795M-303 -277C-303 -277 -235 128 229 255C693 382 761 787 761 787M-296 -285C-296 -285 -228 120 236 247C700 374 768 779 768 779M-289 -293C-289 -293 -221 112 243 239C707 366 775 771 775 771M-282 -301C-282 -301 -214 104 250 231C714 358 782 763 782 763M-275 -309C-275 -309 -207 96 257 223C721 350 789 755 789 755M-268 -317C-268 -317 -200 88 264 215C728 342 796 747 796 747M-261 -325C-261 -325 -193 80 271 207C735 334 803 739 803 739M-254 -333C-254 -333 -186 72 278 199C742 326 810 731 810 731M-247 -341C-247 -341 -179 64 285 191C749 318 817 723 817 723M-240 -349C-240 -349 -172 56 292 183C756 310 824 715 824 715M-233 -357C-233 -357 -165 48 299 175C763 302 831 707 831 707M-226 -365C-226 -365 -158 40 306 167C770 294 838 699 838 699M-219 -373C-219 -373 -151 32 313 159C777 286 845 691 845 691M-212 -381C-212 -381 -144 24 320 151C784 278 852 683 852 683M-205 -389C-205 -389 -137 16 327 143C791 270 859 675 859 675M-198 -397C-198 -397 -130 8 334 135C798 262 866 667 866 667M-191 -405C-191 -405 -123 0 341 127C805 254 873 659 873 659M-184 -413C-184 -413 -116 -8 348 119C812 246 880 651 880 651M-177 -421C-177 -421 -109 -16 355 111C819 238 887 643 887 643M-170 -429C-170 -429 -102 -24 362 103C826 230 894 635 894 635M-163 -437C-163 -437 -95 -32 369 95C833 222 901 627 901 627M-156 -445C-156 -445 -88 -40 376 87C840 214 908 619 908 619M-149 -453C-149 -453 -81 -48 383 79C847 206 915 611 915 611M-142 -461C-142 -461 -74 -56 390 71C854 198 922 603 922 603M-135 -469C-135 -469 -67 -64 397 63C861 190 929 595 929 595M-128 -477C-128 -477 -60 -72 404 55C868 182 936 587 936 587M-121 -485C-121 -485 -53 -80 411 47C875 174 943 579 943 579M-114 -493C-114 -493 -46 -88 418 39C882 166 950 571 950 571M-107 -501C-107 -501 -39 -96 425 31C889 158 957 563 957 563M-100 -509C-100 -509 -32 -104 432 23C896 150 964 555 964 555M-93 -517C-93 -517 -25 -112 439 15C903 142 971 547 971 547M-86 -525C-86 -525 -18 -120 446 7C910 134 978 539 978 539M-79 -533C-79 -533 -11 -128 453 -1C917 126 985 531 985 531M-72 -541C-72 -541 -4 -136 460 -9C924 118 992 523 992 523M-65 -549C-65 -549 3 -144 467 -17C931 110 999 515 999 515M-58 -557C-58 -557 10 -152 474 -25C938 102 1006 507 1006 507M-51 -565C-51 -565 17 -160 481 -33C945 94 1013 499 1013 499M-44 -573C-44 -573 24 -168 488 -41C952 86 1020 491 1020 491M-37 -581C-37 -581 31 -176 495 -49C959 78 1027 483 1027 483M-30 -589C-30 -589 38 -184 502 -57C966 70 1034 475 1034 475M-23 -597C-23 -597 45 -192 509 -65C973 62 1041 467 1041 467M-16 -605C-16 -605 52 -200 516 -73C980 54 1048 459 1048 459M-9 -613C-9 -613 59 -208 523 -81C987 46 1055 451 1055 451M-2 -621C-2 -621 66 -216 530 -89C994 38 1062 443 1062 443M5 -629C5 -629 73 -224 537 -97C1001 30 1069 435 1069 435M12 -637C12 -637 80 -232 544 -105C1008 22 1076 427 1076 427M19 -645C19 -645 87 -240 551 -113C1015 14 1083 419 1083 419"
            stroke="url(#paint0_radial_242_278)"
            strokeOpacity="0.05"
            strokeWidth="0.5"
          ></path>

          {paths.map((path, index) => (
            <motion.path
              key={`path-` + index}
              d={path}
              stroke={`url(#linearGradient-${index})`}
              strokeOpacity="0.4"
              strokeWidth="0.5"
            ></motion.path>
          ))}
          <defs>
            {paths.map((path, index) => (
              <motion.linearGradient
                id={`linearGradient-${index}`}
                key={`gradient-${index}`}
                initial={{
                  x1: "0%",
                  x2: "0%",
                  y1: "0%",
                  y2: "0%",
                }}
                animate={{
                  x1: ["0%", "100%"],
                  x2: ["0%", "95%"],
                  y1: ["0%", "100%"],
                  y2: ["0%", `${93 + Math.random() * 8}%`],
                }}
                transition={{
                  duration: Math.random() * 10 + 10,
                  ease: "easeInOut",
                  repeat: Infinity,
                  delay: Math.random() * 10,
                }}
              >
                <stop stopColor="#18CCFC" stopOpacity="0"></stop>
                <stop stopColor="#18CCFC"></stop>
                <stop offset="32.5%" stopColor="#6344F5"></stop>
                <stop offset="100%" stopColor="#AE48FF" stopOpacity="0"></stop>
              </motion.linearGradient>
            ))}

            <radialGradient
              id="paint0_radial_242_278"
              cx="0"
              cy="0"
              r="1"
              gradientUnits="userSpaceOnUse"
              gradientTransform="translate(352 34) rotate(90) scale(555 1560.62)"
            >
              <stop offset="0.0666667" stopColor="var(--neutral-300)"></stop>
              <stop offset="0.243243" stopColor="var(--neutral-300)"></stop>
              <stop offset="0.43594" stopColor="white" stopOpacity="0"></stop>
            </radialGradient>
          </defs>
        </svg>
      </div>
    );
  }
);

BackgroundBeams.displayName = "BackgroundBeams";



---
File: /examples/coagents-ai-researcher/ui/components/ui/button.tsx
---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



---
File: /examples/coagents-ai-researcher/ui/components/ui/card.tsx
---

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



---
File: /examples/coagents-ai-researcher/ui/components/ui/input.tsx
---

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



---
File: /examples/coagents-ai-researcher/ui/components/ui/meteors.tsx
---

import { cn } from "@/lib/utils";
import React from "react";

export const Meteors = ({
  number,
  className,
}: {
  number?: number;
  className?: string;
}) => {
  const meteors = new Array(number || 20).fill(true);
  return (
    <>
      {meteors.map((el, idx) => (
        <span
          key={"meteor" + idx}
          className={cn(
            "animate-meteor-effect absolute top-1/2 left-1/2 h-0.5 w-0.5 rounded-[9999px] bg-slate-500 shadow-[0_0_0_1px_#ffffff10] rotate-[215deg]",
            "before:content-[''] before:absolute before:top-1/2 before:transform before:-translate-y-[50%] before:w-[50px] before:h-[1px] before:bg-gradient-to-r before:from-[#64748b] before:to-transparent",
            className
          )}
          style={{
            top: 0,
            left: Math.floor(Math.random() * (400 - -400) + -400) + "px",
            animationDelay: Math.random() * (0.8 - 0.2) + 0.2 + "s",
            animationDuration: Math.floor(Math.random() * (10 - 2) + 2) + "s",
          }}
        ></span>
      ))}
    </>
  );
};



---
File: /examples/coagents-ai-researcher/ui/components/ui/skeleton.tsx
---

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



---
File: /examples/coagents-ai-researcher/ui/components/ui/textarea.tsx
---

import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



---
File: /examples/coagents-ai-researcher/ui/components/AnswerMarkdown.tsx
---

import Markdown from "react-markdown";

export function AnswerMarkdown({ markdown }: { markdown: string }) {
  return (
    <div className="markdown-wrapper">
      <Markdown>{markdown}</Markdown>
    </div>
  );
}



---
File: /examples/coagents-ai-researcher/ui/components/HomeView.tsx
---

"use client";

import { useState } from "react";
import { Textarea } from "./ui/textarea";
import { cn } from "@/lib/utils";
import { Button } from "./ui/button";
import { CornerDownLeftIcon } from "lucide-react";
import { useResearchContext } from "@/lib/research-provider";
import { motion } from "framer-motion";
import { useCopilotChat } from "@copilotkit/react-core";
import { Role, TextMessage } from "@copilotkit/runtime-client-gql";
import { useCoAgent } from "@copilotkit/react-core";

const MAX_INPUT_LENGTH = 250;

export function HomeView() {
  const { setResearchQuery, researchInput, setResearchInput } =
    useResearchContext();
  const [isInputFocused, setIsInputFocused] = useState(false);
  const { run: runResearchAgent } = useCoAgent({
    name: "search_agent",
  });

  const handleResearch = (query: string) => {
    setResearchQuery(query);
    runResearchAgent(query);
  };

  const suggestions = [
    { label: "Electric cars sold in 2024 vs 2023", icon: "🚙" },
    { label: "Top 10 richest people in the world", icon: "💰" },
    { label: "Population of the World", icon: "🌍 " },
    { label: "Weather in Seattle VS New York", icon: "⛅️" },
  ];

  return (
    <motion.div
      initial={{ opacity: 0, y: -50 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.4 }}
      className="h-screen w-full flex flex-col gap-y-2 justify-center items-center p-4 lg:p-0"
    >
      <h1 className="text-4xl font-extralight mb-6">
        What would you like to know?
      </h1>

      <div
        className={cn(
          "w-full bg-slate-100/50 border shadow-sm rounded-md transition-all",
          {
            "ring-1 ring-slate-300": isInputFocused,
          }
        )}
      >
        <Textarea
          placeholder="Ask anything..."
          className="bg-transparent p-4 resize-none focus-visible:ring-0 focus-visible:ring-offset-0 border-0 w-full"
          onFocus={() => setIsInputFocused(true)}
          onBlur={() => setIsInputFocused(false)}
          value={researchInput}
          onChange={(e) => setResearchInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              handleResearch(researchInput);
            }
          }}
          maxLength={MAX_INPUT_LENGTH}
        />
        <div className="text-xs p-4 flex items-center justify-between">
          <div
            className={cn("transition-all duration-300 mt-4 text-slate-500", {
              "opacity-0": !researchInput,
              "opacity-100": researchInput,
            })}
          >
            {researchInput.length} / {MAX_INPUT_LENGTH}
          </div>
          <Button
            size="sm"
            className={cn("rounded-full transition-all duration-300", {
              "opacity-0 pointer-events-none": !researchInput,
              "opacity-100": researchInput,
            })}
            onClick={() => handleResearch(researchInput)}
          >
            Research
            <CornerDownLeftIcon className="w-4 h-4 ml-2" />
          </Button>
        </div>
      </div>
      <div className="grid grid-cols-2 w-full gap-2 text-sm">
        {suggestions.map((suggestion) => (
          <div
            key={suggestion.label}
            onClick={() => handleResearch(suggestion.label)}
            className="p-2 bg-slate-100/50 rounded-md border col-span-2 lg:col-span-1 flex cursor-pointer items-center space-x-2 hover:bg-slate-100 transition-all duration-300"
          >
            <span className="text-base">{suggestion.icon}</span>
            <span className="flex-1">{suggestion.label}</span>
          </div>
        ))}
      </div>
    </motion.div>
  );
}



---
File: /examples/coagents-ai-researcher/ui/components/Progress.tsx
---

import { cn } from "@/lib/utils";
import { CheckIcon, LoaderCircle } from "lucide-react";

export function Progress({
  steps,
}: {
  steps: {
    description: string;
    status: "complete" | "done";
    updates: string[];
  }[];
}) {
  if (steps.length === 0) {
    return null;
  }

  return (
    <div>
      <div className="border border-slate-200 bg-slate-100/30 shadow-md rounded-lg overflow-hidden text-sm py-2">
        {steps.map((step, index) => (
          <div key={index} className="flex">
            <div className="w-8">
              <div className="w-4 h-4 bg-slate-700 flex items-center justify-center rounded-full mt-[10px] ml-[12px]">
                {step.status === "complete" ? (
                  <CheckIcon className="w-3 h-3 text-white" />
                ) : (
                  <LoaderCircle className="w-3 h-3 text-white animate-spin" />
                )}
              </div>
              {index < steps.length - 1 && (
                <div
                  className={cn("h-full w-[1px] bg-slate-200 ml-[20px]")}
                ></div>
              )}
            </div>
            <div className="flex-1 flex justify-center py-2 pl-2 pr-4">
              <div className="flex-1 flex items-center">{step.description}</div>
              <div className="text-slate-400">
                {step.updates?.length > 0 && step.updates[step.updates.length - 1]}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



---
File: /examples/coagents-ai-researcher/ui/components/ResearchWrapper.tsx
---

import { HomeView } from "./HomeView";
import { ResultsView } from "./ResultsView";
import { AnimatePresence } from "framer-motion";
import { useResearchContext } from "@/lib/research-provider";

export function ResearchWrapper() {
  const { researchQuery, setResearchInput } = useResearchContext();

  return (
    <>
      <div className="flex flex-col items-center justify-center relative z-10">
        <div className="flex-1">
          {researchQuery ? (
            <AnimatePresence
              key="results"
              onExitComplete={() => {
                setResearchInput("");
              }}
              mode="wait"
            >
              <ResultsView key="results" />
            </AnimatePresence>
          ) : (
            <AnimatePresence key="home" mode="wait">
              <HomeView key="home" />
            </AnimatePresence>
          )}
        </div>
        <footer className="text-xs p-2">
          <a
            href="https://copilotkit.ai"
            target="_blank"
            rel="noopener noreferrer"
            className="text-slate-600 font-medium hover:underline"
          >
            Powered by CopilotKit 🪁
          </a>
        </footer>
      </div>
    </>
  );
}



---
File: /examples/coagents-ai-researcher/ui/components/ResultsView.tsx
---

"use client";

import { useResearchContext } from "@/lib/research-provider";
import { motion } from "framer-motion";
import {
  BookOpenIcon,
  LoaderCircleIcon,
  SparkleIcon,
} from "lucide-react";
import { SkeletonLoader } from "./SkeletonLoader";
import { useCoAgent } from "@copilotkit/react-core";
import { Progress } from "./Progress";
import { AnswerMarkdown } from "./AnswerMarkdown";

export function ResultsView() {
  const { researchQuery } = useResearchContext();
  const { state: agentState } = useCoAgent({
    name: "search_agent",
  });

  console.log("AGENT_STATE", agentState);

  const steps =
    agentState?.steps?.map((step: any) => {
      return {
        description: step.description || "",
        status: step.status || "pending",
        updates: step.updates || [],
      };
    }) || [];

  const isLoading = !agentState?.answer?.markdown;

  return (
    <motion.div
      initial={{ opacity: 0, y: -50 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -50 }}
      transition={{ duration: 0.5, ease: "easeOut" }}
    >
      <div className="max-w-[1000px] p-8 lg:p-4 flex flex-col gap-y-8 mt-4 lg:mt-6 text-sm lg:text-base">
        <div className="space-y-4">
          <h1 className="text-3xl lg:text-4xl font-extralight">{researchQuery}</h1>
        </div>

        <Progress steps={steps} />

        <div className="grid grid-cols-12 gap-8">
          <div className="col-span-12 lg:col-span-8 flex flex-col">
            <h2 className="flex items-center gap-x-2">
              {isLoading ? (
                <LoaderCircleIcon className="animate-spin w-4 h-4 text-slate-500" />
              ) : (
                <SparkleIcon className="w-4 h-4 text-slate-500" />
              )}
              Answer
            </h2>
            <div className="text-slate-500 font-light">
              {isLoading ? (
                <SkeletonLoader />
              ) : (
                <AnswerMarkdown markdown={agentState?.answer?.markdown} />
              )}
            </div>
          </div>

          {agentState?.answer?.references?.length && (
            <div className="flex col-span-12 lg:col-span-4 flex-col gap-y-4 w-[200px]">
              <h2 className="flex items-center gap-x-2">
                <BookOpenIcon className="w-4 h-4 text-slate-500" />
                References
              </h2>
              <ul className="text-slate-900 font-light text-sm flex flex-col gap-y-2">
                {agentState?.answer?.references?.map(
                  (ref: any, idx: number) => (
                    <li key={idx}>
                      <a
                        href={ref.url}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        {idx + 1}. {ref.title}
                      </a>
                    </li>
                  )
                )}
              </ul>
            </div>
          )}
        </div>
      </div>
    </motion.div>
  );
}



---
File: /examples/coagents-ai-researcher/ui/components/SkeletonLoader.tsx
---

import { Skeleton } from "@/components/ui/skeleton";

export function SkeletonLoader() {
  return (
    <div className="grid grid-cols-10 gap-x-2 gap-y-4">
      <Skeleton className="h-4 col-span-2" />
      <Skeleton className="h-4 col-span-4" />
      <Skeleton className="h-4 col-span-4" />

      <Skeleton className="h-4 col-span-4" />
      <Skeleton className="h-4 col-span-6" />

      <Skeleton className="h-4 col-span-3" />
      <Skeleton className="h-4 col-span-3" />
      <Skeleton className="h-4 col-span-4" />

      <Skeleton className="h-4 col-span-5" />
      <Skeleton className="h-4 col-span-3" />
      <Skeleton className="h-4 col-span-2" />

      <Skeleton className="h-4 col-span-2" />
      <Skeleton className="h-4 col-span-4" />
      <Skeleton className="h-4 col-span-3" />
      <Skeleton className="h-4 col-span-1" />
    </div>
  )
}


---
File: /examples/coagents-ai-researcher/ui/lib/research-provider.tsx
---

import { createContext, useContext, useState, ReactNode, useEffect } from "react";

type ResearchContextType = {
  researchQuery: string;
  setResearchQuery: (query: string) => void;
  researchInput: string;
  setResearchInput: (input: string) => void;
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  researchResult: ResearchResult | null;
  setResearchResult: (result: ResearchResult) => void;
};

type ResearchResult = {
  answer: string;
  sources: string[];
}

const ResearchContext = createContext<ResearchContextType | undefined>(undefined);

export const ResearchProvider = ({ children }: { children: ReactNode }) => {
  const [researchQuery, setResearchQuery] = useState<string>("");
  const [researchInput, setResearchInput] = useState<string>("");
  const [researchResult, setResearchResult] = useState<ResearchResult | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  useEffect(() => {
    if (!researchQuery) {
      setResearchResult(null);
      setResearchInput("");
    }
  }, [researchQuery, researchResult]);

  return (
    <ResearchContext.Provider
      value={{
        researchQuery,
        setResearchQuery,
        researchInput,
        setResearchInput,
        isLoading,
        setIsLoading,
        researchResult,
        setResearchResult,
      }}
    >
      {children}
    </ResearchContext.Provider>
  );
};

export const useResearchContext = () => {
  const context = useContext(ResearchContext);
  if (context === undefined) {
    throw new Error("useResearchContext must be used within a ResearchProvider");
  }
  return context;
};


---
File: /examples/coagents-ai-researcher/ui/lib/utils.ts
---

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



---
File: /examples/coagents-ai-researcher/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-qa/agent/my_agent/__init__.py
---




---
File: /examples/coagents-qa/agent/my_agent/agent.py
---

"""Test Q&A Agent"""

import os
from typing import Any, cast
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langgraph.graph import StateGraph, END
from langgraph.graph import MessagesState
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.runnables import RunnableConfig
from langchain_core.messages import HumanMessage, ToolMessage
from copilotkit.langchain import (
  copilotkit_customize_config, copilotkit_exit, copilotkit_emit_message
)
from pydantic import BaseModel, Field


def get_model():
    """
    Get a model based on the environment variable.
    """
    model = os.getenv("MODEL", "openai")

    if model == "openai":
        return ChatOpenAI(temperature=0, model="gpt-4o")
    if model == "anthropic":
        return ChatAnthropic(
            temperature=0,
            model_name="claude-3-5-sonnet-20240620",
            timeout=None,
            stop=None
        )

    raise ValueError("Invalid model specified")


class EmailAgentState(MessagesState):
    """Email Agent State"""
    email: str

class EmailTool(BaseModel):
    """
    Write an email.
    """
    the_email: str = Field(description="The email to be written.")


async def email_node(state: EmailAgentState, config: RunnableConfig):
    """
    Write an email.
    """

    config = copilotkit_customize_config(
        config,
        emit_tool_calls=True,
    )

    instructions = "You write emails."

    email_model = get_model().bind_tools(
        [EmailTool],
        tool_choice="EmailTool"
    )

    response = await email_model.ainvoke([
        *state["messages"],
        HumanMessage(
            content=instructions
        )
    ], config)

    tool_calls = cast(Any, response).tool_calls

    email = tool_calls[0]["args"]["the_email"]

    return {
        "email": email,
    }

async def send_email_node(state: EmailAgentState, config: RunnableConfig):
    """
    Send an email.
    """

    config = copilotkit_customize_config(
        config,
        emit_messages=True,
    )


    await copilotkit_exit(config)

    # get the last message and cast to ToolMessage
    last_message = cast(ToolMessage, state["messages"][-1])
    if last_message.content == "CANCEL":
        await copilotkit_emit_message(config, "❌ Cancelled sending email.")
    else:
        await copilotkit_emit_message(config, "✅ Sent email.")


    return {
        "messages": state["messages"],
    }


workflow = StateGraph(EmailAgentState)
workflow.add_node("email_node", email_node)
workflow.add_node("send_email_node", send_email_node)
workflow.set_entry_point("email_node")

workflow.add_edge("email_node", "send_email_node")
workflow.add_edge("send_email_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory, interrupt_after=["email_node"])



---
File: /examples/coagents-qa/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="email_agent",
            description="This agent sends emails",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-qa/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-qa/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-qa/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-qa/ui/app/Mailer.tsx
---

"use client";

import { useCopilotAction } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";

export function Mailer() {
  useCopilotAction({
    name: "EmailTool",
    disabled: true,
    parameters: [
      {
        name: "the_email",
      },
    ],
    renderAndWait: ({ args, status, handler }) => {
      return (
        <div className="p-4 bg-gray-100 rounded-lg">
          <div className="font-bold text-lg mb-2">Send this email?</div>
          <div className="text-gray-700">{args.the_email}</div>
          {status === "executing" && (
            <div className="mt-4 flex justify-end space-x-2">
              <button
                onClick={() => handler("CANCEL")}
                className="px-4 py-2 bg-slate-400 text-white rounded"
              >
                Cancel
              </button>
              <button
                onClick={() => handler("SEND")}
                className="px-4 py-2 bg-blue-500 text-white rounded"
              >
                Send
              </button>
            </div>
          )}
        </div>
      );
    },
  });

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="text-2xl">Email Q&A example</div>
      <div>e.g. write an email to the CEO of OpenAI asking for a meeting</div>

      <CopilotPopup defaultOpen={true} clickOutsideToClose={false} />
    </div>
  );
}



---
File: /examples/coagents-qa/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Mailer } from "./Mailer";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit">
        <Mailer />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-qa/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-qa-native/agent/my_agent/__init__.py
---




---
File: /examples/coagents-qa-native/agent/my_agent/agent.py
---

"""Test Q&A Agent"""

import os
from typing import Any, cast
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langgraph.graph import StateGraph, END
from langgraph.graph import MessagesState
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.runnables import RunnableConfig
from langchain_core.messages import HumanMessage, ToolMessage
from copilotkit.langchain import (
  copilotkit_customize_config, copilotkit_exit, copilotkit_emit_message
)
from pydantic import BaseModel, Field


def get_model():
    """
    Get a model based on the environment variable.
    """
    model = os.getenv("MODEL", "openai")

    if model == "openai":
        return ChatOpenAI(temperature=0, model="gpt-4o")
    if model == "anthropic":
        return ChatAnthropic(
            temperature=0,
            model_name="claude-3-5-sonnet-20240620",
            timeout=None,
            stop=None
        )

    raise ValueError("Invalid model specified")


class EmailAgentState(MessagesState):
    """Email Agent State"""
    email: str

class EmailTool(BaseModel):
    """
    Write an email.
    """
    the_email: str = Field(description="The email to be written.")


async def email_node(state: EmailAgentState, config: RunnableConfig):
    """
    Write an email.
    """

    config = copilotkit_customize_config(
        config,
        emit_tool_calls=True,
    )

    instructions = "You write emails."

    email_model = get_model().bind_tools(
        [EmailTool],
        tool_choice="EmailTool"
    )

    response = await email_model.ainvoke([
        *state["messages"],
        HumanMessage(
            content=instructions
        )
    ], config)

    tool_calls = cast(Any, response).tool_calls

    email = tool_calls[0]["args"]["the_email"]

    return {
        "email": email,
    }

async def send_email_node(state: EmailAgentState, config: RunnableConfig):
    """
    Send an email.
    """

    config = copilotkit_customize_config(
        config,
        emit_messages=True,
    )


    await copilotkit_exit(config)

    # get the last message and cast to ToolMessage
    last_message = cast(ToolMessage, state["messages"][-1])
    if last_message.content == "CANCEL":
        await copilotkit_emit_message(config, "❌ Cancelled sending email.")
    else:
        await copilotkit_emit_message(config, "✅ Sent email.")


    return {
        "messages": state["messages"],
    }


workflow = StateGraph(EmailAgentState)
workflow.add_node("email_node", email_node)
workflow.add_node("send_email_node", send_email_node)
workflow.set_entry_point("email_node")

workflow.add_edge("email_node", "send_email_node")
workflow.add_edge("send_email_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory, interrupt_after=["email_node"])



---
File: /examples/coagents-qa-native/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="email_agent",
            description="This agent sends emails",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-qa-native/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-qa-native/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-qa-native/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-qa-native/ui/app/Mailer.tsx
---

"use client";

import { useCopilotAction } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";

export function Mailer() {
  useCopilotAction({
    name: "EmailTool",
    disabled: true,
    parameters: [
      {
        name: "the_email",
      },
    ],

    handler: async ({ the_email }) => {
      const result = window.confirm(the_email);
      if (result) {
        return "SEND";
      } else {
        return "CANCEL";
      }
    },
  });

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="text-2xl">Email Q&A example</div>
      <div>e.g. write an email to the CEO of OpenAI asking for a meeting</div>

      <CopilotPopup defaultOpen={true} clickOutsideToClose={false} />
    </div>
  );
}



---
File: /examples/coagents-qa-native/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Mailer } from "./Mailer";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit">
        <Mailer />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-qa-native/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-qa-text/agent/my_agent/__init__.py
---




---
File: /examples/coagents-qa-text/agent/my_agent/agent.py
---

"""Test Q&A Agent"""

import os
from typing import cast
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langgraph.graph import StateGraph, END
from langgraph.graph import MessagesState
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.runnables import RunnableConfig
from langchain_core.messages import HumanMessage, AIMessage
from copilotkit.langchain import (
    copilotkit_exit,
    copilotkit_emit_message
)
from pydantic import BaseModel, Field

def get_model():
    """
    Get a model based on the environment variable.
    """
    model = os.getenv("MODEL", "openai")

    if model == "openai":
        return ChatOpenAI(temperature=0, model="gpt-4o")
    if model == "anthropic":
        return ChatAnthropic(
            temperature=0,
            model_name="claude-3-5-sonnet-20240620",
            timeout=None,
            stop=None
        )

    raise ValueError("Invalid model specified")


class GreetAgentState(MessagesState):
    """Greet Agent State"""
    name: str

class ExtractNameTool(BaseModel):
    """
    Extract the user's name from the message.
    Make sure to only set the name if you are 100 percent sure it is the name of the user.
    """
    name: str = Field(..., description="The user's name or UNKNOWN if you can't find it")

async def ask_name_node(state: GreetAgentState, config: RunnableConfig):
    """
    Ask the user for their name.
    """

    await copilotkit_emit_message(config, "Hey, what is your name? 🙂")

    return {
        "messages": state["messages"],
    }


async def extract_name_node(state: GreetAgentState, config: RunnableConfig):
    """
    Check if the user's name is in the message.
    """

    last_message = cast(HumanMessage, state["messages"][-1])


    instructions = (
        f"Figure out the user's name if possible from this response they gave you: {last_message.content}"
    )

    model = get_model().bind_tools(
        [ExtractNameTool],
        tool_choice="ExtractNameTool"
    )

    response = await model.ainvoke([
        *state["messages"],
        HumanMessage(
            content=instructions
        )
    ], config)

    tool_calls = cast(AIMessage, response).tool_calls
    name = None

    if tool_calls is not None:
        if tool_calls[0]["args"]["name"] != "UNKNOWN":
            name = tool_calls[0]["args"]["name"]

    if name is None:
        return {
            "messages": state["messages"],
        }

    return {
        "messages": state["messages"],
        "name": name,
    }

async def greet_node(state: GreetAgentState, config: RunnableConfig):
    """
    Greet the user by name.
    """

    await copilotkit_emit_message(config, "Hello, " + state["name"] + " 😎")

    await copilotkit_exit(config)

    return {
        "messages": state["messages"],
    }

def route(state: GreetAgentState):
    """Route to the appropriate node."""

    if state.get("name", None) is not None:
        return "greet_node"
    return "ask_name_node"

workflow = StateGraph(GreetAgentState)

workflow.add_node("ask_name_node", ask_name_node)
workflow.add_node("greet_node", greet_node)
workflow.add_node("extract_name_node", extract_name_node)

workflow.set_entry_point("ask_name_node")

workflow.add_edge("ask_name_node", "extract_name_node")
workflow.add_conditional_edges("extract_name_node", route)
workflow.add_edge("greet_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory, interrupt_after=["ask_name_node"])



---
File: /examples/coagents-qa-text/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="greeting_agent",
            description="This agent greets the user",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-qa-text/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-qa-text/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-qa-text/ui/app/Greeter.tsx
---

"use client";

import { CopilotPopup } from "@copilotkit/react-ui";

export function Greeter() {
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="text-2xl">Text Q&A example</div>
      <div>ask: "Greet me!"</div>

      <CopilotPopup defaultOpen={true} clickOutsideToClose={false} />
    </div>
  );
}



---
File: /examples/coagents-qa-text/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-qa-text/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Greeter } from "./Greeter";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit">
        <Greeter />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-qa-text/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-shared-state/agent/my_agent/__init__.py
---




---
File: /examples/coagents-shared-state/agent/my_agent/agent.py
---

"""
This is the main entry point for the AI.
It defines the workflow graph and the entry point for the agent.
"""
# pylint: disable=line-too-long, unused-import

import os
from typing import cast, TypedDict
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_core.messages import ToolMessage, AIMessage, HumanMessage, SystemMessage
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState
from copilotkit.langchain import copilotkit_customize_config

def get_model():
    """
    Get a model based on the environment variable.
    """
    model = os.getenv("MODEL", "openai")

    if model == "openai":
        return ChatOpenAI(temperature=0, model="gpt-4o")
    if model == "anthropic":
        return ChatAnthropic(
            temperature=0,
            model_name="claude-3-5-sonnet-20240620",
            timeout=None,
            stop=None
        )

    raise ValueError("Invalid model specified")

class Translations(TypedDict):
    """Contains the translations in four different languages."""
    translation_es: str
    translation_fr: str
    translation_de: str

class AgentState(MessagesState):
    """Contains the state of the agent."""
    translations: Translations
    input: str

async def translate_node(state: AgentState, config: RunnableConfig):
    """Chatbot that translates text"""

    config = copilotkit_customize_config(
        config,
        emit_messages=True,
        emit_intermediate_state=[
            {
                "state_key": "translations",
                "tool": "Translations"
            }
        ]
    )

    model = get_model().bind_tools(
        [Translations],
        tool_choice=(
            None if state["messages"] and
            isinstance(state["messages"][-1], HumanMessage)
            else "Translations"
        )
    )

    new_message = HumanMessage(
        content=f"""
        You are a helpful assistant that translates text to different languages 
        (Spanish, French and German).
        Don't ask for confirmation before translating.
        {
            'The user is currently working on translating this text: "' + 
            state["input"] + '"' if state.get("input") else ""
        }
        """
    )

    # remove system message and empty AI messages
    messages = [
        message for message in state["messages"]
        if not isinstance(message, SystemMessage) and 
        not (isinstance(message, AIMessage) and message.content == "")
    ]
    messages += [new_message]

    for message in messages:
        print(message)
        print(type(message))
        print("---")

    response = await model.ainvoke(messages, config)

    if hasattr(response, "tool_calls") and len(getattr(response, "tool_calls")) > 0:
        ai_message = cast(AIMessage, response)
        return {
            "messages": [
                new_message,
                response,
                ToolMessage(
                    content="Translated!",
                    tool_call_id=ai_message.tool_calls[0]["id"]
                )
            ],
            "translations": cast(AIMessage, response).tool_calls[0]["args"],
        }

    return {
        "messages": [
            new_message,
            response,
        ],
    }

workflow = StateGraph(AgentState)
workflow.add_node("translate_node", translate_node)
workflow.set_entry_point("translate_node")
workflow.add_edge("translate_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory)



---
File: /examples/coagents-shared-state/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="translate_agent",
            description="Translate agent that translates text.",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-shared-state/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-shared-state/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-shared-state/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-shared-state/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Translator } from "./Translator";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit" agent="translate_agent">
        <Translator />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-shared-state/ui/app/Translator.tsx
---

"use client";

import { useCoAgent, useCopilotChat } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";
import { TextMessage, MessageRole } from "@copilotkit/runtime-client-gql";

interface TranslateAgentState {
  input: string;
  translations?: {
    translation_es: string;
    translation_fr: string;
    translation_de: string;
  };
}

export function Translator() {
  const {
    state: translateAgentState,
    setState: setTranslateAgentState,
    run: runTranslateAgent,
  } = useCoAgent<TranslateAgentState>({
    name: "translate_agent",
    initialState: { input: "Hello World" },
  });

  const { isLoading } = useCopilotChat();

  console.log("state", translateAgentState);

  const handleTranslate = () => {
    runTranslateAgent("Translate to all languages");
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div>
        <input
          type="text"
          placeholder="Text to translate..."
          value={translateAgentState.input}
          onChange={(e) =>
            setTranslateAgentState({
              ...translateAgentState,
              input: e.target.value,
            })
          }
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              handleTranslate();
            }
          }}
          className="w-full p-2 border border-gray-300 rounded"
        />
        <button
          disabled={!translateAgentState.input || isLoading}
          onClick={handleTranslate}
          className="mt-2 w-full p-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
        >
          {isLoading ? "Translating..." : "Translate"}
        </button>
      </div>

      {translateAgentState.translations && (
        <div className="mt-8">
          <div>Spanish: {translateAgentState.translations.translation_es}</div>
          <div>French: {translateAgentState.translations.translation_fr}</div>
          <div>German: {translateAgentState.translations.translation_de}</div>
        </div>
      )}

      <CopilotPopup defaultOpen={true} />
    </div>
  );
}



---
File: /examples/coagents-shared-state/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-starter/agent/my_agent/__init__.py
---




---
File: /examples/coagents-starter/agent/my_agent/agent.py
---

"""
This is the main entry point for the AI.
It defines the workflow graph and the entry point for the agent.
"""
# pylint: disable=line-too-long, unused-import

import json
from typing import cast, TypedDict
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, ToolMessage, AIMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState
from copilotkit.langchain import copilotkit_customize_config

class Translations(TypedDict):
    """Contains the translations in four different languages."""
    translation_es: str
    translation_fr: str
    translation_de: str

class AgentState(MessagesState):
    """Contains the state of the agent."""
    translations: Translations
    input: str

async def translate_node(state: AgentState, config: RunnableConfig):
    """Chatbot that translates text"""

    config = copilotkit_customize_config(
        config,
        emit_messages=True,
        emit_intermediate_state=[
            {
                "state_key": "translations",
                "tool": "translate"
            }
        ]
    )

    model = ChatOpenAI(model="gpt-4o").bind_tools(
        [Translations],
        parallel_tool_calls=False,
        tool_choice=(
            None if state["messages"] and
            isinstance(state["messages"][-1], HumanMessage)
            else "Translations"
        )
    )

    response = await model.ainvoke([
        SystemMessage(
            content=f"""
            You are a helpful assistant that translates text to different languages 
            (Spanish, French and German).
            Don't ask for confirmation before translating.
            {
                'The user is currently working on translating this text: "' + 
                state["input"] + '"' if state.get("input") else ""
            }
            """
        ),
        *state["messages"],
    ], config)

    if hasattr(response, "tool_calls") and len(getattr(response, "tool_calls")) > 0:
        ai_message = cast(AIMessage, response)
        return {
            "messages": [
                response,
                ToolMessage(
                    content="Translated!",
                    tool_call_id=ai_message.tool_calls[0]["id"]
                )
            ],
            "translations": cast(AIMessage, response).tool_calls[0]["args"],
        }

    return {
        "messages": [           
            response,
        ],
    }

workflow = StateGraph(AgentState)
workflow.add_node("translate_node", translate_node)
workflow.set_entry_point("translate_node")
workflow.add_edge("translate_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory)



---
File: /examples/coagents-starter/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="translate_agent",
            description="Translate agent that translates text.",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-starter/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-starter/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-starter/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-starter/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Translator } from "./Translator";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit" agent="translate_agent">
        <Translator />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-starter/ui/app/Translator.tsx
---

"use client";

import { useCoAgent, useCopilotChat } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";
import { TextMessage, MessageRole } from "@copilotkit/runtime-client-gql";

interface TranslateAgentState {
  input: string;
  translations?: {
    translation_es: string;
    translation_fr: string;
    translation_de: string;
  };
}

export function Translator() {
  const {
    state: translateAgentState,
    setState: setTranslateAgentState,
    run: runTranslateAgent,
  } = useCoAgent<TranslateAgentState>({
    name: "translate_agent",
    initialState: { input: "Hello World" },
  });

  const { isLoading } = useCopilotChat();

  console.log("state", translateAgentState);

  const handleTranslate = () => {
    runTranslateAgent("Translate to all languages");
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div>
        <input
          type="text"
          placeholder="Text to translate..."
          value={translateAgentState.input}
          onChange={(e) =>
            setTranslateAgentState({
              ...translateAgentState,
              input: e.target.value,
            })
          }
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              handleTranslate();
            }
          }}
          className="w-full p-2 border border-gray-300 rounded"
        />
        <button
          disabled={!translateAgentState.input || isLoading}
          onClick={handleTranslate}
          className="mt-2 w-full p-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
        >
          {isLoading ? "Translating..." : "Translate"}
        </button>
      </div>

      {translateAgentState.translations && (
        <div className="mt-8">
          <div>Spanish: {translateAgentState.translations.translation_es}</div>
          <div>French: {translateAgentState.translations.translation_fr}</div>
          <div>German: {translateAgentState.translations.translation_de}</div>
        </div>
      )}

      <CopilotPopup defaultOpen={true} />
    </div>
  );
}



---
File: /examples/coagents-starter/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-streaming/agent/my_agent/__init__.py
---




---
File: /examples/coagents-streaming/agent/my_agent/agent.py
---

"""
This is the main entry point for the AI.
It defines the workflow graph and the entry point for the agent.
"""
# pylint: disable=line-too-long, unused-import

import json
from typing import cast, TypedDict
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, ToolMessage, AIMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import MessagesState
from copilotkit.langchain import copilotkit_customize_config

class Translations(TypedDict):
    """Contains the translations in four different languages."""
    translation_es: str
    translation_fr: str
    translation_de: str

class AgentState(MessagesState):
    """Contains the state of the agent."""
    translations: Translations
    input: str

async def translate_node(state: AgentState, config: RunnableConfig):
    """Chatbot that translates text"""

    config = copilotkit_customize_config(
        config,
        emit_messages=True,
        emit_intermediate_state=[
            {
                "state_key": "translations",
                "tool": "translate"
            }
        ]
    )

    model = ChatOpenAI(model="gpt-4o").bind_tools(
        [Translations],
        parallel_tool_calls=False,
        tool_choice=(
            None if state["messages"] and
            isinstance(state["messages"][-1], HumanMessage)
            else "Translations"
        )
    )

    response = await model.ainvoke([
        SystemMessage(
            content=f"""
            You are a helpful assistant that translates text to different languages 
            (Spanish, French and German).
            Don't ask for confirmation before translating.
            {
                'The user is currently working on translating this text: "' + 
                state["input"] + '"' if state.get("input") else ""
            }
            """
        ),
        *state["messages"],
    ], config)

    if hasattr(response, "tool_calls") and len(getattr(response, "tool_calls")) > 0:
        ai_message = cast(AIMessage, response)
        return {
            "messages": [
                response,
                ToolMessage(
                    content="Translated!",
                    tool_call_id=ai_message.tool_calls[0]["id"]
                )
            ],
            "translations": cast(AIMessage, response).tool_calls[0]["args"],
        }

    return {
        "messages": [           
            response,
        ],
    }

workflow = StateGraph(AgentState)
workflow.add_node("translate_node", translate_node)
workflow.set_entry_point("translate_node")
workflow.add_edge("translate_node", END)
memory = MemorySaver()
graph = workflow.compile(checkpointer=memory)



---
File: /examples/coagents-streaming/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="translate_agent",
            description="Translate agent that translates text.",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-streaming/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-streaming/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-streaming/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-streaming/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { Translator } from "./Translator";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit" agent="translate_agent">
        <Translator />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-streaming/ui/app/Translator.tsx
---

"use client";

import { useCoAgent, useCopilotChat } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";
import { TextMessage, MessageRole } from "@copilotkit/runtime-client-gql";

interface TranslateAgentState {
  input: string;
  translations?: {
    translation_es: string;
    translation_fr: string;
    translation_de: string;
  };
}

export function Translator() {
  const {
    state: translateAgentState,
    setState: setTranslateAgentState,
    run: runTranslateAgent,
  } = useCoAgent<TranslateAgentState>({
    name: "translate_agent",
    initialState: { input: "Hello World" },
  });

  const { isLoading } = useCopilotChat();

  console.log("state", translateAgentState);

  const handleTranslate = () => {
    runTranslateAgent("Translate to all languages");
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div>
        <input
          type="text"
          placeholder="Text to translate..."
          value={translateAgentState.input}
          onChange={(e) =>
            setTranslateAgentState({
              ...translateAgentState,
              input: e.target.value,
            })
          }
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              handleTranslate();
            }
          }}
          className="w-full p-2 border border-gray-300 rounded"
        />
        <button
          disabled={!translateAgentState.input || isLoading}
          onClick={handleTranslate}
          className="mt-2 w-full p-2 bg-blue-500 text-white rounded disabled:bg-gray-300"
        >
          {isLoading ? "Translating..." : "Translate"}
        </button>
      </div>

      {translateAgentState.translations && (
        <div className="mt-8">
          <div>Spanish: {translateAgentState.translations.translation_es}</div>
          <div>French: {translateAgentState.translations.translation_fr}</div>
          <div>German: {translateAgentState.translations.translation_de}</div>
        </div>
      )}

      <CopilotPopup defaultOpen={true} />
    </div>
  );
}



---
File: /examples/coagents-streaming/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;



---
File: /examples/coagents-wait-user-input/agent/my_agent/__init__.py
---




---
File: /examples/coagents-wait-user-input/agent/my_agent/agent.py
---

# Set up the state
from langgraph.graph import MessagesState, START

# Set up the tool
# We will have one real tool - a search tool
# We'll also have one "fake" tool - a "ask_human" tool
# Here we define any ACTUAL tools
from langchain_core.tools import tool
from langgraph.prebuilt import ToolNode
from copilotkit.langchain import copilotkit_customize_config


@tool
def search(query: str):
    """Call to surf the web."""
    # This is a placeholder for the actual implementation
    # Don't let the LLM know this though 😊
    return f"I looked up: {query}. Result: It's sunny in San Francisco, but you better look out if you're a Gemini 😈."


tools = [search]
tool_node = ToolNode(tools)

# Set up the model
#from langchain_anthropic import ChatAnthropic
from langchain_openai import ChatOpenAI

# model = ChatAnthropic(model="claude-3-5-sonnet-20240620")
model = ChatOpenAI(model="gpt-4o")

from pydantic import BaseModel


# We are going "bind" all tools to the model
# We have the ACTUAL tools from above, but we also need a mock tool to ask a human
# Since `bind_tools` takes in tools but also just tool definitions,
# We can define a tool definition for `ask_human`
class AskHuman(BaseModel):
    """Ask the human a question"""

    question: str


model = model.bind_tools(tools + [AskHuman])

# Define nodes and conditional edges


# Define the function that determines whether to continue or not
def should_continue(state):
    messages = state["messages"]
    last_message = messages[-1]
    # If there is no function call, then we finish
    if not last_message.tool_calls:
        return "end"
    # If tool call is asking Human, we return that node
    # You could also add logic here to let some system know that there's something that requires Human input
    # For example, send a slack message, etc
    elif last_message.tool_calls[0]["name"] == "AskHuman":
        return "ask_human"
    # Otherwise if there is, we continue
    else:
        return "continue"


# Define the function that calls the model
def call_model(state, config):

    config = copilotkit_customize_config(
        config,
        emit_tool_calls="AskHuman",
    )
    messages = state["messages"]
    response = model.invoke(messages, config=config)
    # We return a list, because this will get added to the existing list
    return {"messages": [response]}


# We define a fake node to ask the human
def ask_human(state):
    pass


# Build the graph

from langgraph.graph import END, StateGraph

# Define a new graph
workflow = StateGraph(MessagesState)

# Define the three nodes we will cycle between
workflow.add_node("agent", call_model)
workflow.add_node("action", tool_node)
workflow.add_node("ask_human", ask_human)

# Set the entrypoint as `agent`
# This means that this node is the first one called
workflow.add_edge(START, "agent")

# We now add a conditional edge
workflow.add_conditional_edges(
    # First, we define the start node. We use `agent`.
    # This means these are the edges taken after the `agent` node is called.
    "agent",
    # Next, we pass in the function that will determine which node is called next.
    should_continue,
    # Finally we pass in a mapping.
    # The keys are strings, and the values are other nodes.
    # END is a special node marking that the graph should finish.
    # What will happen is we will call `should_continue`, and then the output of that
    # will be matched against the keys in this mapping.
    # Based on which one it matches, that node will then be called.
    {
        # If `tools`, then we call the tool node.
        "continue": "action",
        # We may ask the human
        "ask_human": "ask_human",
        # Otherwise we finish.
        "end": END,
    },
)

# We now add a normal edge from `tools` to `agent`.
# This means that after `tools` is called, `agent` node is called next.
workflow.add_edge("action", "agent")

# After we get back the human response, we go back to the agent
workflow.add_edge("ask_human", "agent")

# Set up memory
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()

# Finally, we compile it!
# This compiles it into a LangChain Runnable,
# meaning you can use it as you would any other runnable
# We add a breakpoint BEFORE the `ask_human` node so it never executes
graph = workflow.compile(checkpointer=memory, interrupt_after=["ask_human"])



---
File: /examples/coagents-wait-user-input/agent/my_agent/demo.py
---

"""Demo"""

from dotenv import load_dotenv
load_dotenv() # pylint: disable=wrong-import-position

from fastapi import FastAPI
import uvicorn
from copilotkit.integrations.fastapi import add_fastapi_endpoint
from copilotkit import CopilotKitSDK, LangGraphAgent
from my_agent.agent import graph


app = FastAPI()
sdk = CopilotKitSDK(
    agents=[
        LangGraphAgent(
            name="weather_agent",
            description="This agent deals with everything weather related",
            agent=graph,
        )
    ],
)

add_fastapi_endpoint(app, sdk, "/copilotkit")

def main():
    """Run the uvicorn server."""
    uvicorn.run("my_agent.demo:app", host="127.0.0.1", port=8000, reload=True)



---
File: /examples/coagents-wait-user-input/ui/app/api/copilotkit/route.ts
---

import { NextRequest } from "next/server";
import {
  CopilotRuntime,
  OpenAIAdapter,
  copilotRuntimeNextJSAppRouterEndpoint,
} from "@copilotkit/runtime";
import OpenAI from "openai";

const openai = new OpenAI();
const serviceAdapter = new OpenAIAdapter({ openai });

const BASE_URL = process.env.REMOTE_ACTION_URL || "http://127.0.0.1:8000";

console.log("BASE_URL", BASE_URL);

const runtime = new CopilotRuntime({
  remoteActions: [
    {
      url: `${BASE_URL}/copilotkit`,
    },
  ],
});

export const POST = async (req: NextRequest) => {
  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter,
    endpoint: "/api/copilotkit",
  });

  return handleRequest(req);
};



---
File: /examples/coagents-wait-user-input/ui/app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;



---
File: /examples/coagents-wait-user-input/ui/app/layout.tsx
---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "CoAgents Starter",
  description: "CoAgents Starter",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="light">
      <body className={inter.className}>{children}</body>
    </html>
  );
}



---
File: /examples/coagents-wait-user-input/ui/app/page.tsx
---

"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { WaitForUserInput } from "./WaitForUserInput";
import "@copilotkit/react-ui/styles.css";

export default function Home() {
  return (
    <main className="flex flex-col items-center justify-between">
      <CopilotKit runtimeUrl="/api/copilotkit" agent="weather_agent">
        <WaitForUserInput />
      </CopilotKit>
    </main>
  );
}



---
File: /examples/coagents-wait-user-input/ui/app/WaitForUserInput.tsx
---

"use client";

import { useCopilotAction } from "@copilotkit/react-core";
import { CopilotPopup } from "@copilotkit/react-ui";

export function WaitForUserInput() {
  useCopilotAction({
    name: "AskHuman",
    disabled: true,
    parameters: [
      {
        name: "question",
      },
    ],
    handler: async ({ question }) => {
      return window.prompt(question);
    },
  });

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="text-2xl">LangGraph Wait For User Input Example</div>
      <div className="text-xs">
        (https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/wait-user-input/#agent)
      </div>
      <div>
        Use the search tool to ask the user where they are, then look up the
        weather there
      </div>

      <CopilotPopup defaultOpen={true} clickOutsideToClose={false} />
    </div>
  );
}



---
File: /examples/coagents-wait-user-input/ui/tailwind.config.ts
---

import type { Config } from "tailwindcss";
const plugin = require('tailwindcss/plugin')
const {
  default: flattenColorPalette,
} = require("tailwindcss/lib/util/flattenColorPalette");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: "true",
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        meteor: {
          "0%": {
            transform: "rotate(215deg) translateX(0)",
            opacity: "1",
          },
          "70%": {
            opacity: "1",
          },
          "100%": {
            transform: "rotate(215deg) translateX(-500px)",
            opacity: "0",
          },
        },
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "meteor-effect": "meteor 5s linear infinite",
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), addVariablesForColors, plugin(capitalizeFirstLetter)],
} satisfies Config;

function capitalizeFirstLetter({ addUtilities }: any) {
  const newUtilities = {
    '.capitalize-first:first-letter': {
      textTransform: 'uppercase',
    },
  }
  addUtilities(newUtilities, ['responsive', 'hover'])
}

function addVariablesForColors({ addBase, theme }: any) {
  let allColors = flattenColorPalette(theme("colors"));
  let newVars = Object.fromEntries(
    Object.entries(allColors).map(([key, val]) => [`--${key}`, val])
  );

  addBase({
    ":root": newVars,
  });
}

export default config;

